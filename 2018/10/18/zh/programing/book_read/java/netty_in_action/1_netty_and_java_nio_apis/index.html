<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>1.Netty and Java NIO APIs - Zoctan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Zoctan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zoctan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本章内容主要介绍：  Netty 架构 我们为什么需要非阻塞IO 阻塞IO vs 非阻塞IO 了解 JDK 的 NIO实现的问题和 Netty 的解决方法  前面关于 Netty 架构的省略。 异步的设计整个 Netty 的 API 都是异步的。异步处理并不新鲜，已经出现有一段时间了。在这些年里，IO 经常出现瓶颈，所以异步处理变得越来越重要。 在使用资源时调用异步处理可以变得更有效率，因为当任务"><meta property="og:type" content="blog"><meta property="og:title" content="1.Netty and Java NIO APIs"><meta property="og:url" content="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/"><meta property="og:site_name" content="Zoctan&#039;s Blog"><meta property="og:description" content="本章内容主要介绍：  Netty 架构 我们为什么需要非阻塞IO 阻塞IO vs 非阻塞IO 了解 JDK 的 NIO实现的问题和 Netty 的解决方法  前面关于 Netty 架构的省略。 异步的设计整个 Netty 的 API 都是异步的。异步处理并不新鲜，已经出现有一段时间了。在这些年里，IO 经常出现瓶颈，所以异步处理变得越来越重要。 在使用资源时调用异步处理可以变得更有效率，因为当任务"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/one_thread_handles_one_connection.png"><meta property="og:image" content="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/handling_multiple_connections.png"><meta property="og:image" content="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/scattered_read.png"><meta property="og:image" content="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/aggregate_write.png"><meta property="article:published_time" content="2018-10-17T16:00:00.000Z"><meta property="article:modified_time" content="2022-11-02T16:12:55.097Z"><meta property="article:author" content="Zoctan"><meta property="article:tag" content="zoctan,blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/one_thread_handles_one_connection.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/"},"headline":"1.Netty and Java NIO APIs","image":["https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/one_thread_handles_one_connection.png","https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/handling_multiple_connections.png","https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/scattered_read.png","https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/aggregate_write.png"],"datePublished":"2018-10-17T16:00:00.000Z","dateModified":"2022-11-02T16:12:55.097Z","author":{"@type":"Person","name":"Zoctan"},"publisher":{"@type":"Organization","name":"Zoctan's Blog","logo":{"@type":"ImageObject","url":"https://zoctan.github.io/img/logo.svg"}},"description":"本章内容主要介绍：  Netty 架构 我们为什么需要非阻塞IO 阻塞IO vs 非阻塞IO 了解 JDK 的 NIO实现的问题和 Netty 的解决方法  前面关于 Netty 架构的省略。 异步的设计整个 Netty 的 API 都是异步的。异步处理并不新鲜，已经出现有一段时间了。在这些年里，IO 经常出现瓶颈，所以异步处理变得越来越重要。 在使用资源时调用异步处理可以变得更有效率，因为当任务"}</script><link rel="canonical" href="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/"><link rel="alternate" href="https://zoctan.github.io/atom.xml" title="Zoctan&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><meta name="msvalidate.01" content="3A666EB8EB887659AE5D32D988405EF2"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RW91M7Y2GB" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RW91M7Y2GB")</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2018-10-17T16:00:00.000Z" title="10/18/2018, 12:00:00 AM">2018-10-18</time></span><span class="level-item">Updated&nbsp;<time datetime="2022-11-02T16:12:55.097Z" title="11/3/2022, 12:12:55 AM">2022-11-03</time></span><span class="level-item"><a class="link-muted" href="/categories/zh/">zh</a><span> / </span><a class="link-muted" href="/categories/zh/programing/">programing</a><span> / </span><a class="link-muted" href="/categories/zh/programing/book-read/">book read</a><span> / </span><a class="link-muted" href="/categories/zh/programing/book-read/java/">java</a></span><span class="level-item">27 minutes read (About 4075 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">1.Netty and Java NIO APIs</h1><div class="content"><p>本章内容主要介绍：</p><ul><li>Netty 架构</li><li>我们为什么需要非阻塞IO</li><li>阻塞IO vs 非阻塞IO</li><li>了解 JDK 的 NIO实现的问题和 Netty 的解决方法</li></ul><p>前面关于 Netty 架构的省略。</p><h1 id="异步的设计"><a href="#异步的设计" class="headerlink" title="异步的设计"></a>异步的设计</h1><p>整个 Netty 的 API 都是异步的。异步处理并不新鲜，已经出现有一段时间了。在这些年里，IO 经常出现瓶颈，所以异步处理变得越来越重要。</p><p>在使用资源时调用异步处理可以变得更有效率，因为当任务进行时，我们可以去干其他事，直到我们收到任务完成的信息。</p><span id="more"></span><h2 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h2><p>回调经常在异步处理中使用，回调被传入到方法中直到方法完成才执行。我们可以经常在 JavaScript 中看到异步回调，因为它是 JS 语言的核心。</p><p>以下代码展示了当获取到数据后使用的回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FetchCallback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(Data data)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable cause)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fetcher</span> &#123;</span><br><span class="line">    <span class="comment">// 该 FetchCallback 类型参数有两个回调方法：</span></span><br><span class="line">    <span class="comment">// onData ：接收到数据后的操作</span></span><br><span class="line">    <span class="comment">// onError：出错后的操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fetchData</span><span class="params">(FetchCallback callback)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Fetcher</span> <span class="variable">fetcher</span> <span class="operator">=</span> ...</span><br><span class="line">        fetcher.fetchData(<span class="keyword">new</span> <span class="title class_">FetchCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(Data data)</span> &#123;</span><br><span class="line">                <span class="comment">// 接收到数据</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">                <span class="comment">// 出现错误</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果写过 Android，应该对以上代码很熟悉。</p><p>有个问题就是，当你使用一大堆异步方法并回调时，就会出现很多意大利面式的冗余代码。一些人会认为这会导致代码的难读，但我认为这更多的是影响代码的风格。比如 Node.js，它基于 JavaScript，变得越来越流行。它就使用了大量的回调，但依然有很多人觉得很好读很好写。</p><h2 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h2><p>第二种就是使用 Futures。Future 是抽象，是对将要变得可用的值的呈现。</p><p>Future 接口在 java.util.concurrent 包中，通过为异步处理服务的 Executor 进行使用。</p><p>以下例子中，我们传入了 Runnable 对象给 ExecutorService.submit() 方法，方法会返回 Future 对象给我们，利用它我们可以检查到方法是否执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; doSomeHeavyWork();</span><br><span class="line"><span class="comment">// 带返回值</span></span><br><span class="line">Callable&lt;Integer&gt; task2 = () -&gt; doSomeHeavyWorkWithResult();</span><br><span class="line"><span class="comment">// 提交执行</span></span><br><span class="line">Future&lt;?&gt; future1 = executor.submit(task1);</span><br><span class="line">Future&lt;Integer&gt; future2 = executor.submit(task2);</span><br><span class="line"><span class="comment">// 循环查看是否完成</span></span><br><span class="line"><span class="keyword">while</span> (!future1.isDone() || !future2.isDone()) &#123;</span><br><span class="line">    <span class="comment">// 完成之后做些什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们尝试将回调例子改造一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fetcher</span> &#123;</span><br><span class="line">    Future&lt;Data&gt; <span class="title function_">fetchData</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Fetcher</span> <span class="variable">fetcher</span> <span class="operator">=</span> ...</span><br><span class="line">        Future&lt;Data&gt; future = fetcher.fetchData();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!future.isDone())&#123;</span><br><span class="line">                <span class="comment">// 完成之后做些什么</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接收到数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Data received: &quot;</span>+ future.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable cause)&#123;</span><br><span class="line">            <span class="comment">// 出现错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候用 Futures 会感到很恶心，因为你需要每隔一段时间检查一下是否完成，而通过回调你可以第一时间收到完成消息。</p><p>通过以上两个关于异步执行的例子，你也许会想哪一种会比较好。这里没有明确的答案。如果使用 Netty，它将为你提供最好的操作。</p><h1 id="JVM-中-阻塞IO-vs-非阻塞IO"><a href="#JVM-中-阻塞IO-vs-非阻塞IO" class="headerlink" title="JVM 中 阻塞IO vs 非阻塞IO"></a>JVM 中 阻塞IO vs 非阻塞IO</h1><p>早期的 Java 1.4 就有了 NIO 的 API，而 Java7 则提供了新的 NIO.2 API，其包含更多高层次的 API。</p><p>如果要用 Java 写和网络相关的程序，有两种方法：</p><ol><li>使用 IO，也叫 阻塞 IO</li><li>使用 NIO，也叫 新&#x2F;非阻塞 IO</li></ol><blockquote><p>New 还是 Non-Blocking？<br>NIO 的 N 很明显应该是 Non-Blocking。因为 NIO 出现很久了，没人会说它是 New 的了。</p></blockquote><p>一个线程处理一个连接，它们是 1:1 的关系，因此在 JVM 中会限制你可以创建的线程数。</p><p><img src="/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/one_thread_handles_one_connection.png" alt="阻塞 IO" loading="lazy"></p><p>非阻塞 IO 则可以让你使用一个 selector 处理多个连接，它们是 1:n 的关系。</p><p><img src="/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/handling_multiple_connections.png" alt="非阻塞 IO" loading="lazy"></p><p>请记住上面的关系图，让我们更深入阻塞和非阻塞。</p><p>接下来我们将写一个简单的 echo 服务端去描述这两种 IO 的不同。</p><h2 id="基于阻塞-IO-的-echo-服务端"><a href="#基于阻塞-IO-的-echo-服务端" class="headerlink" title="基于阻塞 IO 的 echo 服务端"></a>基于阻塞 IO 的 echo 服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlainEchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> socket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;Accepted connection from&quot;</span> + clientSocket);</span><br><span class="line">                <span class="comment">// 每个新连接都要开启一个线程</span></span><br><span class="line">                <span class="comment">// 和使用线程池的本质是一样的</span></span><br><span class="line">                <span class="comment">// 一旦需要处理成千上万的并发连接，就会出现灾难</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(clientSocket.getInputStream()));</span><br><span class="line">                        <span class="comment">// 将读到的数据写回去</span></span><br><span class="line">                        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                            writer.println(reader.readLine());</span><br><span class="line">                            writer.flush();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            clientSocket.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非阻塞-IO-基础"><a href="#非阻塞-IO-基础" class="headerlink" title="非阻塞 IO 基础"></a>非阻塞 IO 基础</h2><p>Java7 提供的新 NIO API 被称为 NIO.2，当然你也可以用 NIO。</p><p>尽管新的 API 也是异步的，但在实现和对外接口上并不完全相同，但都有相同的特性。比如，两者的实现都使用了名为 ByteBuffer 的抽象作为数据容器。</p><hr><p>ByteBuffer</p><p>ByteBuffer 是新旧 NIO API 的基础，对于 Netty 来说也是。ByteBuffer 内存可以被分配在堆上，或在直接内存上，这意味着它可以被存储在堆空间以外。通常，当将它传到 channel 上时，在直接内存上的访问会更快，但分配和回收的花费会更高。</p><p>ByteBuffer 允许相同数据在 ByteBuffer 实例间分享，而不用去做内存拷贝。它还支持切片和其他操作去限制数据的可见性。</p><p>ByteBuffer 的典型使用场景：</p><ul><li>向 ByteBuffer 写数据</li><li>调用 ByteBuffer.flip() 切换读写模式</li><li>从 ByteBuffer 读数据</li><li>调用 ByteBuffer.clear() 清除整个 ByteBuffer</li><li>调用 ByteBuffer.compact() 清除已从内存拷贝中读取的数据</li></ul><p>当你向 ByteBuffer 写入数据时，它会去更新缓存已写的下标位置（即每写1个数据，position+1）；当然你也可以手动完成。</p><p>当你准备好读取数据时，可以调用 ByteBuffer.flip() 把写模式切换到读模式。调用 ByteBuffer.flip() 会将 ByteBuffer 的 limit 设置为当前 position，并更新 position &#x3D; 0。这样你就可以读取 ByteBuffer 的所有数据了。</p><p>ByteBuffer.compact() 将所有未读取的数据移动到 ByteBuffer 开头，然后调整 position。</p><p>下面是使用的场景例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">inChannel</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 从 Channel 中读取数据到 ByteBuffer</span></span><br><span class="line">    byteRead = inChannel.read(buf);</span><br><span class="line">    <span class="keyword">if</span> (byteRead != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 切换到读模式</span></span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">            <span class="comment">// 读取 ByteBuffer 的字节</span></span><br><span class="line">            <span class="comment">// 每次 get() 会更新 position+1</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) buf.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使 ByteBuffer 准备下一次写</span></span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (byteRead != -<span class="number">1</span>);</span><br><span class="line">inChannel.close();</span><br></pre></td></tr></table></figure><p>现在基本了解了 ByteBuffer，下一步让我们认识 selectors。</p><hr><p>NIO Selector</p><p>selector 是决定一个或多个 channels 是否准备好 读或写的 NIO 组件。单个 selector 可以被用于处理多个连接，可以缓和阻塞IO下1个线程处理1个连接的模型需求。</p><p>要使用 selector，你需要完成以下步骤：</p><ol><li>创建一个或多个 selectors 去给已开启的 channels（sockets）进行注册。</li><li>当一个 channel 被注册了，要去指定需要监听的事件。以下是可以监听的四种事件（或操作）：</li></ol><ul><li>OP_ACCEPT：连接 accept</li><li>OP_CONNECT：连接 connect</li><li>OP_READ：读</li><li>OP_WRITE：写</li></ul><ol start="3"><li>当多个 channels 被注册了，可以调用 Selector.select() 方法去阻塞，直到这些事件中的一个发生。</li><li>当方法不阻塞了，你就可以获得所有的 SelectionKey 实例（它们有注册 channel 的引用和选定的监听事件）。一个 SelectedKey 可以包含多个事件。</li></ol><p>为了看它是怎么工作的，让我们实现一个非阻塞版本的 echo 服务端。</p><h2 id="基于-NIO-的-echo-的服务端"><a href="#基于-NIO-的-echo-的服务端" class="headerlink" title="基于 NIO 的 echo 的服务端"></a>基于 NIO 的 echo 的服务端</h2><p>该版本的服务端使用异步 NIO API，可以让一个线程处理上千个并发客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlainNioEchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Listening for connections on port: &quot;</span> + port);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> serverChannel.socket();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port);</span><br><span class="line">        <span class="comment">// 绑定端口地址</span></span><br><span class="line">        ss.bind(address);</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 把 channel 注册到 selector，并关注连接的 accept 事件</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞直到被选中</span></span><br><span class="line">                selector.select();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获得所有 SelectedKey 的实例</span></span><br><span class="line">            <span class="type">Set</span> <span class="variable">readyKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> readyKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> (SelectionKey) iterator.next();</span><br><span class="line">                <span class="comment">// 将 SelectedKey 移出迭代器</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 接受客户端的连接</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                        System.out.println(<span class="string">&quot;Accepted connection from &quot;</span> + client);</span><br><span class="line">                        client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">// 把连接注册到 selector 并设置 ByteBuffer</span></span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">100</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 检查 SelectedKey 是否可读</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">output</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="comment">// 将数据读到 ByteBuffer</span></span><br><span class="line">                        client.read(output);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 检查 SelectedKey 是否可写</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">output</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                        output.flip();</span><br><span class="line">                        <span class="comment">// 将 ByteBuffer 里的数据写到 channel</span></span><br><span class="line">                        client.write(output);</span><br><span class="line">                        output.compact();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    key.channel();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子比之前的 echo 服务端版本都要复杂。但这种复杂是一种权衡。异步代码明显要比同步部分复杂。</p><p>下面我们要实现 NIO.2 版本的 echo 服务端。</p><h2 id="基于-NIO-2-的-echo-服务端"><a href="#基于-NIO-2-的-echo-服务端" class="headerlink" title="基于 NIO.2 的 echo 服务端"></a>基于 NIO.2 的 echo 服务端</h2><p>不像原生 NIO 的实现，NIO.2 允许你发出 IO 操作和提供一个完成时的处理器（CompletionHandler 类）。这个完成时处理器会在 IO 操作完成后执行，完成时处理器的执行是由底层系统驱动的，开发者不用关心它的实现。而且支持在同一时间只执行一个在 channel 中的 CompletionHandler。这可以帮助简化代码，因为它除去了多线程执行带来的复杂度。</p><p>原生 NIO 和 NIO.2 的最主要不同点：你不必去检查一个在 channel 中的事件是否发生了，然后再去触发一些动作。</p><p>在 NIO.2 中，你只需要触发 IO 操作，和注册一个完成时处理器给它，这个处理器会在操作完成的第一时间得到通知。这可以移除你在自己程序里写逻辑去检查操作完成的必要。</p><p>现在让我们看下同样是异步 echo 服务端，用 NIO.2 实现是怎样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlainNio2EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Listening for connections on port &quot;</span> + port);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port);</span><br><span class="line">        <span class="comment">// 绑定端口地址</span></span><br><span class="line">        serverChannel.bind(address);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 开始接受新的客户端连接</span></span><br><span class="line">        <span class="comment">// 一旦有一个客户端被 accepted，CompletionHandler 就会被调用</span></span><br><span class="line">        serverChannel.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel channel, Object attachment)</span> &#123;</span><br><span class="line">                <span class="comment">// 再一次接受新的客户端连接</span></span><br><span class="line">                serverChannel.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// 在 channel 中触发读操作</span></span><br><span class="line">                <span class="comment">// 一旦读到什么 CompletionHandler 就会第一时间被通知</span></span><br><span class="line">                channel.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">EchoCompletionHandler</span>(channel));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable throwable, Object attachment)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有错误就关闭套接字</span></span><br><span class="line">                    serverChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EchoCompletionHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel channel;</span><br><span class="line"></span><br><span class="line">        EchoCompletionHandler(AsynchronousSocketChannel channel) &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 在 channel 中触发写操作</span></span><br><span class="line">            <span class="comment">// 一旦写了什么 CompletionHandler 就会第一时间被通知</span></span><br><span class="line">            channel.write(buffer, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// 如果还有东西在 ByteBuffer 中</span></span><br><span class="line">                        <span class="comment">// 就再次触发写操作</span></span><br><span class="line">                        channel.write(buffer, buffer, <span class="built_in">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        buffer.compact();</span><br><span class="line">                        channel.read(buffer, buffer, EchoCompletionHandler.<span class="built_in">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼看上去，比之前使用 NIO 的代码更多了。但要注意到 NIO.2 为你处理好了线程和事件循环的创建。这会简化在创建多线程 NIO 程序时的代码，尽管在这个例子中不太明显。随着程序变得越来越复杂，你产出的代码将会更简洁，简化效果会变得越来越明显。</p><p>下一步我们看看 JDK 的 NIO 存在的一些问题。</p><h1 id="NIO-问题以及-Netty-是如何解决的"><a href="#NIO-问题以及-Netty-是如何解决的" class="headerlink" title="NIO 问题以及 Netty 是如何解决的"></a>NIO 问题以及 Netty 是如何解决的</h1><h2 id="跨平台和兼容性问题"><a href="#跨平台和兼容性问题" class="headerlink" title="跨平台和兼容性问题"></a>跨平台和兼容性问题</h2><p>NIO 比较底层，取决于操作系统是如何处理 IO 的。Java 有统一的 API，这让它可以在所有操作系统上都能工作。</p><p>当你使用 NIO 时，你可能会发现在 Linux 下的代码工作正常，但在 Windows 下却有问题。我的建议就是，即使你不使用 NIO，你要想支持所有操作系统，你都要进行测试。所以就算所有的测试在你的 Linux 下都通过了，也要在其他操作系统上进行验证。如果你不打算这样，那就有得你爽喽。</p><p>NIO.2 只支持 Java7 以上，如果你在 Java6 以下，那就用不了了。而且，在写这篇文章时，NIO.2 还没有支持 datagram channels（针对 UDP 协议），所以只能限制使用 TCP 协议。</p><p>Netty 解决了这个问题，可以运行在 Java6 和 7 上。不用再担心向下兼容，而且还能享受到简单统一的 API。</p><h2 id="ByteBuffer-可扩展性"><a href="#ByteBuffer-可扩展性" class="headerlink" title="ByteBuffer 可扩展性"></a>ByteBuffer 可扩展性</h2><p>如你所见，ByteBuffer 是数据的容器。不幸的是，JDK 没有包含 ByteBuffer 的实现，所以不支持对 ByteBuffer 实例的封装。如果你想压缩内存拷贝，这会很有用。如果你还是想“我自己实现它“。不用浪费你的时间，ByteBuffer 的构造器是私有的，所以不太可能进行扩展。</p><p>Netty 提供了自己的 ByteBuffer 实现，打破了上面的限制，而且通过提供一些构造方法，使用，和生成方法 API。</p><h2 id="分散和聚集可能内存泄漏"><a href="#分散和聚集可能内存泄漏" class="headerlink" title="分散和聚集可能内存泄漏"></a>分散和聚集可能内存泄漏</h2><p>许多 channel 的实现支持分散和聚集。这个特性可以让多个 ByteBuffer 实例在同一时间写入或读出，从而提高性能。这是内核&#x2F;OS进行的读&#x2F;写处理，因为更接近底层，所以可以更高效。</p><p>在你想切割不同 ByteBuffer 实例去分别处理缓存时，通常就要使用分散&#x2F;聚集。比如你想在一个 ByteBuffer 中放入 header，而把 body 放到其他 ByteBuffer。</p><p>下图就展示了分散读是怎样的：</p><p><img src="/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/scattered_read.png" alt="分散读" loading="lazy"></p><p>传入一组 ByteBuffer 实例到 ScatteringByteChannel，然后数据就会从 channel 分散读到 buffer。</p><p>写也差不多，只是数据是从 buffer 写到 channel：</p><p><img src="/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/aggregate_write.png" alt="聚集写" loading="lazy"></p><p>传入一组 ByteBuffer 实例到 GatheringByteChannel.write() 方法，然后数据就会从 buffer 写到 channel。</p><p>不幸的是，这特性可能会导致内存泄露，从而引发 OutOfMemoryError，所以你要谨慎使用分散&#x2F;聚集。</p><h2 id="著名的-epoll-bug"><a href="#著名的-epoll-bug" class="headerlink" title="著名的 epoll bug"></a>著名的 epoll bug</h2><p>在类 Linux 操作系统中，selector 使用 epoll - IO 事件发现。这是一种可以让操作系统在网络栈中异步工作的高性能技术。但直到今天，epoll 仍然有一个可以让 selector 变为 invalid 状态的 bug，会导致 CPU 占用达到100%。唯一的解决办法就是回收旧的 selector，把之前注册的 channel 实例都注册到新的 selector 上。</p><p>这里主要是由于 Selector.select() 方法停止阻塞，然后立即返回了，即使没有 SelectionKeys 被选中。这和它的本质是有冲突的，因为当它的事件没有被选中时是不能变为非阻塞的。</p><p>解决 epoll 的方法被限制了，但 Netty 尝试自动检测和预防这种情况。</p><p>下面是会出现 epoll bug 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 立即返回</span></span><br><span class="line">    <span class="comment">// 并且当没有事件被选中时返回的是0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">selected</span> <span class="operator">=</span> selector.select();</span><br><span class="line">    Set&lt;SelectedKeys&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">    <span class="comment">// 获得所有 SelectedKeys</span></span><br><span class="line">    <span class="comment">// 没东西被选中时，迭代器会是空</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> readyKeys.iterator();</span><br><span class="line">    <span class="comment">// 空迭代器，则无法进入</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最主要的影响是那段 while 循环会吃 CPU：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>1.Netty and Java NIO APIs</p><p><a href="https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/">https://zoctan.github.io/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Zoctan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-10-18</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-03</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-634fc88092b0a58a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/pay_ali.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/pay_wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/10/19/zh/programing/book_read/java/netty_in_action/3_netty_from_the_ground_up/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">3.Netty from the ground up</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/10/11/zh/programing/book_read/java/netty_in_action/netty/"><span class="level-item">Netty&#039;s Hello World</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#异步的设计"><span class="level-left"><span class="level-item">1</span><span class="level-item">异步的设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Callbacks"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Callbacks</span></span></a></li><li><a class="level is-mobile" href="#Futures"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Futures</span></span></a></li></ul></li><li><a class="level is-mobile" href="#JVM-中-阻塞IO-vs-非阻塞IO"><span class="level-left"><span class="level-item">2</span><span class="level-item">JVM 中 阻塞IO vs 非阻塞IO</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基于阻塞-IO-的-echo-服务端"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">基于阻塞 IO 的 echo 服务端</span></span></a></li><li><a class="level is-mobile" href="#非阻塞-IO-基础"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">非阻塞 IO 基础</span></span></a></li><li><a class="level is-mobile" href="#基于-NIO-的-echo-的服务端"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">基于 NIO 的 echo 的服务端</span></span></a></li><li><a class="level is-mobile" href="#基于-NIO-2-的-echo-服务端"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">基于 NIO.2 的 echo 服务端</span></span></a></li></ul></li><li><a class="level is-mobile" href="#NIO-问题以及-Netty-是如何解决的"><span class="level-left"><span class="level-item">3</span><span class="level-item">NIO 问题以及 Netty 是如何解决的</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#跨平台和兼容性问题"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">跨平台和兼容性问题</span></span></a></li><li><a class="level is-mobile" href="#ByteBuffer-可扩展性"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">ByteBuffer 可扩展性</span></span></a></li><li><a class="level is-mobile" href="#分散和聚集可能内存泄漏"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">分散和聚集可能内存泄漏</span></span></a></li><li><a class="level is-mobile" href="#著名的-epoll-bug"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">著名的 epoll bug</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zoctan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script><script src="/js/post_date_tips.js"></script><script src="/js/add_runtime.js"></script><script src="/js/remove_powered_by.js"></script></body></html>