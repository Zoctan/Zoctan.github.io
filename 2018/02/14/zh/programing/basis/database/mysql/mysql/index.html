<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>数据库 - Zoctan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Zoctan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zoctan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Mysql数据库三范式第一范式（1NF） 无重复的列：数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。 举例1：一张学生表Student(stuNo,stuName,a"><meta property="og:type" content="blog"><meta property="og:title" content="数据库"><meta property="og:url" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/database/mysql/mysql/"><meta property="og:site_name" content="Zoctan&#039;s Blog"><meta property="og:description" content="Mysql数据库三范式第一范式（1NF） 无重复的列：数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。 举例1：一张学生表Student(stuNo,stuName,a"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zoctan.github.io/img/og_image.png"><meta property="article:published_time" content="2018-02-13T16:00:00.000Z"><meta property="article:modified_time" content="2022-11-01T09:33:34.650Z"><meta property="article:author" content="Zoctan"><meta property="article:tag" content="zoctan,blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zoctan.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zoctan.github.io/2018/02/14/zh/programing/basis/database/mysql/mysql/"},"headline":"数据库","image":["https://zoctan.github.io/img/og_image.png"],"datePublished":"2018-02-13T16:00:00.000Z","dateModified":"2022-11-01T09:33:34.650Z","author":{"@type":"Person","name":"Zoctan"},"publisher":{"@type":"Organization","name":"Zoctan's Blog","logo":{"@type":"ImageObject","url":"https://zoctan.github.io/img/logo.svg"}},"description":"Mysql数据库三范式第一范式（1NF） 无重复的列：数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。 举例1：一张学生表Student(stuNo,stuName,a"}</script><link rel="canonical" href="https://zoctan.github.io/2018/02/14/zh/programing/basis/database/mysql/mysql/"><link rel="alternate" href="https://zoctan.github.io/atom.xml" title="Zoctan&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><meta name="msvalidate.01" content="3A666EB8EB887659AE5D32D988405EF2"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RW91M7Y2GB" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RW91M7Y2GB")</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2018-02-13T16:00:00.000Z" title="2/14/2018, 12:00:00 AM">2018-02-14</time></span><span class="level-item">Updated&nbsp;<time datetime="2022-11-01T09:33:34.650Z" title="11/1/2022, 5:33:34 PM">2022-11-01</time></span><span class="level-item"><a class="link-muted" href="/categories/zh/">zh</a><span> / </span><a class="link-muted" href="/categories/zh/programing/">programing</a><span> / </span><a class="link-muted" href="/categories/zh/programing/basis/">basis</a><span> / </span><a class="link-muted" href="/categories/zh/programing/basis/database/">database</a></span><span class="level-item">31 minutes read (About 4603 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">数据库</h1><div class="content"><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p><strong>第一范式（1NF）</strong></p><p>无重复的列：数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p><p>举例1：一张学生表Student(stuNo,stuName,age,age,sex)是不符合第一范式的，因为有重复列age属性。去除重复列age以后的Student(stuNo,stuName,age,sex)是符合第一范式的。</p><p><strong>第二范式（2NF）</strong></p><p>属性完全依赖于主键【消除部分子函数依赖】：数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是属性完全依赖于主键。</p><p>这里说的主关键字可能不只有一个，有些情况下是存在联合主键的，就是主键有多个属性。</p><p><strong>第三范式（3NF）</strong></p><p>属性不依赖于其它非主属性【消除传递依赖】：一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p><span id="more"></span><h2 id="InnoDB-和-MyISAM-存储引擎的区别"><a href="#InnoDB-和-MyISAM-存储引擎的区别" class="headerlink" title="InnoDB 和 MyISAM 存储引擎的区别"></a>InnoDB 和 MyISAM 存储引擎的区别</h2><p>基本区别：</p><ol><li>MyISAM 类型不支持事务处理等高级处理，而 InnoDB 类型支持、外键、行级锁等高级数据库功能。</li><li>MyISAM 类型的表强调的是性能，其执行速度比 InnoDB 类型更快。</li></ol><p>具体区别：</p><ol><li>InnoDB 不支持 FULLTEXT 类型的索引。</li><li>InnoDB 中不保存表的具体行数，也就是说，执行 select count( * ) from table 时，InnoDB 要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意：当count( * ) 语句包含 where 条件时，两种表的操作是一样的。</li><li>对于 AUTO_INCREMENT 类型的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中，可以和其他字段一起建立联合索引。</li><li>DELETE FROM table 时，InnoDB 不会重新建立表，而是一行一行的删除。</li><li>LOAD TABLE FROM MASTER 操作对 InnoDB 是不起作用的，解决方法是首先把 InnoDB 表改成 MyISAM 表，导入数据后再改成 InnoDB 表，但是对于使用的额外的 InnoDB 特性(例如外键)的表不适用。</li><li>InnoDB 表的行锁也不是绝对的，假如在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围， InnoDB 表同样会锁全表，例如 update table set num&#x3D;1 where name like “%aaa%”</li></ol><h2 id="索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引"><a href="#索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引" class="headerlink" title="索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引"></a>索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引</h2><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>为表设置索引付出的代价：</p><ol><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><p>优点：</p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><p>一般来说，应该在这些列上创建索引：</p><ol><li>经常需要搜索的列上，可以加快搜索的速度。</li><li>作为主键的列，强制该列的唯一性和组织表中数据的排列结构。</li><li>经常用在连接的列，这些列主要是一些外键，加快连接的速度。</li><li>经常需要根据范围进行搜索的列，因为索引已经排序，其指定的范围是连续的。</li><li>经常需要排序的列，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询速度。</li><li>经常使用在WHERE子句中的列，加快条件的判断速度。</li></ol><p>一般来说，不应该创建索引的的这些列具有下列特点：</p><ol><li>查询中很少使用或者参考的列。</li><li>只有很少数据值的列。因为这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>当修改性能远远大于检索性能时。因为修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。</li></ol><p><strong>三种索引：唯一索引、主键索引和聚集索引</strong></p><p>唯一索引：唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p><p>主键索引：数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p><p>聚集索引：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><h2 id="B树、B-树区别，索引为何使用B-树"><a href="#B树、B-树区别，索引为何使用B-树" class="headerlink" title="B树、B+树区别，索引为何使用B+树"></a>B树、B+树区别，索引为何使用B+树</h2><p>根据B-Tree的定义，可知检索一次最多需要访问h个节点。利用磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。</p><p>为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p><p>B-Tree中一次检索最多需要h-1次I&#x2F;O（根节点常驻内存），渐进复杂度为O(h)&#x3D;O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I&#x2F;O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><h2 id="聚集索引与非聚集索引（使用非聚集索引的查询过程）"><a href="#聚集索引与非聚集索引（使用非聚集索引的查询过程）" class="headerlink" title="聚集索引与非聚集索引（使用非聚集索引的查询过程）"></a>聚集索引与非聚集索引（使用非聚集索引的查询过程）</h2><h2 id="事务的ACID（原子性、一致性、隔离性、持久性）"><a href="#事务的ACID（原子性、一致性、隔离性、持久性）" class="headerlink" title="事务的ACID（原子性、一致性、隔离性、持久性）"></a>事务的ACID（原子性、一致性、隔离性、持久性）</h2><p>原子性（Atomicity）：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>一致性（Correspondence）：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。（实体完整性、参照完整性、用户自定义完整性）</p><p>隔离性（Isolation）：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><p>持久性（Durability）：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><p>7.事务隔离级别和各自存在的问题（脏读、不可重复读、幻读）和解决方式（间隙锁及MVCC）</p><p>8.乐观锁和悲观锁、行锁与表锁、共享锁与排他锁（inndob如何手动加共享锁与排他锁）<br>如果现在只有一张火车票，怎么让所有人都看见但是只有一个人能购买成功 (这里就是悲观锁乐观锁的应用处理并发问题)</p><p>9.MVCC（增加两个版本号）及delete、update、select时的具体控制</p><p>10.死锁判定原理和具体场景</p><p>11.查询缓慢和解决方式（explain、慢查询日志、show profile等）</p><h2 id="drop、truncate、delete区别"><a href="#drop、truncate、delete区别" class="headerlink" title="drop、truncate、delete区别"></a>drop、truncate、delete区别</h2><p>基本区别：</p><ul><li>drop 直接删掉表；</li><li>truncate 删除表中数据，再插入时自增长 id 又从1开始；</li><li>delete 删除表中数据，可以加 where 字句。</li></ul><p>具体区别：</p><ol><li>delete 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。truncate 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li><li>表和索引所占空间。当表被 truncate 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</li><li>一般而言，drop &gt; truncate &gt; delete</li><li>应用范围。truncate 只能对 table，delete 可以是 table 和 view</li><li>truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。</li><li>truncate 与不带 where 的 delete：只删除数据，而不删除表的结构（定义）。</li><li>drop 将删除表的结构被依赖的约束（constrain)、触发器（trigger)、索引（index)，依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为 invalid。</li><li>delete 是 DML（data maintain Language)，这个操作会被放到 rollback segment中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发。</li><li>truncate、drop 是 DLL（data define language)，操作立即生效，原数据不放到 rollback segment中，不能回滚。</li><li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合 where 来约束影响范围。回滚段要足够大。要删除表用 drop；若想保留表而将表中数据删除，且与事务无关，用 truncate 即可实现；如果与事务有关，或想触发 trigger，还是用 delete。</li><li>truncate 速度快,而且效率高,因为 truncate 在功能上与不带 where 子句的 delete 语句相同：二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，并在事务日志中为所删除的每行记录一项。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</li><li>truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop 语句。</li><li>对于由 FOREIGN KEY 约束引用的表，不能使用 truncate，而应使用不带 where 子句的 delete 语句。由于 truncate 不记录在日志中，所以它不能激活触发器。</li></ol><h2 id="查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序"></a>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</h2><h2 id="集合查询有哪些"><a href="#集合查询有哪些" class="headerlink" title="集合查询有哪些"></a>集合查询有哪些</h2><p>union：并操作<br>intersect：交操作<br>except：差操作</p><p><strong>union</strong></p><p>查询计算机系的所有学生和年龄大于19岁的学生的并集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">19</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">OR</span> age <span class="operator">&gt;</span> <span class="number">19</span>;</span><br></pre></td></tr></table></figure><p><strong>intersect</strong></p><p>查询计算机系中年龄大于19岁的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">19</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">19</span>;</span><br></pre></td></tr></table></figure><p><strong>except</strong></p><p>查询计算机系中年龄大于19岁的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;=</span> <span class="number">19</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">19</span>;</span><br></pre></td></tr></table></figure><p>注意：MySQL 中没有求交集和差集的功能，只能用其他关键字达到类似功能。</p><p>求交集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.member_id, a.name <span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> b</span><br><span class="line"><span class="keyword">USING</span> (member_id, name);</span><br></pre></td></tr></table></figure><p>求差集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.<span class="operator">*</span> <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure><h2 id="UNION-和-UNION-ALL-的区别"><a href="#UNION-和-UNION-ALL-的区别" class="headerlink" title="UNION 和 UNION ALL 的区别"></a>UNION 和 UNION ALL 的区别</h2><p>UNION 将多个查询结果合并起来，系统自动去掉重复元组，在排序时会按照字段的顺序。<br>UNION ALL 则会保留重复的元组，在排序时只是简单的将两个结果合并后就返回。</p><h2 id="MYSQL-优化，读写分离、主从复制"><a href="#MYSQL-优化，读写分离、主从复制" class="headerlink" title="MYSQL 优化，读写分离、主从复制"></a>MYSQL 优化，读写分离、主从复制</h2><h2 id="数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"></a>数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）</h2><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h2 id="数据淘汰机制（好几种）"><a href="#数据淘汰机制（好几种）" class="headerlink" title="数据淘汰机制（好几种）"></a>数据淘汰机制（好几种）</h2><h2 id="字典及渐进式rehash"><a href="#字典及渐进式rehash" class="headerlink" title="字典及渐进式rehash"></a>字典及渐进式rehash</h2><h2 id="RDB与AOF"><a href="#RDB与AOF" class="headerlink" title="RDB与AOF"></a>RDB与AOF</h2><h2 id="为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）"><a href="#为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）" class="headerlink" title="为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）"></a>为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）</h2><h2 id="Redis的几种数据结构"><a href="#Redis的几种数据结构" class="headerlink" title="Redis的几种数据结构"></a>Redis的几种数据结构</h2></div><div class="article-licensing box"><div class="licensing-title"><p>数据库</p><p><a href="https://zoctan.github.io/2018/02/14/zh/programing/basis/database/mysql/mysql/">https://zoctan.github.io/2018/02/14/zh/programing/basis/database/mysql/mysql/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Zoctan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-02-14</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-01</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-634fc88092b0a58a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/pay_ali.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/pay_wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/02/14/zh/programing/basis/data_structure/data_structure/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">数据结构与算法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/28/zh/programing/basis/algorithm/blue_bridge_cup/summary_of_2015_2017_provincial_competition_topics/"><span class="level-item">蓝桥杯2015-2017省赛题目总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Mysql"><span class="level-left"><span class="level-item">1</span><span class="level-item">Mysql</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数据库三范式"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">数据库三范式</span></span></a></li><li><a class="level is-mobile" href="#InnoDB-和-MyISAM-存储引擎的区别"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">InnoDB 和 MyISAM 存储引擎的区别</span></span></a></li><li><a class="level is-mobile" href="#索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引</span></span></a></li><li><a class="level is-mobile" href="#B树、B-树区别，索引为何使用B-树"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">B树、B+树区别，索引为何使用B+树</span></span></a></li><li><a class="level is-mobile" href="#聚集索引与非聚集索引（使用非聚集索引的查询过程）"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">聚集索引与非聚集索引（使用非聚集索引的查询过程）</span></span></a></li><li><a class="level is-mobile" href="#事务的ACID（原子性、一致性、隔离性、持久性）"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">事务的ACID（原子性、一致性、隔离性、持久性）</span></span></a></li><li><a class="level is-mobile" href="#drop、truncate、delete区别"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">drop、truncate、delete区别</span></span></a></li><li><a class="level is-mobile" href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</span></span></a></li><li><a class="level is-mobile" href="#集合查询有哪些"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">集合查询有哪些</span></span></a></li><li><a class="level is-mobile" href="#UNION-和-UNION-ALL-的区别"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">UNION 和 UNION ALL 的区别</span></span></a></li><li><a class="level is-mobile" href="#MYSQL-优化，读写分离、主从复制"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">MYSQL 优化，读写分离、主从复制</span></span></a></li><li><a class="level is-mobile" href="#数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><span class="level-left"><span class="level-item">1.12</span><span class="level-item">数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Redis"><span class="level-left"><span class="level-item">2</span><span class="level-item">Redis</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#发布订阅"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">发布订阅</span></span></a></li><li><a class="level is-mobile" href="#数据淘汰机制（好几种）"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">数据淘汰机制（好几种）</span></span></a></li><li><a class="level is-mobile" href="#字典及渐进式rehash"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">字典及渐进式rehash</span></span></a></li><li><a class="level is-mobile" href="#RDB与AOF"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">RDB与AOF</span></span></a></li><li><a class="level is-mobile" href="#为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）</span></span></a></li><li><a class="level is-mobile" href="#Redis的几种数据结构"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">Redis的几种数据结构</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zoctan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script><script src="/js/post_date_tips.js"></script><script src="/js/add_runtime.js"></script><script src="/js/remove_powered_by.js"></script></body></html>