<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>计算机网络 - Zoctan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Zoctan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zoctan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="网络的网络 网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。"><meta property="og:type" content="blog"><meta property="og:title" content="计算机网络"><meta property="og:url" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/"><meta property="og:site_name" content="Zoctan&#039;s Blog"><meta property="og:description" content="网络的网络 网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/network.png"><meta property="og:image" content="https://zoctan.github.io/isp.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/composition_of_the_internet.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/three_exchanges.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/packet_message.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/delay.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/computer_network_architecture.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/process_of_transferring_data_between_layers.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/effect_of_propagation_delay_on_carrier_sense.png"><meta property="og:image" content="https://zoctan.github.io/mac.png"><meta property="og:image" content="https://zoctan.github.io/tcp_ip_architecture_1.png"><meta property="og:image" content="https://zoctan.github.io/tcp_ip_architecture_2.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/sliding_window.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/tcp_congestion_control_1.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/tcp_congestion_control_2.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/fast_retransmission.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/domain_tree.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/divide_multiple_zones.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/two_authoritative_name_servers.png"><meta property="og:image" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/parsing_process.png"><meta property="article:published_time" content="2018-02-13T16:00:00.000Z"><meta property="article:modified_time" content="2022-11-17T16:04:38.298Z"><meta property="article:author" content="Zoctan"><meta property="article:tag" content="zoctan,blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/network.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/"},"headline":"计算机网络","image":["https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/network.png","https://zoctan.github.io/isp.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/composition_of_the_internet.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/three_exchanges.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/packet_message.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/delay.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/computer_network_architecture.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/process_of_transferring_data_between_layers.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/effect_of_propagation_delay_on_carrier_sense.png","https://zoctan.github.io/mac.png","https://zoctan.github.io/tcp_ip_architecture_1.png","https://zoctan.github.io/tcp_ip_architecture_2.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/sliding_window.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/tcp_congestion_control_1.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/tcp_congestion_control_2.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/fast_retransmission.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/domain_tree.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/divide_multiple_zones.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/two_authoritative_name_servers.png","https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/parsing_process.png"],"datePublished":"2018-02-13T16:00:00.000Z","dateModified":"2022-11-17T16:04:38.298Z","author":{"@type":"Person","name":"Zoctan"},"publisher":{"@type":"Organization","name":"Zoctan's Blog","logo":{"@type":"ImageObject","url":"https://zoctan.github.io/img/logo.svg"}},"description":"网络的网络 网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。"}</script><link rel="canonical" href="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/"><link rel="alternate" href="https://zoctan.github.io/atom.xml" title="Zoctan&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><meta name="msvalidate.01" content="3A666EB8EB887659AE5D32D988405EF2"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RW91M7Y2GB" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RW91M7Y2GB")</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2018-02-13T16:00:00.000Z" title="2/14/2018, 12:00:00 AM">2018-02-14</time></span><span class="level-item">Updated&nbsp;<time datetime="2022-11-17T16:04:38.298Z" title="11/18/2022, 12:04:38 AM">2022-11-18</time></span><span class="level-item"><a class="link-muted" href="/categories/zh/">zh</a><span> / </span><a class="link-muted" href="/categories/zh/programing/">programing</a><span> / </span><a class="link-muted" href="/categories/zh/programing/basis/">basis</a></span><span class="level-item">an hour read (About 7614 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">计算机网络</h1><div class="content"><h1 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h1><p><img src="/2018/02/14/zh/programing/basis/computer_network/network.png" alt="网络的网络" loading="lazy"></p><p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p><span id="more"></span><h1 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h1><p>互联网服务提供商（Internet Service Provider）拥有通信线路以及路由器等联网设备，可以从互联网管理机构获得许多 IP 地址。个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><p><img src="/isp.png" alt="ISP" loading="lazy"></p><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。</p><p>互联网交换点（Internet eXchange Point）允许两个 ISP 直接相连而不用经过第三个 ISP。</p><h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><ol><li>边缘部分：所有连接在互联网上的主机，用户可以直接使用；</li><li>核心部分：由大量的网络和连接这些网络的路由器组成，为边缘部分的主机提供服务。</li></ol><p><img src="/2018/02/14/zh/programing/basis/computer_network/composition_of_the_internet.png" alt="互联网的组成" loading="lazy"></p><h1 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h1><p>客户-服务器（C&#x2F;S）：客户是服务的请求方，服务器是服务的提供方。</p><p>浏览器-服务器（B&#x2F;S）：浏览器是服务的请求方，服务器是服务的提供方。</p><p>对等（P2P）：不区分客户和服务器。</p><h1 id="电路交换、报文交换、分组交换"><a href="#电路交换、报文交换、分组交换" class="headerlink" title="电路交换、报文交换、分组交换"></a>电路交换、报文交换、分组交换</h1><p><img src="/2018/02/14/zh/programing/basis/computer_network/three_exchanges.png" alt="电路交换、报文交换、分组交换" loading="lazy"></p><p><strong>电路交换</strong></p><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><p><strong>报文交换</strong></p><p>报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。</p><p><strong>分组交换</strong></p><p>分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/packet_message.png" alt="分组报文" loading="lazy"></p><p>存储转发允许在一条传输线路上传送多个主机的分组，也就是说两个用户之间的通信不需要占用端到端的线路资源。相比于报文交换，分组比报文更小，因此分组交换的存储转发速度更快。</p><h1 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h1><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/delay.png" alt="时延" loading="lazy"></p><ol><li>发送时延：主机或路由器发送数据帧所需要的时间。</li><li>传播时延：电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。</li><li>处理时延：主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据部、进行差错检验或查找适当的路由等。</li><li>排队时延：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li></ol><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><img src="/2018/02/14/zh/programing/basis/computer_network/computer_network_architecture.png" alt="计算机网络体系结构" loading="lazy"></p><p><strong>各层对应的网络设备</strong></p><p>中继器、集线器 &gt; 物理层<br>网桥、交换机 &gt; 数据链路层<br>路由器 &gt; 网络层<br>网关（不是设备） &gt; 网络层（常见）</p><p><strong>数据在各层之间的传递过程</strong></p><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/process_of_transferring_data_between_layers.png" alt="数据在各层之间的传递过程" loading="lazy"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>CSMA&#x2F;CD 协议</strong></p><p>CSMA&#x2F;CD 全称：载波监听多点接入&#x2F;碰撞检测</p><ul><li>多点接入：说明这是总线型网络，许多计算机以多点的方式连接到总线上。</li><li>载波监听：每个站都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li>碰撞检测：在发送中，如果监听到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p><img src="/2018/02/14/zh/programing/basis/computer_network/effect_of_propagation_delay_on_carrier_sense.png" alt="传播时延对载波监听的影响" loading="lazy"></p><p>整体过程：</p><ol><li>准备发送，并在发前，检测信道。</li><li>检测信道：若忙：则不停检测；若空闲，并在96比特时间（帧间最小间隔）内保持空闲的话，就发送。</li><li>发送过程中不停检测，即网络适配器要边发边监听：<br>a.争用期内一直未检测到碰撞，则发送成功，回到阶段1。<br>b.失败：检测到碰撞，停止发送，并发送人为干扰信号，再采取指数退避算法，等待r倍512比特时间后，返回阶段2。如果重传达到16次仍不成功，则停止重传，向上报错。</li></ol><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC 地址是 6 字节（48 位）的地址，用于唯一标识网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。</p><p><img src="/mac.png" alt="MAC" loading="lazy"></p><p>MAC 帧：<br>类型：标记上层使用的协议；<br>数据：长度在 46-1500 之间，如果太小则需要填充；<br>FCS：帧检验序列，使用的是 CRC 检验方法；<br>前同步码：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。</p><h1 id="TCP-x2F-IP-体系结构"><a href="#TCP-x2F-IP-体系结构" class="headerlink" title="TCP&#x2F;IP 体系结构"></a>TCP&#x2F;IP 体系结构</h1><p><img src="/tcp_ip_architecture_1.png" alt="TCP/IP 体系结构" loading="lazy"></p><p>TCP&#x2F;IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><img src="/tcp_ip_architecture_2.png" alt="TCP/IP 体系结构" loading="lazy"></p><p>IP 地址分类，子网划分：</p><table><thead><tr><th align="center">类</th><th align="center">起始</th><th align="center">网络号</th><th align="center">主机号</th><th align="center">最大可指派网络数</th><th align="center">第一个网络号</th><th align="center">最后一个网络号</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">8位</td><td align="center">24位</td><td align="center">2^7-2</td><td align="center">1</td><td align="center">126</td></tr><tr><td align="center">B</td><td align="center">10</td><td align="center">16位</td><td align="center">16位</td><td align="center">2^14-2</td><td align="center">128.1</td><td align="center">191.255</td></tr><tr><td align="center">C</td><td align="center">110</td><td align="center">24位</td><td align="center">8位</td><td align="center">2^21-2</td><td align="center">192.0.1</td><td align="center">223.255.255</td></tr><tr><td align="center">D</td><td align="center">1110</td><td align="center">多播</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="TCP-x2F-UDP-区别"><a href="#TCP-x2F-UDP-区别" class="headerlink" title="TCP&#x2F;UDP 区别"></a>TCP&#x2F;UDP 区别</h2><p>基本区别：</p><ol><li>基于连接与无连接</li><li>TCP 要求系统资源较多，UDP 较少</li><li>UDP 程序结构较简单</li><li>流模式（TCP）与数据报模式(UDP)</li><li>TCP 保证数据正确性，UDP 可能丢包</li><li>TCP 保证数据顺序，UDP 不保证</li><li>TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道</li></ol><p>UDP 应用场景：</p><ol><li>面向数据报方式</li><li>网络数据大多为短消息</li><li>拥有大量 Client</li><li>对数据安全性无特殊要求</li><li>网络负担非常重，但对响应速度要求高</li></ol><h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h2><p>三次握手：互相确认对方都可以收也可以发。<br>四次挥手：互相确认对方都收到自己要关闭的信息，并且对方已经没有要传输的信息了。</p><p>三次握手例子：<br>第一次握手：A 打电话给 B：你可以听到我说话吗？<br>第二次握手：B 收到 A 的信息，回复：我可以听到你说话，你听得到我说话吗？<br>第三次握手：A 收到 B 的信息，回复：可以听到你说话，我要给你发信息啦！</p><p>三次握手之后，A 和 B 都能确定：我说的话，你能听到；你说的话，我也能听到。这样，就可以开始正常通信了。</p><p>如果是两次：无法确认发起方可以收到。<br>如果是四次：在三次已经可以确认时，增加次数可以提高通信的可靠性，不过会浪费资源而已。</p><p>四次挥手例子：<br>第一次挥手：A：喂，我不说了 (FIN)。<br>第二次挥手：B：我知道了(ACK)。等下，上一句还没说完。Balabala…..（传输剩余数据）<br>第三次挥手：B：好了，说完了，我也不说了（FIN）。<br>第四次挥手：A：我知道了（ACK）。<br>A 等待2MSL，保证 B 收到了消息，否则重说一次“我知道了（ACK）”。</p><p>四次挥手之后，把该说的话都说完，并且 A 和 B 都知道自己没话说了，对方也没花说了，然后就挂掉电话（断开链接）了。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><img src="/2018/02/14/zh/programing/basis/computer_network/sliding_window.png" alt="滑动窗口" loading="lazy"></p><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算：RTTs &#x3D; (1 - a) x RTTs + a x RTT</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算：RTO &#x3D; RTTs + 4 x RTTd，其中 RTTd 为偏差。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/tcp_congestion_control_1.png" alt="拥塞控制" loading="lazy"></p><p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="/2018/02/14/zh/programing/basis/computer_network/tcp_congestion_control_2.png" alt="拥塞控制" loading="lazy"></p><p><strong>慢开始与拥塞避免</strong></p><p>发送的最初执行慢开始，令 cwnd&#x3D;1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh &#x3D; cwnd&#x2F;2，然后重新执行慢开始。</p><p><strong>快重传与快恢复</strong></p><p>在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh &#x3D; cwnd&#x2F;2 ，cwnd &#x3D; ssthresh，注意到此时直接进入拥塞避免。</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/fast_retransmission.png" alt="快重传" loading="lazy"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>把主机名解析为 IP 地址，被设计成分布式系统。</p><p><strong>层次结构</strong></p><p>一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/domain_tree.png" alt="域名树" loading="lazy"></p><p>域名服务器可以分为以下四类：</p><ul><li>根域名服务器：解析顶级域名；</li><li>顶级域名服务器：解析二级域名；</li><li>权限域名服务器：解析区内的域名；</li><li>本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。</li></ul><p>区和域的概念不同，可以在一个域中划分多个区。在域 abc.com 中划分了两个区：abc.com 和 y.abc.com：</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/divide_multiple_zones.png" alt="划分多个区" loading="lazy"></p><p>因此就需要两个权限域名服务器：</p><p><img src="/2018/02/14/zh/programing/basis/computer_network/two_authoritative_name_servers.png" alt="两个权限域名服务器" loading="lazy"></p><p><strong>解析过程</strong></p><p><img src="/2018/02/14/zh/programing/basis/computer_network/parsing_process.png" alt="解析过程" loading="lazy"></p><p>主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。</p><p>迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归的方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。</p><h1 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h1><p>这个过程可以大致分为两个部分：网络通信和页面渲染。</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p><strong>解析 URL</strong></p><p>a.浏览器判断地址是否是通过域名访问的。<br>DNS 解析：从浏览器的缓存中去找网址对应的 IP 地址 -&gt;<br>从 OS 系统的 DNS 缓存中找 -&gt;<br>从路由器的 DNS 缓存中找 -&gt;<br>从 ISP 的 DNS 缓存中找。如果都没有找到：向 ISP 或公共的域名解析服务发起 DNS 查找请求（递归查询）。</p><p>比如：baidu.com 查找过程: 根域名服务器 -&gt; .com 域名服务器 -&gt; baidu.com 域名服务器。</p><p>b.若地址不含端口号，则根据协议补充默认端口号。如 HTTP 协议是 80 端口，HTTPS 是 443 端口。</p><p><strong>建立 TCP 连接</strong></p><p>TCP 协议通过三次握手建立连接。<br>1️：客户端通过 SYN 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 SYN_SEND；<br>2️：服务器如果有开着的端口并且决定接受连接，就会返回一个 SYN+ACK 报文段给客户端，状态设置为 SYN_RECV；<br>3️：客户端收到服务器的 SYN+ACK 报文段，向服务器发送 ACK 报文段表示确认。此时客户端和服务器都设置为 ESTABLISHED 状态。<br>连接建立，可以开始数据传输了。</p><p><strong>应用层客户端发送 HTTP 请求</strong></p><p>HTTP 请求包括请求头和请求主体两个部分。<br>请求头包含了重要的信息：请求的方法（GET&#x2F;POST）、目标URL、遵循的协议（HTTP&#x2F;HTTPS&#x2F;FTP…）、返回的信息是否需要缓存、客户端是否发送Cookie 等。</p><p><strong>服务器接收数据</strong></p><p>服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在传输层通过 TCP 协议将分段的数据包重新组成原来的 HTTP 请求报文。</p><p><strong>服务器响应请求</strong></p><p>Web 服务程序接收到客户端发送的 HTTP 请求后，解析请求，查找客户端请求的资源，并返回响应数据。</p><p>响应 &#x3D; 响应行 + 响应头 + 响应主体。</p><p>响应行：HTTP&#x2F;版本号 状态码 状态信息（比如： HTTP&#x2F;1.1 200 OK）<br>响应头：服务器设置的一些信息，比如 Cookie 等。<br>响应主体：要返回的资源，比如 HTML 文件。</p><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>浏览器渲染页面的过程：解析 HTML -&gt; 构建 DOM 树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。</p><p>DOM 树：由 HTML 文件中的标签排列组成。<br>渲染树：由 DOM 树中加入 CSS 或 HTML 中的 style 样式形成，只包含需要显示在页面中的 DOM 元素，如</p><head>元素、display 属性值为 none 的元素都不在树中。<p></p><p>浏览器还没接收到完整的 HTML 文件时，就开始渲染页面，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。</p><p>在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</p><h1 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h1><p>GET：请求获取指定的资源，报文主体没有任何语义。</p><ul><li>安全</li><li>幂等（任意多次请求所产生的响应均与一次执行的响应相同）</li><li>可缓存的（除非有 Cache-ControlHeader 约束）</li></ul><p>POST：根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。</p><ul><li>不安全</li><li>不幂等</li><li>（大部分实现）不可缓存</li></ul><p>这里指的“安全”在不同情况下是有不同解释的：</p><ul><li>网络安全：两者都是一样的，HTTP 下两者都是明文，HTTPS 下两者都是密文。</li><li>RFC2616 9.1.1：GET 被称为安全方法，而 POST 却不是，因为 GET 和 HEAD 方法应该只用于检索数据，而不是添加、更新和删除。</li></ul><h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><table><thead><tr><th align="center">状态码</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="center">2xx</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3xx</td><td align="center">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4xx</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5xx</td><td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h1 id="HTTP-x2F-1-0-和-HTTP-x2F-1-1-区别"><a href="#HTTP-x2F-1-0-和-HTTP-x2F-1-1-区别" class="headerlink" title="HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 区别"></a>HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 区别</h1><p><strong>HTTP&#x2F;1.1 支持长连接（PersistentConnection）</strong></p><p>HTTP&#x2F;1.0 会话方式：</p><ol><li>建立连接</li><li>发出请求信息</li><li>回送响应信息</li><li>关掉连接</li></ol><p>HTTP&#x2F;1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p><p>HTTP&#x2F;1.1 支持持久连接, 并且默认使用该方式，但也需要增加新的请求头来帮助实现。例如，请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；请求头的值为 close 时，客户端通知服务器返回本次请求结果后关闭连接。</p><p><strong>HTTP&#x2F;1.1 请求的流水线（Pipelining）处理</strong></p><p>请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><p>例如，一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。<br>HTTP&#x2F;1.1 允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。</p><p><strong>HTTP&#x2F;1.1 Host 字段</strong></p><p>HTTP&#x2F;1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的 URL 并没有传递主机名（Hostname）。</p><p>但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p><p>HTTP&#x2F;1.1 的请求消息和响应消息都应支持Host头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。</p><p><strong>HTTP&#x2F;1.1 状态码 100（Continue）</strong></p><p>客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就返回响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。</p><p>优点：允许客户端在发送完整请求前先用请求头试探服务器，确认服务器是否接收，再决定要不要继续发。（节约带宽）</p><p><strong>HTTP&#x2F;1.1 Chunked transfer-coding</strong></p><p>发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。</p><p><strong>HTTP&#x2F;1.1 Cache 的新特性</strong></p><p>当缓存对象的 Age 超过 Expire 时变为 stale 对象，Cache 不需要直接抛弃 stale 对象，而是与源服务器进行重新激活（revalidation）。</p><h1 id="HTTP-缓存机制"><a href="#HTTP-缓存机制" class="headerlink" title="HTTP 缓存机制"></a>HTTP 缓存机制</h1><p>Pragma：用来包含实现特定的指令，最常用的是Pragma:no-cache。（HTTP&#x2F;1.1 协议中，含义和 Cache-Control:no-cache相同）<br>Expires：文件在本地缓存的过期时间，如果浏览器发现缓存中的文件没有过期，则不发送请求（有例外，后面介绍）。<br>Cache-Control：指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control 并不会修改另一个消息处理过程中的缓存处理过程。</p><p>请求中的缓存指令：no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached。<br>响应中的指令：public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。</p><p>public：响应可被任何缓存区缓存。<br>private：对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请 求无效。<br>no-cache：请求或响应消息不能缓存。<br>no-store：防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age：客户端可以接收生存期 &gt;&#x3D; 指定时间（以秒为单位）的响应。<br>min-fresh：客户端可以接收响应时间 &lt; 当前时间加上指定时间的响应。<br>max-stale：客户端可以接收 &gt; 超时期间的响应消息。</p><h1 id="Session-和-Cookie-区别"><a href="#Session-和-Cookie-区别" class="headerlink" title="Session 和 Cookie 区别"></a>Session 和 Cookie 区别</h1><ol><li>Cookie 放在客户端，Session 放在服务器。</li><li>Cookie 不安全。黑客可以分析存放在本地 Cookie 并进行 Cookie 欺骗。</li><li>Session 会在一定时间内保存在服务器上。当访问增多，会占用你服务器的性能。</li><li>单个 Cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个 Cookie。</li></ol><p>实现 Session 有两种方式：</p><ol><li>Cookie 实现。如果浏览器支持 Cookie，创建 Session 的时候把 SessionID 放在 Cookie 里。</li><li>重写 URL。如果浏览器不支持 Cookie，服务端可以通过重写 URL 的方式实现 Session，即 URL 后面加上 SessionID。</li></ol><h1 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h1><p>操作系统首先检查本地的 hosts 文件是否有这个网址映射关系：<br>-&gt; yes.就先调用这个 IP 地址映射，完成域名解析。<br>-&gt; no.查找本地 DNS 解析器缓存，是否有这个网址映射关系：<br>——&gt; yes.直接返回，完成域名解析。<br>——&gt; no.首先找TCP&#x2F;IP 参数中设置的首选 DNS 服务器，暂且叫它本地 DNS 服务器：<br>———–&gt; 1.查询的域名，在服务器的本地配置区域资源中，返回解析结果给客户端，完成域名解析。<br>———–&gt; 2.不由本地 DNS 服务器区域解析：<br>—————&gt; a.但服务器缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析。<br>—————&gt; b.本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询：<br>——————-&gt; a) 未用转发模式：本地 DNS 就把请求发至根 DNS，根 DNS 服务器收到请求后会判断这个域名由谁授权管理，并返回一个负责该顶级域名服务器的一个 IP。<br>———————&gt; 1.本地 DNS 服务器收到 IP 信息后，将会联系负责该域名的这台顶级域名服务器。<br>———————&gt; 2.顶级域名服务器收到请求后，如果自己无法解析，就会找一个管理该域名的下一级 DNS 服务器地址给本地 DNS 服务器。<br>———————&gt; 3.本地 DNS 服务器收到这个地址后，就会找这个下一级 DNS 服务器服务器，重复上面的动作进行查询，直至找到域名主机。<br>——————-&gt; b) 转发模式：本地 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，如此循环。<br>——————-&gt; 不管是本地 DNS 服务器用的是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，再由本地 DNS 服务器返回给客户端。</p><p>从客户端到本地 DNS 服务器是递归查询，而 DNS 服务器之间的交互查询是迭代查询。</p><h1 id="常用协议端口"><a href="#常用协议端口" class="headerlink" title="常用协议端口"></a>常用协议端口</h1><table><thead><tr><th align="center">端口</th><th align="center">协议</th></tr></thead><tbody><tr><td align="center">20&#x2F;TCP</td><td align="center">FTP 文件数据传输</td></tr><tr><td align="center">21&#x2F;TCP</td><td align="center">FTP 控制信令的传输</td></tr><tr><td align="center">23&#x2F;TCP</td><td align="center">TELNET 终端仿真</td></tr><tr><td align="center">25&#x2F;TCP</td><td align="center">SMTP 简单邮件传输</td></tr><tr><td align="center">53&#x2F;UDP</td><td align="center">DNS 域名解析</td></tr><tr><td align="center">67&#x2F;TCP</td><td align="center">DHCP 服务端</td></tr><tr><td align="center">68&#x2F;TCP</td><td align="center">DHCP 客户端</td></tr><tr><td align="center">69&#x2F;UDP</td><td align="center">TFTP 简单文件传输</td></tr><tr><td align="center">80&#x2F;TCP</td><td align="center">HTTP 超文本传输</td></tr><tr><td align="center">110&#x2F;TCP</td><td align="center">POP3 邮局协议版本3</td></tr><tr><td align="center">443&#x2F;TCP</td><td align="center">HTTPS 加密的超文本传输</td></tr><tr><td align="center">1521&#x2F;TCP</td><td align="center">Oracle 数据库</td></tr><tr><td align="center">1863&#x2F;TCP</td><td align="center">MSN Messenger 文件传输</td></tr><tr><td align="center">3389&#x2F;TCP</td><td align="center">Microsoft RDP 微软远程桌面</td></tr><tr><td align="center">5631&#x2F;TCP</td><td align="center">Symantec pcAnywhere 远程控制数据传输</td></tr><tr><td align="center">5632&#x2F;UDP</td><td align="center">Symantec pcAnywhere 主控端扫描被控端</td></tr><tr><td align="center">5000&#x2F;TCP</td><td align="center">MS SQL Server</td></tr></tbody></table></head></div><div class="article-licensing box"><div class="licensing-title"><p>计算机网络</p><p><a href="https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/">https://zoctan.github.io/2018/02/14/zh/programing/basis/computer_network/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Zoctan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-02-14</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-18</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-634fc88092b0a58a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/pay_ali.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/pay_wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/02/21/zh/programing/basis/algorithm/5_basic_algorithms/greedy_algorithm/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">贪心法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/02/14/zh/programing/basis/operating_system/"><span class="level-item">操作系统</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#网络的网络"><span class="level-left"><span class="level-item">1</span><span class="level-item">网络的网络</span></span></a></li><li><a class="level is-mobile" href="#ISP"><span class="level-left"><span class="level-item">2</span><span class="level-item">ISP</span></span></a></li><li><a class="level is-mobile" href="#互联网的组成"><span class="level-left"><span class="level-item">3</span><span class="level-item">互联网的组成</span></span></a></li><li><a class="level is-mobile" href="#主机之间的通信方式"><span class="level-left"><span class="level-item">4</span><span class="level-item">主机之间的通信方式</span></span></a></li><li><a class="level is-mobile" href="#电路交换、报文交换、分组交换"><span class="level-left"><span class="level-item">5</span><span class="level-item">电路交换、报文交换、分组交换</span></span></a></li><li><a class="level is-mobile" href="#时延"><span class="level-left"><span class="level-item">6</span><span class="level-item">时延</span></span></a></li><li><a class="level is-mobile" href="#计算机网络体系结构"><span class="level-left"><span class="level-item">7</span><span class="level-item">计算机网络体系结构</span></span></a></li><li><a class="level is-mobile" href="#数据链路层"><span class="level-left"><span class="level-item">8</span><span class="level-item">数据链路层</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MAC"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">MAC</span></span></a></li></ul></li><li><a class="level is-mobile" href="#TCP-x2F-IP-体系结构"><span class="level-left"><span class="level-item">9</span><span class="level-item">TCP/IP 体系结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#TCP-x2F-UDP-区别"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">TCP/UDP 区别</span></span></a></li><li><a class="level is-mobile" href="#三次握手和四次挥手"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">三次握手和四次挥手</span></span></a></li><li><a class="level is-mobile" href="#滑动窗口"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">滑动窗口</span></span></a></li><li><a class="level is-mobile" href="#可靠传输"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">可靠传输</span></span></a></li><li><a class="level is-mobile" href="#流量控制"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">流量控制</span></span></a></li><li><a class="level is-mobile" href="#拥塞控制"><span class="level-left"><span class="level-item">9.6</span><span class="level-item">拥塞控制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#应用层"><span class="level-left"><span class="level-item">10</span><span class="level-item">应用层</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#域名系统-DNS"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">域名系统 DNS</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Web-页面请求过程"><span class="level-left"><span class="level-item">11</span><span class="level-item">Web 页面请求过程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#网络通信"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">网络通信</span></span></a></li><li><a class="level is-mobile" href="#页面渲染"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">页面渲染</span></span></a></li></ul></li><li><a class="level is-mobile" href="#GET-和-POST-区别"><span class="level-left"><span class="level-item">12</span><span class="level-item">GET 和 POST 区别</span></span></a></li><li><a class="level is-mobile" href="#HTTP-状态码"><span class="level-left"><span class="level-item">13</span><span class="level-item">HTTP 状态码</span></span></a></li><li><a class="level is-mobile" href="#HTTP-x2F-1-0-和-HTTP-x2F-1-1-区别"><span class="level-left"><span class="level-item">14</span><span class="level-item">HTTP/1.0 和 HTTP/1.1 区别</span></span></a></li><li><a class="level is-mobile" href="#HTTP-缓存机制"><span class="level-left"><span class="level-item">15</span><span class="level-item">HTTP 缓存机制</span></span></a></li><li><a class="level is-mobile" href="#Session-和-Cookie-区别"><span class="level-left"><span class="level-item">16</span><span class="level-item">Session 和 Cookie 区别</span></span></a></li><li><a class="level is-mobile" href="#DNS-解析过程"><span class="level-left"><span class="level-item">17</span><span class="level-item">DNS 解析过程</span></span></a></li><li><a class="level is-mobile" href="#常用协议端口"><span class="level-left"><span class="level-item">18</span><span class="level-item">常用协议端口</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zoctan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script><script src="/js/post_date_tips.js"></script><script src="/js/add_runtime.js"></script><script src="/js/remove_powered_by.js"></script></body></html>