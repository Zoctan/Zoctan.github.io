<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>MySQL 大表优化方案 - Zoctan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Zoctan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zoctan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言当 MySQL 单表记录数过大时，增删改查性能都会急剧下降，可以参考以下优化手段：  单表优化 读写分离 缓存 拆分 NoSQL"><meta property="og:type" content="blog"><meta property="og:title" content="MySQL 大表优化方案"><meta property="og:url" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/"><meta property="og:site_name" content="Zoctan&#039;s Blog"><meta property="og:description" content="前言当 MySQL 单表记录数过大时，增删改查性能都会急剧下降，可以参考以下优化手段：  单表优化 读写分离 缓存 拆分 NoSQL"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/table_partitions.png"><meta property="og:image" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/original_user_table.png"><meta property="og:image" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/vertically_split_user_table.png"><meta property="og:image" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/horizontally_split_user_table.png"><meta property="og:image" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/client_architecture.png"><meta property="og:image" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/agency_architecture.png"><meta property="article:published_time" content="2018-07-21T16:00:00.000Z"><meta property="article:modified_time" content="2022-10-28T17:04:13.709Z"><meta property="article:author" content="Zoctan"><meta property="article:tag" content="zoctan,blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/table_partitions.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/"},"headline":"MySQL 大表优化方案","image":["https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/table_partitions.png","https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/original_user_table.png","https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/vertically_split_user_table.png","https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/horizontally_split_user_table.png","https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/client_architecture.png","https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/agency_architecture.png"],"datePublished":"2018-07-21T16:00:00.000Z","dateModified":"2022-10-28T17:04:13.709Z","author":{"@type":"Person","name":"Zoctan"},"publisher":{"@type":"Organization","name":"Zoctan's Blog","logo":{"@type":"ImageObject","url":"https://zoctan.github.io/img/logo.svg"}},"description":"前言当 MySQL 单表记录数过大时，增删改查性能都会急剧下降，可以参考以下优化手段：  单表优化 读写分离 缓存 拆分 NoSQL"}</script><link rel="canonical" href="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/"><link rel="alternate" href="https://zoctan.github.io/atom.xml" title="Zoctan&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><meta name="msvalidate.01" content="3A666EB8EB887659AE5D32D988405EF2"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RW91M7Y2GB" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RW91M7Y2GB")</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2018-07-21T16:00:00.000Z" title="7/22/2018, 12:00:00 AM">2018-07-22</time></span><span class="level-item">Updated&nbsp;<time datetime="2022-10-28T17:04:13.709Z" title="10/29/2022, 1:04:13 AM">2022-10-29</time></span><span class="level-item"><a class="link-muted" href="/categories/zh/">zh</a><span> / </span><a class="link-muted" href="/categories/zh/programing/">programing</a><span> / </span><a class="link-muted" href="/categories/zh/programing/basis/">basis</a><span> / </span><a class="link-muted" href="/categories/zh/programing/basis/database/">database</a></span><span class="level-item">39 minutes read (About 5778 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">MySQL 大表优化方案</h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当 MySQL 单表记录数过大时，增删改查性能都会急剧下降，可以参考以下优化手段：</p><ul><li>单表优化</li><li>读写分离</li><li>缓存</li><li>拆分</li><li>NoSQL</li></ul><span id="more"></span><h1 id="单表优化"><a href="#单表优化" class="headerlink" title="单表优化"></a>单表优化</h1><p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。</p><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><ul><li><p>尽量使用 <code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUM_INT</code> 作为整数类型而非 INT，如果非负则加上 <code>UNSIGNED</code>。</p></li><li><p>VARCHAR 的长度只分配真正需要的空间。</p></li><li><p>使用枚举或整数代替字符串类型。</p></li><li><p>尽量使用 <code>TIMESTAMP</code> 而非 DATETIME。</p></li><li><p>单表不要有太多字段，建议在20以内。</p></li><li><p>避免使用 NULL 字段，很难查询优化且占用额外索引空间。</p></li><li><p>用整型来存 IP。（<code>INET_ATON(EXPR)</code>、<code>INET_NTOA（EXPR）</code>函数）</p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>索引并不是越多越好，要根据查询有针对性的创建，考虑在 <code>WHERE</code> 和 <code>ORDER BY</code> 命令上涉及的列建立索引，可根据 <code>EXPLAIN</code> 来查看是否用了索引还是全表扫描。</p></li><li><p>应尽量避免在 <code>WHERE</code> 子句中对字段进行 <code>NULL</code> 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</p></li><li><p>值分布很稀少的字段不适合建索引，例如”性别”这种只有两三个值的字段。</p></li><li><p>字符字段只建前缀索引。</p></li><li><p>字符字段最好不要做主键。</p></li><li><p>不用外键，由程序保证约束。</p></li><li><p>尽量不用 <code>UNIQUE</code>，由程序保证约束。</p></li><li><p>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引。</p></li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li><p>可通过开启慢查询日志来找出较慢的 SQL。</p></li><li><p>不做列运算：<code>SELECT id WHERE age + 1 = 10</code>，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p></li><li><p>SQL 语句尽可能简单：一条 SQL 只能在一个 CPU 运算；大语句拆小语句，减少锁时间；一条大 SQL 可能堵死整个库。</p></li><li><p>不用 <code>SELECT *</code>。</p></li><li><p><code>OR</code> 改成 <code>IN</code>（OR 的效率是 n 级别，IN 的效率是 log(n) 级别， IN 的个数建议控制在200以内）。</p></li><li><p>不用函数和触发器，在应用程序实现。</p></li><li><p>避免 <code>%xxx</code> 查询。</p></li><li><p>少用 <code>JOIN</code>。</p></li><li><p>使用同类型进行比较，比如用 ‘123’ 和 ‘123’ 比，123 和 123 比。</p></li><li><p>尽量避免在 <code>WHERE</code> 子句中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p>对于连续数值，使用 <code>BETWEEN</code> 而非 <code>IN</code>，比如 <code>SELECT id FROM t WHERE num BETWEEN 1 AND 5</code>。</p></li><li><p>列表数据不要拿全表，要使用 <code>LIMIT</code> 来分页，每页数量也不要太大。</p></li></ul><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><p>目前广泛使用的是 <code>MyISAM</code> 和 <code>InnoDB</code> 两种引擎。</p><p>MyISAM 适合 SELECT 密集型的表，而 InnoDB 适合 INSERT 和 UPDATE 密集型的表。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 引擎是 MySQL 5.1 及之前版本的默认引擎，特点：</p><ul><li><p>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</p></li><li><p>不支持事务</p></li><li><p>不支持外键</p></li><li><p>不支持崩溃后的安全恢复</p></li><li><p>在表有读取查询的同时，支持往表中插入新纪录</p></li><li><p>支持 <code>BLOB</code> 和 <code>TEXT</code> 的前500个字符索引，支持全文索引</p></li><li><p>支持延迟更新索引，极大提升写入性能</p></li><li><p>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</p></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是 MySQL 5.5 之后的默认引擎，特点：</p><ul><li><p>支持行锁，采用 MVCC 来支持高并发</p></li><li><p>支持事务</p></li><li><p>支持外键</p></li><li><p>支持崩溃后的安全恢复</p></li><li><p>不支持全文索引</p></li></ul><h1 id="调优参数"><a href="#调优参数" class="headerlink" title="调优参数"></a>调优参数</h1><p>可以使用下面几个工具来做基准测试：</p><ul><li><p>sysbench：一个模块化，跨平台以及多线程的性能测试工具</p></li><li><p>iibench-mysql：基于 Java 的 MySQL&#x2F;Percona&#x2F;MariaDB 索引进行插入性能测试工具</p></li><li><p>tpcc-mysql：Percona 开发的 TPC-C 测试工具</p></li></ul><p>具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：</p><ul><li><p>back_log：出在 MySQL 暂停时回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果 MySql 的连接数据达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过 back_log，将不被授予连接资源。【可以从默认的50升至500】</p></li><li><p>wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。【可以从默认的8小时减到半小时】</p></li><li><p>max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限。</p></li><li><p>thread_concurrency：并发线程数，设为CPU核数的两倍。</p></li><li><p>skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问。</p></li><li><p>key_buffer_size：索引块的缓存大小，增大可提升索引处理速度，对 MyISAM 表性能影响最大。对于内存4G左右，可设为 256M 或 384M，通过查询 <code>show status like &#39;key_read%&#39;</code>，保证 <code>key_reads / key_read_requests</code> 在 0.1% 以下最好。</p></li><li><p>innodb_buffer_pool_size：缓存数据块和索引块，对 InnoDB 表性能影响最大。通过查询 <code>show status like &#39;Innodb_buffer_pool_read%&#39;</code>，保证 <code>(Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests</code> 越高越好。</p></li><li><p>innodb_additional_mem_pool_size：InnoDB 存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL 会记录 Warning 信息到数据库的错误日志中，这时就需要该调整这个参数大小。</p></li><li><p>innodb_log_buffer_size：InnoDB 存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB。</p></li><li><p>query_cache_size：缓存 MySQL 中的 ResultSet，也就是一条 SQL 语句执行的结果集，所以仅仅只能针对 select 语句。当某个表的数据有任何变化，都会导致所有引用了该表的 select 语句在 Query Cache 中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用 Query Cache 可能会得不偿失。根据命中率 <code>Qcache_hits / (Qcache_hits + Qcache_inserts) * 100</code> 进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大，可以通过命令 <code>show status like &#39;Qcache_%&#39;</code> 查看目前系统 Query Cache 使用大小。</p></li><li><p>read_buffer_size：MySql 读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql 会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能。</p></li><li><p>sort_buffer_size：MySql 执行排序使用的缓冲大小。如果想要增加 ORDER BY 的速度，首先看是否可以让 MySQL 使用索引而不是额外的排序阶段。如果不能，可以尝试增加 sort_buffer_size 变量的大小。</p></li><li><p>read_rnd_buffer_size：MySql 的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但 MySql 会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</p></li><li><p>record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值。</p></li><li><p>thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的。</p></li><li><p>table_cache：类似于 thread_cache_size，但用来缓存表文件，对 InnoDB 效果不大，主要用于 MyISAM。</p></li></ul><h1 id="升级硬件"><a href="#升级硬件" class="headerlink" title="升级硬件"></a>升级硬件</h1><p>根据 MySQL 是 CPU 密集型还是 I&#x2F;O 密集型，通过提升 CPU 和内存、使用 SSD，都能显著提升 MySQL 性能。</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>从库读、主库写，一般不采用双主或多主来增大复杂性，尽量采用文中的其他方案来提高性能。目前很多拆分的解决方案兼顾了读写分离。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存可以发生在这些层次：</p><ul><li><p>MySQL 内部：在系统调优参数介绍了相关设置。</p></li><li><p>数据访问层：比如 MyBatis 针对 SQL 语句做缓存，而 Hibernate 可以精确到单个记录，这里缓存的对象主要是持久化对象 Persistence Object。</p></li><li><p>应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象 Data Transfer Object。</p></li><li><p>Web 层：针对 Web 页面做缓存。</p></li><li><p>浏览器客户端：用户端的缓存。</p></li></ul><p>可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：</p><ul><li><p>直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是大多数应用缓存框架的工作方式，比如 Spring Cache。实现简单，同步好，但效率一般。</p></li><li><p>回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。实现复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率高。</p></li></ul><h1 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h1><p>MySQL 5.1 引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。</p><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对 SQL 层来说是一个完全封装底层的黑盒子。MySQL 实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。</p><p><img src="/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/table_partitions.png" alt="表分区" loading="lazy"></p><p>用户的 SQL 语句需要针对分区表做优化，条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区。</p><p>可以通过 EXPLAIN PARTITIONS 来查看某条 SQL 语句会落在那些分区上，从而进行 SQL 优化，如下5条记录落在 p1,p4 两个分区上：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain partitions <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> user_partition <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: user_partition</span><br><span class="line">   partitions: p1,p4</span><br><span class="line">         type: <span class="keyword">range</span></span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">8</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">5</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li><p>可以让单表存储更多的数据。</p></li><li><p>分区表的数据更容易维护，可以通过清除整个分区来批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作。</p></li><li><p>部分查询能够从查询条件确定只落在少数分区上，速度会很快。</p></li><li><p>分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备。</p></li><li><p>可以使用分区表赖避免某些特殊瓶颈，例如 InnoDB 单个索引的互斥访问、ext3 文件系统的 inode 锁竞争。</p></li><li><p>可以备份和恢复单个分区。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>一个表最多只能有1024个分区。</p></li><li><p>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</p></li><li><p>分区表无法使用外键约束。</p></li><li><p>NULL 值会使分区过滤无效。</p></li><li><p>所有分区必须使用相同的存储引擎。</p></li></ul><p><strong>分区类型</strong></p><ul><li><p>RANGE 分区：基于属于一个给定连续区间的列值，把多行分配给分区。</p></li><li><p>LIST 分区：类似 RANGE 分区，区别在于 LIST 分区是基于列值匹配一个离散值集合中的某个值来进行选择。</p></li><li><p>HASH 分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含 MySQL 中有效的、产生非负整数值的任何表达式。</p></li><li><p>KEY 分区：类似 HASH 分区，区别在于 KEY 分区只支持计算一列或多列，且 MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p></li></ul><p><strong>适用场景</strong></p><ul><li>时间序列性比较强，则可以按时间来分区：（查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容易地批量删除）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">    firstname <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    lastname <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">35</span>),</span><br><span class="line">    joined <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(joined) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1960</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1970</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1980</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1990</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存。</li></ul><h1 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h1><p>垂直分库是根据数据库里面的数据表的相关性进行拆分。<br>垂直分表是对数据表进行垂直拆分的一种方式。常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，使用主键关联。</p><p>比如，一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。</p><p>比如，原始的用户表：</p><p><img src="/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/original_user_table.png" alt="原始的用户表" loading="lazy"></p><p>垂直拆分后：</p><p><img src="/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/vertically_split_user_table.png" alt="垂直拆分的用户表" loading="lazy"></p><p><strong>优点</strong></p><ul><li><p>行数据变小，一个数据块（Block）就能存放更多的数据，在查询时就能减少 I&#x2F;O（每次查询时读取的 Block 就少）。</p></li><li><p>最大化利用 Cache，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起。</p></li><li><p>数据维护简单。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>主键出现冗余，需要管理冗余列。</p></li><li><p>会引起表连接 JOIN 操作，增加 CPU 开销，可以通过在业务服务器上进行 JOIN 来减少数据库压力。</p></li><li><p>依然存在单表数据量过大的问题（需要水平拆分）。</p></li><li><p>事务处理复杂。</p></li></ul><h1 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h1><p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的 MySQL 表或库，达到分布式的效果，能够支持非常大的数据量。表分区本质上也是一种特殊的库内分表。</p><p>库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻 MySQL 服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的 IO、CPU、网络，这个就要通过分库来解决</p><p>前面的用户表如果进行水平拆分（按用户名首字母）：</p><p><img src="/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/horizontally_split_user_table.png" alt="水平拆分的用户表" loading="lazy"></p><p>实际情况中往往是结合垂直拆分和水平拆分，比如将 Users_A_M 和 Users_N_Z 再拆成 Users 和 UserExtras，这样一共四张表。</p><p><strong>优点</strong></p><ul><li><p>不存在单库大数据和高并发的性能瓶颈。</p></li><li><p>应用端改造较少。</p></li><li><p>提高了系统的稳定性和负载能力。</p></li></ul><p><strong>缺点</strong></p><ul><li><p>分片事务一致性难以解决。</p></li><li><p>跨节点 Join 性能差，逻辑复杂。</p></li><li><p>数据多次扩展难度跟维护量极大。</p></li></ul><p><strong>分片原则</strong></p><ul><li><p>能不分就不分，参考单表优化。</p></li><li><p>分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。</p></li><li><p>分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性 Hash 分片，这几种分片都有利于扩容。</p></li><li><p>尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题。</p></li><li><p>查询条件尽量优化，尽量避免 Select * 的方式，大量数据结果集下，会消耗大量带宽和 CPU 资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。</p></li><li><p>通过数据冗余和表分区赖降低跨库 Join 的可能。</p></li></ul><p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p><p>总体上来说，分片的选择是取决于最频繁的查询 SQL 的条件，因为不带任何 Where 语句的查询 SQL，会遍历所有的分片，性能相对最差，因此这种 SQL 越多，对系统的影响越大，所以我们要尽量避免这种 SQL 的产生。</p><p><strong>解决方案</strong></p><p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p><p><em>客户端架构</em></p><p>通过修改数据访问层，如 JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以 Jar 包的方式呈现。</p><p>客户端架构例子：</p><p><img src="/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/client_architecture.png" alt="客户端架构" loading="lazy"></p><p>可以看到分片的实现是和应用服务器在一起的，通过修改 Spring JDBC 层来实现。</p><p>优点：</p><ul><li><p>应用直连数据库，降低外围系统依赖所带来的宕机风险。</p></li><li><p>集成成本低，无需额外运维的组件。</p></li></ul><p>缺点：</p><ul><li><p>限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心。</p></li><li><p>将分片逻辑的压力放在应用服务器上，造成额外风险。</p></li></ul><p><em>代理架构</em></p><p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件。</p><p>代理架构例子：</p><p><img src="/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/agency_architecture.png" alt="代理架构" loading="lazy"></p><p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要 Zookeeper 之类的服务组件来管理。</p><p>优点：</p><ul><li><p>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强。</p></li><li><p>对于应用服务器透明且没有增加任何额外负载。</p></li></ul><p>缺点：</p><ul><li><p>需部署和运维独立的代理中间件，成本高。</p></li><li><p>应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险。</p></li></ul><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>在 MySQL 上做 Sharding 是一种戴着镣铐的跳舞，事实上很多大表本身对 MySQL 这种 RDBMS 的需求并不大，并不要求 ACID，可以考虑将这些表迁移到 NoSQL，彻底解决水平扩展问题。</p><ul><li><p>日志类、监控类、统计类数据。</p></li><li><p>非结构化或弱结构化数据。</p></li><li><p>对事务要求不强，且无太多关联操作的数据。</p></li></ul></div><div class="article-licensing box"><div class="licensing-title"><p>MySQL 大表优化方案</p><p><a href="https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/">https://zoctan.github.io/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Zoctan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-07-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-10-29</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-634fc88092b0a58a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/pay_ali.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/pay_wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/07/22/zh/programing/basis/database/redis_and_memcached/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Redis、Memcached</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/07/21/zh/hardware/raspberry/triode_control_cooling_fan/"><span class="level-item">三极管控制散热风扇</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#单表优化"><span class="level-left"><span class="level-item">2</span><span class="level-item">单表优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字段"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">字段</span></span></a></li><li><a class="level is-mobile" href="#索引"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">索引</span></span></a></li><li><a class="level is-mobile" href="#SQL"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">SQL</span></span></a></li><li><a class="level is-mobile" href="#引擎"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">引擎</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MyISAM"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">MyISAM</span></span></a></li><li><a class="level is-mobile" href="#InnoDB"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">InnoDB</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#调优参数"><span class="level-left"><span class="level-item">3</span><span class="level-item">调优参数</span></span></a></li><li><a class="level is-mobile" href="#升级硬件"><span class="level-left"><span class="level-item">4</span><span class="level-item">升级硬件</span></span></a></li><li><a class="level is-mobile" href="#读写分离"><span class="level-left"><span class="level-item">5</span><span class="level-item">读写分离</span></span></a></li><li><a class="level is-mobile" href="#缓存"><span class="level-left"><span class="level-item">6</span><span class="level-item">缓存</span></span></a></li><li><a class="level is-mobile" href="#表分区"><span class="level-left"><span class="level-item">7</span><span class="level-item">表分区</span></span></a></li><li><a class="level is-mobile" href="#垂直拆分"><span class="level-left"><span class="level-item">8</span><span class="level-item">垂直拆分</span></span></a></li><li><a class="level is-mobile" href="#水平拆分"><span class="level-left"><span class="level-item">9</span><span class="level-item">水平拆分</span></span></a></li><li><a class="level is-mobile" href="#NoSQL"><span class="level-left"><span class="level-item">10</span><span class="level-item">NoSQL</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zoctan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script><script src="/js/post_date_tips.js"></script><script src="/js/add_runtime.js"></script><script src="/js/remove_powered_by.js"></script></body></html>