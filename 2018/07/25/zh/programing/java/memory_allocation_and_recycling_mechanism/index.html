<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>内存分配和回收机制 - Zoctan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Zoctan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zoctan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="内存分配这里所说的内存分配，主要指在堆上的分配。一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或 String 等），然后在栈上分配，在栈上分配的很少见，这里不考虑。 Java 的内存分配和回收机制概括起来就是：分代分配，分代回收。 根据存活时间，对象被分为：新生代（Young Generation）、老年代（Old Gen"><meta property="og:type" content="blog"><meta property="og:title" content="内存分配和回收机制"><meta property="og:url" content="https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/"><meta property="og:site_name" content="Zoctan&#039;s Blog"><meta property="og:description" content="内存分配这里所说的内存分配，主要指在堆上的分配。一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或 String 等），然后在栈上分配，在栈上分配的很少见，这里不考虑。 Java 的内存分配和回收机制概括起来就是：分代分配，分代回收。 根据存活时间，对象被分为：新生代（Young Generation）、老年代（Old Gen"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zoctan.github.io/%E4%B8%89%E4%BB%A31.jpg"><meta property="og:image" content="https://zoctan.github.io/%E4%B8%89%E4%BB%A32.png"><meta property="og:image" content="https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png"><meta property="og:image" content="https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg"><meta property="article:published_time" content="2018-07-24T16:00:00.000Z"><meta property="article:modified_time" content="2022-10-22T09:03:55.590Z"><meta property="article:author" content="Zoctan"><meta property="article:tag" content="zoctan,blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zoctan.github.io/%E4%B8%89%E4%BB%A31.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/"},"headline":"内存分配和回收机制","image":["https://zoctan.github.io/%E4%B8%89%E4%BB%A31.jpg","https://zoctan.github.io/%E4%B8%89%E4%BB%A32.png","https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png","https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg"],"datePublished":"2018-07-24T16:00:00.000Z","dateModified":"2022-10-22T09:03:55.590Z","author":{"@type":"Person","name":"Zoctan"},"publisher":{"@type":"Organization","name":"Zoctan's Blog","logo":{"@type":"ImageObject","url":"https://zoctan.github.io/img/logo.svg"}},"description":"内存分配这里所说的内存分配，主要指在堆上的分配。一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或 String 等），然后在栈上分配，在栈上分配的很少见，这里不考虑。 Java 的内存分配和回收机制概括起来就是：分代分配，分代回收。 根据存活时间，对象被分为：新生代（Young Generation）、老年代（Old Gen"}</script><link rel="canonical" href="https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/"><link rel="alternate" href="https://zoctan.github.io/atom.xml" title="Zoctan&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><meta name="msvalidate.01" content="3A666EB8EB887659AE5D32D988405EF2"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-109619265-1" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-109619265-1")</script><script>!function(t,h,e,j,s,n){t.hj=t.hj||function(){(t.hj.q=t.hj.q||[]).push(arguments)},t._hjSettings={hjid:3209077,hjsv:6},s=h.getElementsByTagName("head")[0],(n=h.createElement("script")).async=1,n.src="https://static.hotjar.com/c/hotjar-"+t._hjSettings.hjid+".js?sv="+t._hjSettings.hjsv,s.appendChild(n)}(window,document)</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script data-ad-client="ca-pub-3229148200516708" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2018-07-24T16:00:00.000Z" title="7/25/2018, 12:00:00 AM">2018-07-25</time></span><span class="level-item">Updated&nbsp;<time datetime="2022-10-22T09:03:55.590Z" title="10/22/2022, 5:03:55 PM">2022-10-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">an hour read (About 8116 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">内存分配和回收机制</h1><div class="content"><h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>这里所说的内存分配，主要指在堆上的分配。一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或 String 等），然后在栈上分配，在栈上分配的很少见，这里不考虑。</p><p>Java 的内存分配和回收机制概括起来就是：分代分配，分代回收。</p><p>根据存活时间，对象被分为：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。</p><p><img src="/%E4%B8%89%E4%BB%A31.jpg" alt="三代" loading="lazy"></p><p><img src="/%E4%B8%89%E4%BB%A32.png" alt="三代——《成为JavaGC专家part I》" loading="lazy"></p><span id="more"></span><p><strong>新生代</strong></p><p>对象被创建时，内存的分配首先发生在新生代（大对象可以直接被创建在老年代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被新生代的 GC 机制清理掉，这个 GC 机制被称为 Minor GC 或叫 Young GC。</p><blockquote><p>注：Minor GC 并不代表新生代内存不足，它只是表示在 Eden 区上的 GC。</p></blockquote><p>新生代分为3个区域：</p><ul><li>较大 Eden 区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过）</li><li>较小 两个大小相等的存活区（Survivor0、Survivor1）。</li></ul><p>新生代内存分配过程：</p><p><img src="/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.png" alt="新生代内存分配过程——《成为JavaGC专家part I》" loading="lazy"></p><ol><li>绝大多数刚创建的对象会被分配在 Eden 区，其中的大多数对象很快就会消亡。Eden 区是连续的内存空间，因此在其上分配内存极快；</li><li>当 Eden 区满的时候，将执行 Minor GC 清掉消亡的对象，并将剩余的对象复制到存活区 Survivor0（此时，Survivor1 空，因为两个 Survivor 总有一个为空）；</li><li>下次 Eden 区满了，再执行一次 Minor GC 清掉消亡的对象，将存活的对象复制到 Survivor1 中，然后清空 Eden 区；</li><li>将 Survivor0 中消亡的对象清理掉，将其中可以晋级的对象晋级到 Old 区，将存活的对象也复制到 Survivor1 区，然后清空 Survivor0 区；</li><li>当两个存活区切换了几次之后（HotSpot 虚拟机默认15次，用 <code>-XX:MaxTenuringThreshold</code> 控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值），仍然存活的对象（其实只有一小部分，比如我们自己定义的对象），将被复制到老年代。</li></ol><p>从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象复制到另一个 Survivor 中）。不过，它也只在新生代下高效，如果在老年代仍然采用这种方式，则不再高效。</p><p>在 Eden 区，HotSpot 虚拟机使用了两种技术来加快内存分配：</p><ul><li><p>bump-the-pointer：由于 Eden 区是连续的，因此改技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度。</p></li><li><p>TLAB（Thread-Local Allocation Buffers）：该技术是对于多线程而言的，将 Eden 区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB 结合 bump-the-pointer 技术，将保证每个线程都使用 Eden 区的一段，并快速地分配内存。</p></li></ul><p><strong>老年代（Old Generation）</strong></p><p>对象如果在新生代存活了足够长的时间而没有被清理掉（即在几次 Minor GC 后存活了下来），则会被复制到老年代，老年代的空间一般比新生代大，能存放更多的对象，在老年代上发生的 GC 次数也比新生代少。当老年代内存不足时，将执行 Major GC 或叫 Full GC。</p><p><code>-XX:+UseAdaptiveSizePolicy</code>：是否采用动态控制策略。如果动态控制，则动态调整堆中各个区域的大小以及进入老年代的年龄。</p><p>如果对象比较大（比如长字符串或大数组），新生代空间不足，则大对象会直接分配到老年代上（大对象可能触发提前 GC，应少用，更应避免使用短命的大对象）。</p><p><code>-XX:PretenureSizeThreshold</code>：控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。</p><p>可能存在老年代对象引用新生代对象的情况，如果需要执行 Minor GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决方法：老年代中维护一个 512 byte 的块 —— card table，所有老年代对象引用新生代对象的记录都记录在这里。Minor GC 时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p><h1 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h1><p><strong>新生代</strong></p><p>新生代使用“停止-复制”算法进行清理，每次进行清理时，将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中，然后清理掉 Eden 和刚才的 Survivor。</p><p>停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的 Eden 区和2个小的 Survivor 区来避免这个问题）</p><p>由于绝大部分的对象都是短命的，甚至存活不到 Survivor 中，所以 Eden 区比 Survivor 大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor + Eden 中存活下来的内存超过了10%，则需要将一部分对象分配到老年代。用 <code>-XX:SurvivorRatio</code> 参数来配置 Eden 区域 Survivor 区的容量比值，默认是8，代表 Eden：Survivor1：Survivor2 &#x3D; 8:1:1。</p><p><strong>老年代</strong></p><p>老年代存储的对象比新生代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</p><p>在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小：</p><ul><li>大于：直接触发一次 Full GC。</li><li>小于：查看是否设置了 <code>-XX:+HandlePromotionFailure</code>（允许担保失败）：如果允许，则只会进行 Minor GC，此时可以容忍内存分配失败；如果不允许，则仍然进行 Full GC。这表示如果设置了不允许担保失败，则触发 Minor GC 就会同时触发 Full GC，哪怕老年代还有很多内存，所以最好不要这样做。</li></ul><p><strong>方法区（永久代）</strong></p><p>永久代的回收有两种：</p><ul><li>常量池的常量：没有引用了就可以被回收。</li><li>无用的类信息，需满足3点：类的所有实例都已经被回收、加载类的 ClassLoader 已经被回收、类对象的 Class 对象没有被引用（即没有通过反射引用该类的地方）。</li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>在 GC 机制中，起重要作用的是垃圾收集器，垃圾收集器是 GC 的具体实现，JVM 规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾收集器各不相同，HotSpot 1.6 版使用的垃圾收集器如下图（两个收集器之间有连线，说明它们可以配合使用）：</p><p><img src="/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器——《深入理解Java虚拟机：JVM高级特效与最佳实现》" loading="lazy"></p><blockquote><p>注：在新生代采用的停止复制算法中，“停止（stop-the-world）”表示在回收内存时，需要暂停其他所有线程的执行。这很低效，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。</p></blockquote><p>注意并发（Concurrent）和并行（Parallel）的区别：</p><ul><li>并发是指用户线程与 GC 线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在 CMS 中用户线程还是需要停顿的，只是非常短，GC 线程在另一个 CPU上 执行）；</li><li>并行收集是指多个 GC 线程并行工作，但此时用户线程是暂停的。</li></ul><p>Serial 串行，Parallel 并行，CMS 并发，G1 既可以并行也可以并发。</p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><ul><li>新生代收集器</li><li>停止复制算法</li><li>单线程串行 GC，暂停其它工作线程</li></ul><p><code>-XX:+UseSerialGC</code>：开启 Serial + Serial Old 进行内存回收</p><p>Serial 收集器是虚拟机在 Client 模式下默认的新生代收集器，其收集效率大约是100M左右的内存需要几十到100多毫秒。收集桌面应用的内存垃圾，基本上不影响用户体验。所以一般的 Java 桌面应用中，使用默认的 Serial 收集器即可。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>Serial 收集器的多线程版本，默认开通的线程数与CPU数量相同。</p><ul><li>新生代收集器</li><li>停止复制算法</li><li>多个线程并行 GC，暂停其它工作线程，Serial 收集器的多线程版，缩短垃圾收集时间</li></ul><p><code>-XX:+UseParNewGC</code>：开启 ParNew + Serial Old 进行内存回收</p><p><code>-XX:ParallelGCThreads</code>：设置执行内存回收的线程数</p><p><code>-XX:SurvivorRatio</code>：</p><p><code>-XX:PretenureSizeThreshold</code>：</p><p><code>-XX:+HandlePromotionFailure</code>：</p><p><code>-XX:MaxTenuringThreshold</code>：</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><ul><li>新生代收集器</li><li>停止复制算法</li><li>关注 CPU 吞吐量，即运行用户代码的时间&#x2F;总时间，比如：JVM 运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，能最高效率地利用CPU，适合后台数据运算</li></ul><p><code>-XX:+UseParallelGC</code>：开启 Parallel Scavenge + Serial Old 进行内存回收（Server 模式下的默认设置）</p><p><code>-XX:GCTimeRatio</code>：设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收</p><p><code>-XX:MaxGCPauseMillis</code>：设置 GC 的最大停顿时间（该参数只对 Parallel Scavenge 有效）</p><p><code>-XX:+UseAdaptiveSizePolicy</code>：设置自适应调节策略，如自动调整 Eden&#x2F;Survivor 比例，老年代对象年龄，新生代大小等</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>一般用在 Client 模式。</p><ul><li>老年代收集器</li><li>标记整理算法：Sweep（清理）和 Compact（压缩）。Sweep 是将废弃的对象清掉，只留幸存的对象；Compact 是移动对象将空间填满保证内存分为2块：一块全是对象、一块空闲</li><li>单线程串行 GC，暂停其它工作线程</li><li>JDK 1.5 前，Serial Old + ParallelScavenge 进行内存回收</li></ul><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><ul><li>老年代收集器</li><li>标记整理算法：Summary（汇总）和 Compact（压缩）。Summary 是将幸存的对象复制到预先准备好的区域，而不是像 Sweep 那样清理废弃的对象</li><li>多线程并行 GC，暂停其它工作线程</li><li>有利于多核计算</li></ul><p><code>-XX:+UseParallelOldGC</code> 开启 Parallel Scavenge + Parallel Old 进行内存回收</p><p>在 JDK 1.6 后，Parallel Old + Parallel Scavenge 配合有很好的效果，能充分体现 Parallel Scavenge 收集器吞吐量优先的效果。</p><h2 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h2><ul><li>老年代收集器</li><li>关注最短回收停顿时间（即缩短垃圾回收的时间），强调用户交互体验</li><li>标记清除算法</li><li>并发收集（用户线程可以和 GC 线程同时工作），停顿小</li></ul><p>标记清除算法执行过程：（2次标记，1次预清理，1次重新标记，再1次清除）</p><ol><li>初始标记（CMS-initial-mark）</li><li>并发标记（CMS-concurrent-mark）</li><li>预清理（CMS-concurrent-preclean）</li><li>可控预清理（CMS-concurrent-abortable-preclean）</li><li>重新标记（CMS-remark）</li><li>并发清除（CMS-concurrent-sweep）</li><li>并发重设状态等待下次 CMS 的触发（CMS-concurrent-reset）</li></ol><p><code>-XX:+UseConcMarkSweepGC</code>：开启 ParNew + CMS + Serial Old 进行内存回收。Server 模式下优先使用 ParNew + CMS，当用户线程内存不足发生 Concurrent Mode Failure 时，由备用方案 ParNew + Serial Old 收集</p><p><code>-XX:CMSInitiatingOccupancyFraction</code>：</p><p><code>-XX:+UseCMSCompactAtFullCollection</code>：</p><p><code>-XX:CMSFullGCsBeforeCompaction</code>：</p><p>CMSIncrementalMode： CMS 收集器变种，属增量式垃圾收集器，在并发标记和并发清理时交替运行垃圾收集器和用户线程。</p><h2 id="G1（Garbage-First）收集器"><a href="#G1（Garbage-First）收集器" class="headerlink" title="G1（Garbage First）收集器"></a>G1（Garbage First）收集器</h2><ul><li>堆被划分成许多个连续的区域（region）</li><li>G1 算法</li><li>支持很大的堆，高吞吐量</li><li>支持多 CPU 和垃圾回收线程</li><li>在主线程暂停的情况下，使用并行收集</li><li>在主线程运行的情况下，使用并发收集</li><li>实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收</li></ul><p><code>–XX:+UseG1GC</code>：开启 G1 进行内存回收</p><h1 id="JVM-调优参数"><a href="#JVM-调优参数" class="headerlink" title="JVM 调优参数"></a>JVM 调优参数</h1><p><a target="_blank" rel="noopener" href="http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm">http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm</a></p><p>性能参数:往往用来定义内存分配的大小和比例。</p><table><thead><tr><th align="left">参数及其默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-XX:NewSize&#x3D;2.125m</td><td align="left">新生代对象生成时占用内存的默认值</td></tr><tr><td align="left">-XX:MaxNewSize&#x3D;size</td><td align="left">新生成对象能占用内存的最大值</td></tr><tr><td align="left">-XX:MaxPermSize&#x3D;64m</td><td align="left">方法区所能占用的最大内存（非堆内存）</td></tr><tr><td align="left">-XX:PermSize&#x3D;64m</td><td align="left">方法区分配的初始内存</td></tr><tr><td align="left">-XX:MaxTenuringThreshold&#x3D;15</td><td align="left">对象在新生代存活区切换的次数（坚持过 Minor GC 的次数，每坚持过一次，该值就增加1），大于该值会进入老年代</td></tr><tr><td align="left">-XX:MaxHeapFreeRatio&#x3D;70</td><td align="left">GC 后 Java 堆中空闲量占的最大比例，大于该值，则堆内存会减少</td></tr><tr><td align="left">-XX:MinHeapFreeRatio&#x3D;40</td><td align="left">GC 后 Java 堆中空闲量占的最小比例，小于该值，则堆内存会增加</td></tr><tr><td align="left">-XX:NewRatio&#x3D;2</td><td align="left">新生代内存容量与老生代内存容量的比例</td></tr><tr><td align="left">-XX:ReservedCodeCacheSize&#x3D;32m</td><td align="left">保留代码占用的内存容量</td></tr><tr><td align="left">-XX:ThreadStackSize&#x3D;512</td><td align="left">设置线程栈大小，若为0则使用系统默认值</td></tr><tr><td align="left">-XX:LargePageSizeInBytes&#x3D;4m</td><td align="left">设置用于 Java 堆的大页面尺寸</td></tr><tr><td align="left">-XX:PretenureSizeThreshold&#x3D;size</td><td align="left">大于该值的对象直接晋升入老年代（这种对象少用为好）</td></tr><tr><td align="left">-XX:SurvivorRatio&#x3D;8</td><td align="left">Eden 区域 Survivor 区的容量比值，如默认值为8，表示 Eden：Survivor0：Survivor1 &#x3D; 8:1:1</td></tr></tbody></table><p>常用的行为参数：用来选择使用什么样的垃圾收集器组合，以及控制运行过程中的 GC 策略等。</p><table><thead><tr><th align="left">参数及其默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-XX:-UseSerialGC</td><td align="left">启用串行 GC，即采用 Serial + Serial Old 模式</td></tr><tr><td align="left">-XX:-UseParallelGC</td><td align="left">启用并行 GC，即采用 Parallel Scavenge + Serial Old 收集器组合（Server 模式默认）</td></tr><tr><td align="left">-XX:GCTimeRatio&#x3D;99</td><td align="left">设置用户执行时间占总时间的比例（默认值99，即1%的时间用于 GC）</td></tr><tr><td align="left">-XX:MaxGCPauseMillis&#x3D;time</td><td align="left">设置 GC 的最大停顿时间（这个参数只对 Parallel Scavenge 有效）</td></tr><tr><td align="left">-XX:+UseParNewGC</td><td align="left">使用 ParNew + Serial Old 收集器组合</td></tr><tr><td align="left">-XX:ParallelGCThreads</td><td align="left">设置执行内存回收的线程数，在 +UseParNewGC 的情况下使用</td></tr><tr><td align="left">-XX:+UseParallelOldGC</td><td align="left">使用 Parallel Scavenge + Parallel Old 组合收集器</td></tr><tr><td align="left">-XX:+UseConcMarkSweepGC</td><td align="left">使用 ParNew + CMS + Serial Old 组合并发收集</td></tr><tr><td align="left">-XX:-DisableExplicitGC</td><td align="left">禁止调用 System.gc() 但 JVM 的 gc 仍有效</td></tr><tr><td align="left">-XX:+ScavengeBeforeFullGC</td><td align="left">新生代 GC 优先于 Full GC 执行</td></tr></tbody></table><p>常用的调试参数：用于监控和打印 GC 的信息。</p><table><thead><tr><th align="left">参数及其默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-XX:-CITime</td><td align="left">打印消耗在 JIT 编译的时间</td></tr><tr><td align="left">-XX:ErrorFile&#x3D;.&#x2F;hs_err_pid<pid>.log</pid></td><td align="left">保存错误日志或者数据到文件中</td></tr><tr><td align="left">-XX:-ExtendedDTraceProbes</td><td align="left">开启 solaris 特有的 dtrace 探针</td></tr><tr><td align="left">-XX:HeapDumpPath&#x3D;.&#x2F;java_pid<pid>.hprof</pid></td><td align="left">指定导出堆信息时的路径或文件名</td></tr><tr><td align="left">-XX:-HeapDumpOnOutOfMemoryError</td><td align="left">当首次遭遇 OOM 时导出此时堆中相关信息</td></tr><tr><td align="left">-XX:OnError&#x3D;”<cmd args>;<cmd args>“</cmd></cmd></td><td align="left">出现致命 ERROR 之后运行自定义命令</td></tr><tr><td align="left">-XX:OnOutOfMemoryError&#x3D;”<cmd args>;<cmd args>“</cmd></cmd></td><td align="left">当首次遭遇 OOM 时执行自定义命令</td></tr><tr><td align="left">-XX:-PrintClassHistogram</td><td align="left">遇到 Ctrl-Break 后打印类实例的柱状信息，与 jmap -histo 功能相同</td></tr><tr><td align="left">-XX:-PrintConcurrentLocks</td><td align="left">遇到 Ctrl-Break 后打印并发锁的相关信息，与 jstack -l 功能相同</td></tr><tr><td align="left">-XX:-PrintCommandLineFlags</td><td align="left">打印在命令行中出现过的标记</td></tr><tr><td align="left">-XX:-PrintCompilation</td><td align="left">当一个方法被编译时打印相关信息</td></tr><tr><td align="left">-XX:-PrintGC</td><td align="left">每次 GC 时打印相关信息</td></tr><tr><td align="left">-XX:-PrintGC Details</td><td align="left">每次 GC 时打印详细信息</td></tr><tr><td align="left">-XX:-PrintGCTimeStamps</td><td align="left">打印每次 GC 的时间戳</td></tr><tr><td align="left">-XX:-TraceClassLoading</td><td align="left">跟踪类的加载信息</td></tr><tr><td align="left">-XX:-TraceClassLoadingPreorder</td><td align="left">跟踪被引用到的所有类的加载信息</td></tr><tr><td align="left">-XX:-TraceClassResolution</td><td align="left">跟踪常量池</td></tr><tr><td align="left">-XX:-TraceClassUnloading</td><td align="left">跟踪类的卸载信息</td></tr><tr><td align="left">-XX:-TraceLoaderConstraints</td><td align="left">跟踪类加载器约束的相关信息</td></tr></tbody></table><h2 id="启动内存分配"><a href="#启动内存分配" class="headerlink" title="启动内存分配"></a>启动内存分配</h2><p>具体配置多少？设置小了，频繁 GC（甚至内存溢出），设置大了，内存浪费。建议：</p><p><code>-XX:PermSize</code>：尽量比 <code>-XX:MaxPermSize</code> 小，<code>-XX:MaxPermSize</code> &gt;&#x3D; 2 x <code>-XX:PermSize</code>, <code>-XX:PermSize</code> &gt; 64m，对于4G内存的机器，<code>-XX:MaxPermSize</code> 一般不超过256m。</p><p><code>-Xms</code> &#x3D; <code>-Xmx</code>（线上 Server 模式）：以防止抖动，大小受操作系统和内存大小限制，如果是32位系统，则一般设置为1g~2g（假设有4g内存），在64位系统上，没有限制，一般为机器最大内存的一半左右。</p><p><code>-Xmn</code>：在开发环境下，<code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code> 设置新生代的大小；在生产环境下，建议只设置 <code>-Xmn</code>，并且大小是 <code>-Xms</code> 的1&#x2F;2左右，不要过大或过小，过大导致老年代变小，频繁 Full GC，过小导致 Minor GC 频繁。如果不设置 <code>-Xmn</code>，可以设置 <code>-XX:NewRatio=2</code>，效果一样。</p><p><code>-Xss</code>：默认值即可。</p><p><code>-XX:SurvivorRatio</code>：8~10左右，推荐设置为10，即 Survivor 区的大小是 Eden 区的 1&#x2F;10，因为对于普通程序，一次 Minor GC 后，至少98%-99%的对象，都会消亡，该设置能使 Survivor 区容纳下10-20次的 Minor GC 才满，然后再进入老年代，这个与 <code>-XX:MaxTenuringThreshold</code> 的默认值15次也相匹配的。如果设置过小，会导致本来能通过 Minor GC 回收掉的对象提前进入老年代，产生不必要的 Full GC；如果设置过大，会导致 Eden 区相应的被压缩。</p><p><code>-XX:MaxTenuringThreshold</code>：默认15，也就是说，经过15次 Survivor 轮换（即15次 Minor GC）就进入老年代，如果设置过小，则新生代对象在 Survivor 中存活的时间减小，提前进入年老代，对于老年代比较多的应用，可以提高效率。如果设置过大，则新生代对象会在 Survivor 区进行多次复制，这样可以增加对象在新生代的存活时间，增加在新生代即被回收的概率。注意：设置了该值，并不表示对象一定会在新生代存活15次才被晋升进入老年代，它只是一个最大值，事实上，存在一个动态计算机制，计算每次晋入老年代的阈值，取阈值以 <code>MaxTenuringThreshold</code> 中较小的一个为准。</p><p><code>-XX:PretenureSizeThreshold</code>：默认值即可。</p><h2 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h2><p>在 JVM 运行的过程中，为保证其稳定、高效，或在出现 GC 问题时分析问题原因，我们需要对 GC 进行监控。所谓监控，其实就是分析清楚当前 GC 的情况。其目的是鉴别 JVM 是否在高效的进行垃圾回收，以及有没有必要进行调优。</p><p>通过监控GC，我们可以搞清楚很多问题，如：</p><ul><li>Minor GC 和 Full GC 的频率</li><li>执行一次 GC 所消耗的时间</li><li>新生代的对象何时被移到老生代以及花费了多少时间</li><li>每次 GC 中，其它线程暂停（Stop the world）的时间</li><li>每次 GC 的效果如何，是否不理想</li></ul><p><strong>jps</strong></p><p>用于查询正在运行的 JVM 进程。</p><table><thead><tr><th align="center">常用参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-q</td><td align="left">只输出 LVMID，省略主类的名称</td></tr><tr><td align="center">-m</td><td align="left">输出虚拟机进程启动时传给主类 main() 函数的参数</td></tr><tr><td align="center">-l</td><td align="left">输出主类的全类名，如果进程执行的是 jar 包，输出 jar 路径</td></tr><tr><td align="center">-v</td><td align="left">输出虚拟机进程启动时 JVM 参数</td></tr></tbody></table><p>命令格式：<code>jps [option] [hostid]</code></p><p>栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">19688 sun.tools.jps.Jps</span><br><span class="line">19610 com.zoctan.api.Application</span><br></pre></td></tr></table></figure><p>上面的 vid 为 19610 的 api.Application 进程在提供 web 服务。</p><p><strong>jstat</strong></p><p>实时显示本地或远程 JVM 进程中类装载、内存、垃圾收集、JIT 编译等数据（如果要显示远程 JVM 信息，需要远程主机开启 RMI 支持）。如果在服务启动时没有指定启动参数 <code>-verbose:gc</code>，则可以用 jstat 实时查看 GC 情况。</p><table><thead><tr><th align="center">常用参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-class</td><td align="left">监视类装载、卸载数量、总空间及类装载所耗费的时间</td></tr><tr><td align="center">-gc</td><td align="left">监听堆状况，包括 Eden 区、两个 Survivor 区、老年代、永久代等的容量，已用空间、GC 时间合计等</td></tr><tr><td align="center">-gccapacity</td><td align="left">监视内容与 -gc 基本相同，但输出主要关注堆的各个区域使用到的最大和最小空间</td></tr><tr><td align="center">-gcutil</td><td align="left">监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td align="center">-gccause</td><td align="left">与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因</td></tr><tr><td align="center">-gcnew</td><td align="left">监视新生代 GC 状况</td></tr><tr><td align="center">-gcnewcapacity</td><td align="left">监视内同与 -gcnew 基本相同，输出主要关注使用到的最大和最小空间</td></tr><tr><td align="center">-gcold</td><td align="left">监视老年代 GC 情况</td></tr><tr><td align="center">-gcoldcapacity</td><td align="left">监视内同与 -gcold 基本相同，输出主要关注使用到的最大和最小空间</td></tr><tr><td align="center">-gcpermcapacity</td><td align="left">输出永久代使用到最大和最小空间</td></tr><tr><td align="center">-compiler</td><td align="left">输出 JIT 编译器编译过的方法、耗时等信息</td></tr><tr><td align="center">-printcompilation</td><td align="left">输出已经被 JIT 编译的方法</td></tr></tbody></table><p>命令格式：<code>jstat [option vmid [interval[s|ms] [count]]]</code></p><p>命令格式中 VMID 和 LVMID 说明：</p><ul><li>如果是本地虚拟机进程，VMID 和 LVMID 一致</li><li>如果是远程虚拟机进程，VMID 格式：[protocol:][&#x2F;&#x2F;]lvmid[@hostname[:port]&#x2F;servername]，如果省略 interval 和 count，则只查询一次。</li></ul><p>栗子：搜集 vid 为 19600 的 Java 进程的整体 GC 状态，每1000ms收集一次，共收集3次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 19600 1000 3</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">7680.0 7680.0 4386.2  0.0   48640.0  17858.7   128512.0     88.0    19456.0 18871.3 2304.0 2164.6      2    0.018   0      0.000    0.018</span><br><span class="line">7680.0 7680.0 4386.2  0.0   48640.0  17858.7   128512.0     88.0    19456.0 18871.3 2304.0 2164.6      2    0.018   0      0.000    0.018</span><br><span class="line">7680.0 7680.0 4386.2  0.0   48640.0  17858.7   128512.0     88.0    19456.0 18871.3 2304.0 2164.6      2    0.018   0      0.000    0.018</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">XXXC：该区容量，XXXU：该区使用量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">S0C</td><td align="left">Survivor0区容量（Survivor1区相同，略）</td></tr><tr><td align="center">S0U</td><td align="left">Survivor0区已使用</td></tr><tr><td align="center">EC</td><td align="left">Eden 区容量</td></tr><tr><td align="center">EU</td><td align="left">Eden 区已使用</td></tr><tr><td align="center">OC</td><td align="left">老年代容量</td></tr><tr><td align="center">OU</td><td align="left">老年代已使用</td></tr><tr><td align="center">PC</td><td align="left">Perm 容量</td></tr><tr><td align="center">PU</td><td align="left">Perm 区已使用</td></tr><tr><td align="center">YGC</td><td align="left">Young GC（Minor GC）次数</td></tr><tr><td align="center">YGCT</td><td align="left">Young GC 总耗时</td></tr><tr><td align="center">FGC</td><td align="left">Full GC 次数</td></tr><tr><td align="center">FGCT</td><td align="left">Full GC 总耗时</td></tr><tr><td align="center">GCT</td><td align="left">GC 总耗时</td></tr></tbody></table><p>-gcutil 查看内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil 19600 1000 3</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC    YGCT    FGC   FGCT      GCT   </span><br><span class="line">57.11   0.00  36.72   0.07  96.99  93.95    2    0.018     0    0.000    0.018</span><br><span class="line">57.11   0.00  36.72   0.07  96.99  93.95    2    0.018     0    0.000    0.018</span><br><span class="line">57.11   0.00  36.72   0.07  96.99  93.95    2    0.018     0    0.000    0.018</span><br></pre></td></tr></table></figure><p>各列与用 gc 参数时基本一致，不同的是这里显示的是已占用的百分比，如 S0 为 57.11，代表着 S0 区已使用了57.11%。</p><p><strong>jinfo</strong></p><p>查询当前运行的 JVM 属性和参数的值。</p><table><thead><tr><th align="center">常用参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-flag</td><td align="left">显示未被显示指定的参数的系统默认值</td></tr><tr><td align="center">-flag</td><td align="left">-flag name&#x3D;value: 修改部分参数</td></tr><tr><td align="center">-sysprops</td><td align="left">打印虚拟机进程的 System.getProperties()</td></tr></tbody></table><p>命令格式：<code>jinfo [option] pid</code></p><p><strong>jmap</strong></p><p>显示当前堆和永久代的详细信息，如当前使用的收集器，当前的空间使用率等。</p><table><thead><tr><th align="center">常用参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-dump</td><td align="left">生成堆转储快照</td></tr><tr><td align="center">-heap</td><td align="left">显示堆详细信息(只在 Linux&#x2F;Solaris 下有效)</td></tr><tr><td align="center">-F</td><td align="left">当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成dump快照(只在 Linux&#x2F;Solaris 下有效)</td></tr><tr><td align="center">-finalizerinfo</td><td align="left">显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象(只在 Linux&#x2F;Solaris 下有效)</td></tr><tr><td align="center">-histo</td><td align="left">显示堆中对象统计信息</td></tr><tr><td align="center">-permstat</td><td align="left">以 ClassLoader 为统计口径显示永久代内存状态(只在 Linux&#x2F;Solaris 下有效)</td></tr></tbody></table><p>命令格式：<code>jmap [option] vmid</code></p><p>其中前面3个参数最重要，如：<br>查看对详细信息：<code>sudo jmap -heap 309</code><br>生成 dump 文件： <code>sudo jmap -dump:file=./test.prof 309</code><br>部分用户没有权限时，采用 admin 用户：<code>sudo -u admin -H jmap -dump:format=b,file=文件名.hprof pid</code><br>查看当前堆中对象统计信息：<code>sudo jmap -histo 309</code> 该命令显示3列，分别为对象数量，对象大小，对象名称，通过该命令可以查看是否内存中有大对象；<br>有的用户可能没有 jmap 权限：<code>sudo -u admin -H jmap -histo 309 | less</code></p><p><strong>jhat</strong></p><p>分析使用 jmap 生成的 dump 文件。</p><p>命令格式：<code>jhat -J -Xmx512m [file]</code></p><p><strong>jstack</strong></p><p>生成当前 JVM 的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。</p><table><thead><tr><th align="center">常用参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-F</td><td align="left">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="center">-l</td><td align="left">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="center">-m</td><td align="left">如果调用到本地方法的话，可以显示 C&#x2F;C++ 的堆栈</td></tr></tbody></table><p>命令格式：<code>jstack [option] vmid</code></p><h2 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h2><p>在调优之前，需要记住下面的原则：</p><ul><li>多数的 Java 应用不需要在服务器上进行 GC 优化</li><li>多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题</li><li>在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）</li><li>减少创建对象的数量</li><li>减少使用全局变量和大对象</li><li>GC 优化是到最后不得已才采用的手段</li><li>在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多</li></ul><p>GC 优化的目的：</p><ul><li>将转移到老年代的对象数量降低到最小</li><li>减少 Full GC 的执行时间</li></ul><p>为了达到上面的目的，需要：</p><ul><li>减少使用全局变量和大对象</li><li>调整新生代的大小到最合适</li><li>设置老年代的大小为最合适</li><li>选择合适的 GC 收集器</li></ul><p>真正熟练的使用 GC 调优，是建立在多次进行 GC 监控和调优的实战经验上的，进行监控和调优的一般步骤为：</p><ol><li>监控 GC 状态</li><li>分析结果，判断是否需要优化</li><li>调整 GC 类型和内存分配</li><li>不断的分析和调整</li><li>全面应用参数</li></ol><p><strong>监控 GC 状态</strong><br>使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 GC 日志，根据实际的各区域内存划分和 GC 执行时间，判断是否进行优化。</p><p><strong>分析结果，判断是否需要优化</strong><br>如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化；如果 GC 时间超过1-3秒，或者频繁 GC，则必须优化。<br>注：如果满足下面的指标，则一般不需要优 GC：</p><ul><li>Minor GC 执行时间不到50ms；</li><li>Minor GC 执行不频繁，约10秒一次；</li><li>Full GC 执行时间不到1s；</li><li>Full GC 执行频率不算频繁，不低于10分钟1次。</li></ul><p><strong>调整 GC 类型和内存分配</strong><br>如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找一台或几台机器进行测试，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。</p><p><strong>不断的分析和调整</strong><br>通过不断的试验和试错，分析并找到最合适的参数。</p><p><strong>全面应用参数</strong><br>如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。</p><h2 id="调优实例"><a href="#调优实例" class="headerlink" title="调优实例"></a>调优实例</h2><p><strong>实例1</strong></p><p>原作者发现部分开发测试机器出现异常：java.lang.OutOfMemoryError: GC overhead limit exceeded。该异常表示：GC 为了释放很小的空间却耗费了太多的时间，其原因一般有两个：堆太小，死循环&#x2F;大对象。</p><p>因为这个应用有在线上运行，所以首先排除第2个原因，如果应用本身有问题，线上早就挂了，所以怀疑开发测试机器中堆设置太小。</p><p>使用 <code>ps -ef | grep java</code> 查看发现运行的程序带有这些参数：<br><code>-Xms768m -Xmx768m -XX:NewSize=320m -XX:MaxNewSize=320m</code></p><p>该程序较大，需要占用的内存也比较多。但堆区设置只有768m，而机器内存有2G，机器上只跑这一个 Java 应用，没有其他需要占用内存的地方。</p><p>通过上面的情况判断，只需要增大堆中各区域的大小即可，于是改成下面的参数：<br><code>-Xms1280m -Xmx1280m -XX:NewSize=500m -XX:MaxNewSize=500m</code></p><p>跟踪运行情况发现，相关异常没有再出现。</p><p><strong>实例2</strong></p><p><a target="_blank" rel="noopener" href="http://www.360doc.com/content/13/0305/10/15643_269388816.shtml">http://www.360doc.com/content/13/0305/10/15643_269388816.shtml</a></p><p>一个服务系统，经常出现卡顿，分析原因，发现 Full GC 时间太长：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil:</span><br><span class="line">  S0    S1    E      O      P    YGC   YGCT   FGC   FGCT    GCT</span><br><span class="line">12.16  0.00  5.18  63.78  20.32   54   2.047   5    6.946  8.993</span><br></pre></td></tr></table></figure><p>分析上面的数据，发现 Young GC 执行了54次，耗时2.047秒，每次 Young GC 耗时37ms，在正常范围，而 Full GC 执行了5次，耗时6.946秒，每次平均1.389s，表明问题是：Full GC 耗时较长。</p><p>分析该程序的参数发现：NewRatio &#x3D; 9，也就是说，新生代和老生代大小之比为1:9，这就是问题的原因：</p><ul><li>新生代太小，导致对象提前进入老年代，触发老年代发生 Full GC</li><li>老年代较大，进行 Full GC 时耗时较大</li></ul><p>调整比例 NewRatio &#x3D; 4，发现卡顿现象减少，Full GC 没有再发生，只有 Young GC 在执行。这就是把对象控制在新生代就清理掉，没有进入老年代（这种做法对一些应用是很有用的，但并不是对所有应用都要这么做）。</p></div><div class="article-licensing box"><div class="licensing-title"><p>内存分配和回收机制</p><p><a href="https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/">https://zoctan.github.io/2018/07/25/zh/programing/java/memory_allocation_and_recycling_mechanism/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Zoctan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-07-25</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-10-22</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-634fc88092b0a58a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/pay_ali.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/pay_wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/07/25/zh/programing/java/class_loading_mechanism/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">类加载机制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/07/25/zh/programing/java/references_and_usage_scenarios/"><span class="level-item">四种引用和使用场景</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Zoctan"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Zoctan</p><p class="is-size-6 is-block">Full Stack Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">144</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zoctan" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zoctan"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:zoctan@163.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="https://zoctan.github.io/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li><li><a class="level is-mobile" href="/categories/book-read/"><span class="level-start"><span class="level-item">book read</span></span><span class="level-end"><span class="level-item tag">30</span></span></a><ul><li><a class="level is-mobile" href="/categories/book-read/algorithms/"><span class="level-start"><span class="level-item">algorithms</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/book-read/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/book-read/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/zh/"><span class="level-start"><span class="level-item">zh</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/zh/basis/"><span class="level-start"><span class="level-item">basis</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/zh/hardware/"><span class="level-start"><span class="level-item">hardware</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/zh/hardware/raspberry/"><span class="level-start"><span class="level-item">raspberry</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/zh/usage/"><span class="level-start"><span class="level-item">usage</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/zh/work/"><span class="level-start"><span class="level-item">work</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%8B%9C%E8%AF%BB/"><span class="level-start"><span class="level-item">拜读</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">43</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2022-10-11T16:00:00.000Z">2022-10-12</time></p><p class="title"><a href="/2022/10/12/zh/usage/v2ray_cloudfare_save_bang_ip/">V2ray + Cloudfare 拯救被墙 VPS IP</a></p><p class="categories"><a href="/categories/zh/">zh</a> / <a href="/categories/zh/usage/">usage</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-30T16:00:00.000Z">2019-01-31</time></p><p class="title"><a href="/2019/01/31/zh/programing/docker/jenkins_auto_deploy/">Jenkins 自动化部署</a></p><p class="categories"><a href="/categories/Docker/">Docker</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-28T16:00:00.000Z">2019-01-29</time></p><p class="title"><a href="/2019/01/29/zh/programing/docker/gitlab_deploy/">GitLab 搭建</a></p><p class="categories"><a href="/categories/Docker/">Docker</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-01-28T16:00:00.000Z">2019-01-29</time></p><p class="title"><a href="/2019/01/29/zh/programing/docker/registry_deploy/">Registry 搭建</a></p><p class="categories"><a href="/categories/Docker/">Docker</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2018-10-30T16:00:00.000Z">2018-10-31</time></p><p class="title"><a href="/2018/10/31/zh/programing/design_ideas/short_link_service_system/">短链接服务系统开发</a></p><p class="categories"><a href="/categories/%E6%8B%9C%E8%AF%BB/">拜读</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">January 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">August 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">June 2018</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">May 2018</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">April 2018</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">March 2018</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">February 2018</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">January 2018</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OAuth2/"><span class="tag">OAuth2</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSO/"><span class="tag">SSO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring-Cloud/"><span class="tag">Spring Cloud</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91/"><span class="tag">树</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-3229148200516708" data-ad-slot="9728616636" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zoctan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script></body></html>