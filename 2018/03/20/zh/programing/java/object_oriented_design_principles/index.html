<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>面向对象设计原则 - Zoctan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Zoctan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zoctan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="简介对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。 在面向对象设计中，可维护性的复用是以设计原则为基础的。每个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升软件结构的设计水平。"><meta property="og:type" content="blog"><meta property="og:title" content="面向对象设计原则"><meta property="og:url" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/"><meta property="og:site_name" content="Zoctan&#039;s Blog"><meta property="og:description" content="简介对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。 在面向对象设计中，可维护性的复用是以设计原则为基础的。每个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升软件结构的设计水平。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/1-1.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/1-2.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/2-1.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/2-2.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/3-1.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/3-2.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/4-1.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/4-2.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/5-1.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/5-2.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/6-1.png"><meta property="og:image" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/6-2.png"><meta property="article:published_time" content="2018-03-19T16:00:00.000Z"><meta property="article:modified_time" content="2022-11-09T09:44:30.611Z"><meta property="article:author" content="Zoctan"><meta property="article:tag" content="zoctan,blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/1-1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/"},"headline":"面向对象设计原则","image":["https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/1-1.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/1-2.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/2-1.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/2-2.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/3-1.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/3-2.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/4-1.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/4-2.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/5-1.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/5-2.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/6-1.png","https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/6-2.png"],"datePublished":"2018-03-19T16:00:00.000Z","dateModified":"2022-11-09T09:44:30.611Z","author":{"@type":"Person","name":"Zoctan"},"publisher":{"@type":"Organization","name":"Zoctan's Blog","logo":{"@type":"ImageObject","url":"https://zoctan.github.io/img/logo.svg"}},"description":"简介对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。 在面向对象设计中，可维护性的复用是以设计原则为基础的。每个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升软件结构的设计水平。"}</script><link rel="canonical" href="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/"><link rel="alternate" href="https://zoctan.github.io/atom.xml" title="Zoctan&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><meta name="msvalidate.01" content="3A666EB8EB887659AE5D32D988405EF2"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RW91M7Y2GB" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RW91M7Y2GB")</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2018-03-19T16:00:00.000Z" title="3/20/2018, 12:00:00 AM">2018-03-20</time></span><span class="level-item">Updated&nbsp;<time datetime="2022-11-09T09:44:30.611Z" title="11/9/2022, 5:44:30 PM">2022-11-09</time></span><span class="level-item"><a class="link-muted" href="/categories/zh/">zh</a><span> / </span><a class="link-muted" href="/categories/zh/programing/">programing</a><span> / </span><a class="link-muted" href="/categories/zh/programing/java/">java</a></span><span class="level-item">an hour read (About 6785 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">面向对象设计原则</h1><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。</p><p>在面向对象设计中，可维护性的复用是以设计原则为基础的。每个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升软件结构的设计水平。</p><span id="more"></span><p>常见的7种面向对象设计原则：</p><p><strong>单一职责原则</strong><br>SRP：Single Responsibility Principle -&gt; 一个类只负责一个功能领域中的相应职责</p><p><strong>开闭原则</strong><br>OCP：Open-Closed Principle -&gt; 软件实体应对扩展开放，而对修改关闭</p><p><strong>里氏代换原则</strong><br>LSP：Liskov Substitution Principle -&gt; 所有引用基类对象的地方能够透明地使用其子类的对象</p><p><strong>依赖反转原则</strong><br>DIP：Dependence Inversion Principle -&gt; 抽象不应该依赖于细节，细节应该依赖于抽象</p><p><strong>接口隔离原则</strong><br>ISP：Interface Segregation Principle -&gt; 使用多个专门的接口，而不使用单一的总接口</p><p><strong>合成复用原则</strong><br>CRP：Composite Reuse Principle -&gt; 尽量使用对象组合，而不是继承来达到复用的目的</p><p><strong>迪米特法则</strong><br>LoD：Law of Demeter -&gt; 一个软件实体应当尽可能少地与其他实体发生相互作用</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7536542">单一职责原则</a></h1><p>定义：一个类只负责一个功能领域中的相应职责，或定义为：就一个类而言，应该只有一个引起它变化的原因。</p><p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p><p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><p>举个栗子：</p><p>某 CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块的初始设计方案：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/1-1.png" alt="1-1" loading="lazy"></p><p>CustomerDataChart 类中的方法：getConnection() 连接数据库、findCustomers() 查询所有的客户信息、createChart() 创建图表、displayChart() 显示图表。</p><p>CustomerDataChart 类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库，或者使用 findCustomers() 方法查询客户信息，就难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。</p><p>因此需要对该类进行拆分，使其满足单一职责原则，将 CustomerDataChart 类拆分为如下三个类：</p><ol><li>DBUtil：负责数据库操作，包括数据库连接方法 getConnection()；</li><li>CustomerDAO：负责操作数据库中的 Customer 表，包括对 Customer 表的增删改查等方法，如 findCustomers()；</li><li>CustomerDataChart：负责图表的生成和显示，包括方法 createChart() 和 displayChart()。</li></ol><p>重构后的结构：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/1-2.png" alt="1-2" loading="lazy"></p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7537584">开闭原则</a></h1><p>定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展，其中软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</p><p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在 Java、C# 等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><p>举个栗子：</p><p>某 CRM 系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/2-1.png" alt="2-1" loading="lazy"></p><p>在 ChartDisplay 类的 display() 方法中存在如下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">&quot;pie&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">PieChart</span> <span class="variable">chart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PieChart</span>();</span><br><span class="line">    chart.display();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;bar&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">BarChart</span> <span class="variable">chart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BarChart</span>();</span><br><span class="line">    chart.display();</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>如果想新增一个图表类，如折线图 LineChart，那么只能修改 ChartDisplay 类的 display() 方法的源代码，增加判断逻辑。<br>如果新增的不止一个图表呢？如果后来需求改了，又得删除呢？代码就会变得难以修改和维护，这就是违反开闭原则的表现。</p><p>现对该系统进行重构，使之符合开闭原则：</p><p>本例中，由于在 ChartDisplay 类的 display() 方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。只能通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则：</p><ol><li>增加一个抽象图表类 AbstractChart，将各种具体图表类作为其子类；</li><li>ChartDisplay 类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。</li></ol><p>重构后的结构：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/2-2.png" alt="2-2" loading="lazy"></p><p>这时如果想新增一种图表，如折线图 LineChart，那么 LineChart 只需要继承 AbstractChart，客户端在使用时只要向 ChartDisplay 中注入一个 LineChart 对象即可，无须修改现有类库的源代码。</p><blockquote><p>注：xml 和 properties 等格式的配置文件属于纯文本文件，无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的代码没有做任何修改，即可认为该系统是一个符合开闭原则的系统。</p></blockquote><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7540445">里氏替换原则</a></h1><p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士 Barbara Liskov 教授和卡内基·梅隆大学 Jeannette Wing 教授于1994年提出。<br>严格定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。</p><p>通俗定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p><p>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p><p>比如，有两个类，一个基类 BaseClass，一个子类 SubClass：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法接受 BaseClass 类型参数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(BaseClass base)</span>;</span><br><span class="line"><span class="comment">// 那么也必然可以接受 BaseClass 的子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即可以这样调用：</span></span><br><span class="line">SubClass sub;</span><br><span class="line">method1(sub);<span class="comment">// 能够正常运行</span></span><br></pre></td></tr></table></figure><p>但是，反过来不成立：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法接受 SubClass 类型参数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(SubClass sub)</span>;</span><br><span class="line"><span class="comment">// 但一般不可以接受 BaseClass 基类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样调用：</span></span><br><span class="line">BaseClass base;</span><br><span class="line">method2(base);<span class="comment">// 除非是重载方法</span></span><br></pre></td></tr></table></figure><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>需要注意如下几个问题：</p><ol><li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。（根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法）</li><li>尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</li><li>Java 语言中，在编译阶段，Java 编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但 Java 编译器的检查是有局限的。</li></ol><p>举个栗子：</p><p>某 CRM 系统中，客户（Customer）可以分为 VIP 客户（VIPCustomer）、普通客户（CommonCustomer）两类，系统需要提供一个发送 Email 的功能，原始设计方案：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/3-1.png" alt="3-1" loading="lazy"></p><p>无论是普通客户还是 VIP 客户，发送邮件的过程都是相同的，也就是说两个 send() 方法中的代码重复，而且在本系统中还将增加新类型的客户。</p><p>为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构：</p><ul><li>新增抽象客户类 Customer，将 CommonCustomer 和 VIPCustomer 类作为其子类；</li><li>将 EmailSender 中的 send() 方法的参数类型改为 Customer，如果需要增加新类型的客户，只需将其作为 Customer 类的子类即可。</li></ul><p>重构后的结构：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/3-2.png" alt="3-2" loading="lazy"></p><p>本例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。</p><h1 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7562783">依赖反转原则</a></h1><p>定义：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p><p>如果说开闭原则是面向对象设计的目标的话，那么依赖反转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p><p>需要注意如下几个问题：</p><ul><li>代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</li><li>为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</li></ul><p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>在实现依赖倒转原则时，需要我们针对抽象层编程，将具体类的对象通过依赖注入的方式注入到其他对象中。</p><p>依赖注入（DependencyInjection, DI）是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</p><p>常用的注入方式有三种：</p><p><strong>构造注入</strong><br>通过构造函数来传入具体类的对象。</p><p><strong>Setter注入</strong><br>通过Setter方法来传入具体类的对象。</p><p><strong>接口注入</strong><br>通过在接口中声明的业务方法来传入具体类的对象。</p><p>这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p><p>举个栗子：</p><p>某 CRM 系统：该系统经常需要将存储在 TXT 或 Excel 文件中的客户信息转存到数据库中，因此需要进行数据格式转换，初始设计方案：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/4-1.png" alt="4-1" loading="lazy"></p><p>该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将 TXTDataConvertor 改为 ExcelDataConvertor，此时，需要修改 CustomerDAO 的源代码，而且在引入并使用新的数据转换类时也不得不修改 CustomerDAO 的源代码。</p><p>系统扩展性较差，违反了开闭原则，现需要对该方案进行重构，使之符合依赖反转原则：</p><ul><li>引用抽象数据转换类 DataConvertor，CustomerDAO 针对抽象类 DataConvertor 编程；</li><li>将具体数据转换类名存储在配置文件中。</li></ul><p>根据里氏代换原则，程序运行时，具体数据转换类对象将替换 DataConvertor 类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为 DataConvertor 的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。</p><p>重构后的结构：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/4-2.png" alt="4-2" loading="lazy"></p><p>在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖反转原则。<br>在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖反转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。</p><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7562842">接口隔离原则</a></h1><p>定义：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。<br>这里的“接口”往往有两种不同的含义：</p><ol><li>一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；</li><li>一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如 Java 语言中的 interface。</li></ol><p>对于这两种不同的含义，接口隔离原则的表达方式以及含义都有所不同：</p><ol><li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</li><li>如果把“接口”理解成狭义的特定语言的接口，那么是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</li></ol><p>举个栗子：</p><p>某 CRM 系统的客户数据显示模块接口：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/5-1.png" alt="5-1" loading="lazy"></p><p>dataRead() 从文件中读取数据<br>transformToXML() 将数据转换成 XML 格式<br>createChart() 创建图表<br>displayChart() 显示图表<br>createReport() 创建文字报表<br>displayReport() 显示文字报表。</p><p>在实际使用过程中发现该接口很不灵活：</p><ol><li>如果一个具体的数据显示类本身不需要进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的 transformToXML() 方法（至少需要提供一个空实现）；</li><li>如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。</li></ol><p>CustomerDataDisplay 接口定义了太多方法，即该接口承担了太多职责：</p><ol><li>导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；</li><li>由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。</li></ol><p>现使用接口隔离原则和单一职责原则对其进行重构：</p><ul><li>将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法。</li></ul><p>重构后的结构：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/5-2.png" alt="5-2" loading="lazy"></p><p>注：</p><ol><li>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；</li><li>接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</li><li>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</li></ol><h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion/article/details/7563445">迪米特法则</a></h1><p>迪米特法则又称最少知识原则(LeastKnowledge Principle, LKP)，来自1987年美国东北大学(Northeastern University)一个名为 Demeter 的研究项目。</p><p>定义：一个软件实体应当尽可能少地与其他实体发生相互作用。</p><p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p><p>迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等。对于一个对象，其朋友包括以下几类：</p><ul><li>当前对象本身(this)；</li><li>以参数形式传入到当前对象方法中的对象；</li><li>当前对象的成员对象；</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li><li>当前对象所创建的对象。</li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p><p>需要注意如下几个问题：</p><ol><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类；</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ol><p>举个栗子：</p><p>某 CRM 系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，比如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变。<br>初始设计方案：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/6-1.png" alt="6-1" loading="lazy"></p><p>由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。</p><p>现使用迪米特对其进行重构：通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。</p><p>重构后的结构：</p><p><img src="/2018/03/20/zh/programing/java/object_oriented_design_principles/6-2.png" alt="6-2" loading="lazy"></p><p>引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码。</p></div><div class="article-licensing box"><div class="licensing-title"><p>面向对象设计原则</p><p><a href="https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/">https://zoctan.github.io/2018/03/20/zh/programing/java/object_oriented_design_principles/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Zoctan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-03-20</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-09</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-634fc88092b0a58a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/pay_ali.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/pay_wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/03/21/zh/programing/basis/algorithm/three_common_gaming_games/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">三个常见博弈游戏</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/03/20/zh/programing/basis/algorithm/top_10_classic_sorting_algorithms/"><span class="level-item">十大经典排序算法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#单一职责原则"><span class="level-left"><span class="level-item">2</span><span class="level-item">单一职责原则</span></span></a></li><li><a class="level is-mobile" href="#开闭原则"><span class="level-left"><span class="level-item">3</span><span class="level-item">开闭原则</span></span></a></li><li><a class="level is-mobile" href="#里氏替换原则"><span class="level-left"><span class="level-item">4</span><span class="level-item">里氏替换原则</span></span></a></li><li><a class="level is-mobile" href="#依赖反转原则"><span class="level-left"><span class="level-item">5</span><span class="level-item">依赖反转原则</span></span></a></li><li><a class="level is-mobile" href="#接口隔离原则"><span class="level-left"><span class="level-item">6</span><span class="level-item">接口隔离原则</span></span></a></li><li><a class="level is-mobile" href="#迪米特法则"><span class="level-left"><span class="level-item">7</span><span class="level-item">迪米特法则</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zoctan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script><script src="/js/post_date_tips.js"></script><script src="/js/add_runtime.js"></script><script src="/js/remove_powered_by.js"></script></body></html>