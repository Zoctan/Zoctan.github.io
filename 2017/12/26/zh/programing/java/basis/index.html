<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>Java 基础概念 - Zoctan&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Zoctan&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zoctan&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="J2SE、J2EE、J2MEJ2SE（Java 2 Platform Standard Edition）标准版J2SE 主要用于开发客户端（桌面应用软件），如：常用的文本编辑器、下载软件、即时通讯工具等。 J2SE 包含了 Java 的核心类库，如数据库连接、接口定义、输入&amp;#x2F;输出、网络编程等。 J2EE（Java 2 Platform Enterprise Edition）企业版J2EE"><meta property="og:type" content="blog"><meta property="og:title" content="Java 基础概念"><meta property="og:url" content="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/"><meta property="og:site_name" content="Zoctan&#039;s Blog"><meta property="og:description" content="J2SE、J2EE、J2MEJ2SE（Java 2 Platform Standard Edition）标准版J2SE 主要用于开发客户端（桌面应用软件），如：常用的文本编辑器、下载软件、即时通讯工具等。 J2SE 包含了 Java 的核心类库，如数据库连接、接口定义、输入&amp;#x2F;输出、网络编程等。 J2EE（Java 2 Platform Enterprise Edition）企业版J2EE"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/implementation_of_charsequence_interface.png"><meta property="og:image" content="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/c_include.png"><meta property="og:image" content="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/java_packet.png"><meta property="og:image" content="https://zoctan.github.io/transitions_between_thread_states.png"><meta property="og:image" content="https://zoctan.github.io/relationship_between_memory_and_threads.png"><meta property="og:image" content="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/sort_by_operation_method.jpg"><meta property="og:image" content="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/sort_by_operation_object.jpg"><meta property="article:published_time" content="2017-12-25T16:00:00.000Z"><meta property="article:modified_time" content="2022-11-21T09:39:28.067Z"><meta property="article:author" content="Zoctan"><meta property="article:tag" content="zoctan,blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/implementation_of_charsequence_interface.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zoctan.github.io/2017/12/26/zh/programing/java/basis/"},"headline":"Java 基础概念","image":["https://zoctan.github.io/2017/12/26/zh/programing/java/basis/implementation_of_charsequence_interface.png","https://zoctan.github.io/2017/12/26/zh/programing/java/basis/c_include.png","https://zoctan.github.io/2017/12/26/zh/programing/java/basis/java_packet.png","https://zoctan.github.io/transitions_between_thread_states.png","https://zoctan.github.io/relationship_between_memory_and_threads.png","https://zoctan.github.io/2017/12/26/zh/programing/java/basis/sort_by_operation_method.jpg","https://zoctan.github.io/2017/12/26/zh/programing/java/basis/sort_by_operation_object.jpg"],"datePublished":"2017-12-25T16:00:00.000Z","dateModified":"2022-11-21T09:39:28.067Z","author":{"@type":"Person","name":"Zoctan"},"publisher":{"@type":"Organization","name":"Zoctan's Blog","logo":{"@type":"ImageObject","url":"https://zoctan.github.io/img/logo.svg"}},"description":"J2SE、J2EE、J2MEJ2SE（Java 2 Platform Standard Edition）标准版J2SE 主要用于开发客户端（桌面应用软件），如：常用的文本编辑器、下载软件、即时通讯工具等。 J2SE 包含了 Java 的核心类库，如数据库连接、接口定义、输入&#x2F;输出、网络编程等。 J2EE（Java 2 Platform Enterprise Edition）企业版J2EE"}</script><link rel="canonical" href="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/"><link rel="alternate" href="https://zoctan.github.io/atom.xml" title="Zoctan&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><meta name="msvalidate.01" content="3A666EB8EB887659AE5D32D988405EF2"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RW91M7Y2GB" async></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-RW91M7Y2GB")</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>(function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();</script><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2017-12-25T16:00:00.000Z" title="12/26/2017, 12:00:00 AM">2017-12-26</time></span><span class="level-item">Updated&nbsp;<time datetime="2022-11-21T09:39:28.067Z" title="11/21/2022, 5:39:28 PM">2022-11-21</time></span><span class="level-item"><a class="link-muted" href="/categories/zh/">zh</a><span> / </span><a class="link-muted" href="/categories/zh/programing/">programing</a><span> / </span><a class="link-muted" href="/categories/zh/programing/java/">java</a></span><span class="level-item">3 hours read (About 26996 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Java 基础概念</h1><div class="content"><h1 id="J2SE、J2EE、J2ME"><a href="#J2SE、J2EE、J2ME" class="headerlink" title="J2SE、J2EE、J2ME"></a>J2SE、J2EE、J2ME</h1><p><strong>J2SE（Java 2 Platform Standard Edition）标准版</strong><br>J2SE 主要用于开发客户端（桌面应用软件），如：常用的文本编辑器、下载软件、即时通讯工具等。</p><p>J2SE 包含了 Java 的核心类库，如数据库连接、接口定义、输入&#x2F;输出、网络编程等。</p><p><strong>J2EE（Java 2 Platform Enterprise Edition）企业版</strong><br>J2EE 是功能最丰富的一个版本，主要用于开发高访问量、大数据量、高并发量的网站，如：美团、去哪儿网的后台。通常所说的 JSP 开发就是 J2EE 的一部分。</p><p>J2EE 包含 J2SE 中的类，还包含用于开发企业级应用的类，如：EJB、servlet、JSP、XML、事务控制等。</p><p>J2EE 也可以用来开发技术比较庞杂的管理软件，如：ERP 系统（Enterprise Resource Planning，企业资源计划系统）。</p><p><strong>J2ME（Java 2 Platform Micro Edition）微型版</strong><br>J2ME 只包含 J2SE 中的一部分类，受平台影响比较大，主要用于嵌入式系统和移动平台的开发，如：呼机、智能卡、手机、机顶盒等。</p><p>在智能手机还没有进入公众视野时，摩托罗拉、诺基亚等手机上很多 Java 小游戏就是用 J2ME 开发的。</p><p>Java 的初衷就是做这一块的开发。</p><blockquote><p>注：Android 手机有自己的开发组件，不使用 J2ME 进行开发。</p></blockquote><p>Java 5.0 后，J2SE、J2EE、J2ME 分别更名为 Java SE、Java EE、Java ME，由于习惯，我们依然称之为 J2SE、J2EE、J2ME。</p><span id="more"></span><h1 id="JRE、JDK"><a href="#JRE、JDK" class="headerlink" title="JRE、JDK"></a>JRE、JDK</h1><p><strong>JRE（Java Runtime Environment）运行时环境</strong><br>包含了 Java 虚拟机，Java 基础类库。是使用 Java 语言编写的程序运行所需要的软件环境，是提供给想运行 Java 程序的用户使用的。如果需要运行 Java 程序，只需安装 JRE 即可。</p><p>根据不同操作系统（如：Windows、Linux等）和不同提供商（IBM、ORACLE等），JRE 有很多版本，最常用的是 Oracle 公司收购 SUN 公司的 JRE 版本。</p><p><strong>JDK（Java Development Kit）开发工具包</strong><br>是程序员使用 Java 语言编写 Java 程序所需的开发工具包，是提供给程序员使用的。JDK 包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具：Jconsole，Jvisualvm 等工具软件，Java 程序编写所需的文档和 Demo 例子程序。如果需要编写 Java 程序，即需要安装 JDK。</p><h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><p>Java 是一种强类型的语言，声明变量时必须指明数据类型。变量（variable）的值占据一定的内存空间。不同类型的变量占据不同的大小。</p><p>语法比较简单，重点说下：StringBuffer 与 StringBuider。</p><p>String 的值是不可变的，每次对 String 的操作都会生成新的 String 对象，不仅效率低，而且耗费大量内存空间。</p><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>StringBuffer 类和 String 类一样，也用来表示字符串，但是 StringBuffer 的内部实现方式和 String 不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于 String。</p><p>StringBuffer 默认分配 16 字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象。</p><p>StringBuffer 只能通过 new 来创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配默认的16个字节长度的缓冲区</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配512个字节长度的缓冲区</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在缓冲区中存放了字符串，并在后面预留了16个字节长度的空缓冲区</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;www.xx.com&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>StringBuffer 类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是 StringBuffer 类和 String 类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。</p><p>append()：向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer 对象的内容也发生改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;biancheng100&quot;</span>);</span><br><span class="line">str.append(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>对象 str 的值将变成 “biancheng100true”<br>注意是 str 指向的内容变了，不是 str 的指向变了</p><p>字符串的 “+” 操作实际上也是先创建一个 StringBuffer 对象，<br>然后调用 append() 方法将字符串片段拼接起来，最后调用 toString() 方法转换为字符串</p><p>这样看来，String 的连接操作就比 StringBuffer 多出了一些附加操作，效率上必然会打折扣</p><p>但是，对于长度较小的字符串，”+” 操作更加直观，更具可读性，有些时候可以稍微牺牲一下效率</p><p>deleteCharAt()：删除指定位置的字符，并将剩余的字符形成新的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"><span class="comment">// 删除索引值为3的字符，即”d“字符</span></span><br><span class="line">str.deleteCharAt(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>delete()：方法一次性删除多个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"><span class="comment">// 删除索引值为 1~4 之间的字符，包括索引值 1，但不包括 4</span></span><br><span class="line">str.delete(<span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>insert()：在指定位置插入字符串，可以认为是 append() 的升级版。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"><span class="comment">// 最后 str 所指向的字符串为 abcdxyzef</span></span><br><span class="line">str.insert(<span class="number">3</span>, <span class="string">&quot;xyz&quot;</span>);</span><br></pre></td></tr></table></figure><p>setCharAt()：修改指定位置的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"><span class="comment">// 把索引值为3的字符修改为 z，最后 str 所指向的字符串为 abczef</span></span><br><span class="line">str.setCharAt(<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>StringBuffer 线程安全；StringBuilder 线程不安全。</p><p>StringBuffer、StringBuilder、String 中都实现了 CharSequence 接口。</p><p>CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个API。</p><p>StringBuffer、StringBuilder、String 对 CharSequence 接口的实现过程不一样：</p><p><img src="/2017/12/26/zh/programing/java/basis/implementation_of_charsequence_interface.png" alt="对CharSequence接口的实现" loading="lazy"></p><p>String 直接实现了 CharSequence 接口；<br>StringBuilder 和 StringBuffer 都是可变的字符序列，它们都继承于 AbstractStringBuilder，实现了 CharSequence 接口。</p><h1 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h1><p>Java 中的类可以看做 C 语言中结构体的升级版。</p><p>结构体是一种构造数据类型，可以包含不同的成员（变量），每个成员的数据类型可以不一样；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。</p><figure class="highlight c"><figcaption><span>结构体</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">        <span class="comment">// 结构体包含的变量</span></span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">float</span> score;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 通过结构体来定义变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span></span><br><span class="line">    <span class="comment">// 操作结构体的成员</span></span><br><span class="line">    stu1.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    stu1.age = <span class="number">15</span>;</span><br><span class="line">    stu1.score = <span class="number">92.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明的年龄是 15，成绩是 92.500000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的年龄是 %d，成绩是 %f\n&quot;</span>, stu1.name, stu1.age, stu1.score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java 中的类也是一种构造数据类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象”。</p><figure class="highlight java"><figcaption><span>类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过class关键字类定义类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">            <span class="comment">// 类包含的变量</span></span><br><span class="line">            String name;</span><br><span class="line">            <span class="type">int</span> age;</span><br><span class="line">            <span class="type">float</span> score;</span><br><span class="line">            <span class="comment">// 类包含的函数</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println( name + <span class="string">&quot;的年龄是 &quot;</span> + age + <span class="string">&quot;，成绩是 &quot;</span> + score );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过类来定义变量</span></span><br><span class="line">        <span class="comment">// 必须使用new关键字创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">// 操作类的成员</span></span><br><span class="line">        stu1.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        stu1.age = <span class="number">15</span>;</span><br><span class="line">        stu1.score = <span class="number">92.5f</span>;</span><br><span class="line">        <span class="comment">// 小明的年龄是 15，成绩是 92.5</span></span><br><span class="line">        stu1.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C 语言中，通过结构体名称就可以完成结构体变量的定义，并分配内存空间；<br>但在 Java 中，仅仅通过类来定义变量不会分配内存空间，必须使用 new 关键字来完成内存空间的分配。</p><p>类的变量：属性（通常也称成员变量），函数：方法。它们统称为类的成员。</p><p>类可以比喻成图纸，对象比喻成产品，图纸说明了产品的参数及其承担的任务；一张图纸可以生产出具有相同性质的产品，不同图纸可以生产不同类型的产品。</p><p>使用 new 关键字，就可以通过类来创建对象，即将图纸生产成产品，这个过程叫做类的实例化，因此也称对象是类的一个实例。</p><blockquote><p>注：类只是一张图纸，起到说明的作用，不占用内存空间；对象才是具体的产品，要有地方来存放，才会占用内存空间。</p></blockquote><p>在 C 语言中，可以将完成某个功能的重复使用的代码块定义为函数，将具有一类功能的函数声明在一个头文件中，不同类型的函数声明在不同的头文件，以便对函数进行更好的管理，方便编写和调用。</p><p><img src="/2017/12/26/zh/programing/java/basis/c_include.png" alt="include" loading="lazy"></p><p>在 Java 中，可以将完成某个功能的代码块定义为方法，将具有相似功能的方法定义在一个类中，也就是定义在一个源文件中（因为一个源文件只能包含一个公共的类），多个源文件可以位于一个文件夹，这个文件夹有特定的称呼，叫做包。</p><p><img src="/2017/12/26/zh/programing/java/basis/java_packet.png" alt="packet" loading="lazy"></p><p>面向对象编程在软件执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。</p><h1 id="访问修饰符-x2F-访问控制符"><a href="#访问修饰符-x2F-访问控制符" class="headerlink" title="访问修饰符&#x2F;访问控制符"></a>访问修饰符&#x2F;访问控制符</h1><table><thead><tr><th align="left">修饰符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">共有的，对所有类可见。</td></tr><tr><td align="left">protected</td><td align="left">受保护的，对同一包内的类和所有子类可见。</td></tr><tr><td align="left">private</td><td align="left">私有的，在同一类内可见。</td></tr><tr><td align="left">默认</td><td align="left">在同一包内可见。默认不使用任何修饰符。</td></tr></tbody></table><p>public：类、方法、构造方法和接口能够被任何其他类访问。类的继承性，类所有的公有方法和变量都能被其子类继承。</p><p>protected：方法和成员变量能够声明为 <code>protected</code>，不能修饰接口。<br>子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p><p>private：方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。声明为私有访问类型的变量只能通过类中公共的 Getter&#x2F;Setter 方法被外部类访问。主要用来隐藏类的实现细节和保护类的数据。</p><p>默认：接口里的变量都隐式声明为 <code>public static final</code>，而接口里的方法默认情况下访问权限为 <code>public</code>。</p><p>方法继承规则：</p><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。不能声明为 private（即不能越来越隐秘，只能越来越公开）。</li><li>父类中默认修饰符声明的方法，能够在子类中声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承（实际是继承了，但是无法访问）。</li></ul><h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><p>类级变量&#x2F;全局级变量&#x2F;静态变量：使用 static 关键字修饰。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。</p><p>对象实例级变量：成员变量，实例化后才会分配内存空间，才能访问。</p><p>方法级变量：在方法内部定义的变量，就是局部变量。</p><p>块级变量：定义在一个块内部的变量（指由大括号包围的代码），变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。</p><figure class="highlight java"><figcaption><span>作用域</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 类级变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">    <span class="comment">// 对象实例级变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 属性块，在类初始化属性时候运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 块级变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法级变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 块级变量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不能访问块级变量k，块级变量只能在块内部访问</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;, i=&quot;</span> + i + <span class="string">&quot;, j=&quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 不创建对象，直接通过类名访问类级变量</span></span><br><span class="line">        System.out.println(Demo.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象并访问它的方法</span></span><br><span class="line">        <span class="type">Demo</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        t.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：<br>demo<br>name&#x3D;demo, i&#x3D;0, j&#x3D;3</p><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>方法重载（method overloading）：同一个类中的多个方法有相同的名称，但它们的参数列表不同。</p><p>不同包括：个数、类型和顺序。</p><ul><li>仅仅参数变量名称不同是不可以的。</li><li>跟成员方法一样，构造方法也可以重载。</li><li>声明为 final 的方法不能被重载。</li><li>声明为 static 的方法不能被重载，但是能够被再次声明。</li></ul><p>重载的规则：</p><ul><li>方法名称必须相同。</li><li>参数列表必须不同。</li><li>方法的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为方法的重载。</li></ul><p>重载是面向对象的一个基本特性。</p><p>方法签名：方法名称 + 参数列表（顺序和类型）。</p><blockquote><p>注：方法签名不包括：方法的返回类型，返回值和访问修饰符。</p></blockquote><p>常见应用：重载和重写。</p><figure class="highlight java"><figcaption><span>方法重载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 一个普通的方法，不带参数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No parameters&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载上面的方法，并且带了一个整型参数，且有整型返回值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + a);</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Demo obj= <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        obj.test();</span><br><span class="line">        obj.test(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">No parameters</span><br><span class="line">a: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>重载的实现：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法；如果匹配失败，编译器会报错，这叫做重载分辨。</p><h1 id="程序的基本运行顺序"><a href="#程序的基本运行顺序" class="headerlink" title="程序的基本运行顺序"></a>程序的基本运行顺序</h1><figure class="highlight java"><figcaption><span>运行顺序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">        age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        System.out.println(obj.name + <span class="string">&quot;的年龄是&quot;</span> + obj.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序：</p><ol><li>先运行到第 8 行，这是程序的入口。</li><li>然后运行到第 9 行，这里要 new 一个Demo，就要调用 Demo 的构造方法。</li><li>就运行到第 4 行，注意：初始化一个类，必须先初始化它的属性。</li><li>因此运行到第 2 行，然后是第 3 行。</li><li>属性初始化完过后，才回到构造方法，执行里面的代码，也就是第 5 行、第 6 行。</li><li>然后是第 9 行，表示 new 一个Demo实例完成。</li><li>然后回到 main 方法中执行第 10 行。</li><li>然后是第 11 行，main方法执行完毕。</li></ol><p>总结：程序入口 -&gt; 类属性 -&gt; 构造方法</p><p>复杂情况下的初始化：</p><ol><li>父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；</li><li>子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；</li><li>父类的普通成员变量和代码块，再执行父类的构造方法；</li><li>子类的普通成员变量和代码块，再执行子类的构造方法；</li></ol><h1 id="包装类、拆箱和装箱"><a href="#包装类、拆箱和装箱" class="headerlink" title="包装类、拆箱和装箱"></a>包装类、拆箱和装箱</h1><table><thead><tr><th align="left">基本数据类型</th><th align="left">对应的包装类</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">Boolean</td></tr><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">char</td><td align="left">Character</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr></tbody></table><table><thead><tr><th align="left">基本数据类型</th><th align="center">占用的字节数</th><th align="center">取值范围</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="center">1</td><td align="center">ture &#x2F; flase</td><td align="center">flase</td></tr><tr><td align="left">byte</td><td align="center">1</td><td align="center">-128 ~ 127</td><td align="center">0</td></tr><tr><td align="left">short</td><td align="center">2</td><td align="center">-2^15 ~ 2^15-1</td><td align="center">0</td></tr><tr><td align="left">int</td><td align="center">4</td><td align="center">-2^31 ~ 2^31-1</td><td align="center">0</td></tr><tr><td align="left">long</td><td align="center">8</td><td align="center">-2^63 ~ 2^63-1</td><td align="center">0</td></tr><tr><td align="left">char</td><td align="center">2</td><td align="center">0 ~ 2^16-1</td><td align="center">\u0000</td></tr><tr><td align="left">float</td><td align="center">4</td><td align="center">0x0.000002P-126f ~ 0x1.fffffeP+127f</td><td align="center">0.0f</td></tr><tr><td align="left">double</td><td align="center">8</td><td align="center">0x0.0000000000001P-1022 ~ 0x1.fffffffffffffP+1023</td><td align="center">0.0d</td></tr></tbody></table><p>基本类型和对应的包装类相互装换：</p><ul><li>装箱：由基本类型向对应的包装类转换，如把 int 包装成 Integer 类的对象。</li><li>拆箱：包装类向对应的基本类型转换，如把 Integer 类的对象重新简化为 int。</li></ul><p>Java 1.5 前必须手动拆箱装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="comment">// 手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(m);</span><br><span class="line">        <span class="comment">// 手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj.intValue();</span><br><span class="line">        <span class="comment">// n = 500</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// obj 等价于 obj1？true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 1.5 后系统自动拆箱装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> m;</span><br><span class="line">        <span class="comment">// 自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj;</span><br><span class="line">        <span class="comment">// n = 500</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="comment">// obj 等价于 obj1？true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;obj 等价于 obj1？&quot;</span> + obj.equals(obj1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承（extends）是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。</p><p>继承可以理解为一个类从另一个类获取方法和属性的过程。如果类 B 继承于类 A，那么 B 就拥有 A 的方法和属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是 &quot;</span> + name + <span class="string">&quot;，年龄是 &quot;</span> + age + <span class="string">&quot;，身高是 &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 教师属于人类，可以继承最基本的属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    String school;  <span class="comment">// 所在学校</span></span><br><span class="line">    String subject;  <span class="comment">// 学科</span></span><br><span class="line">    <span class="type">int</span> seniority;  <span class="comment">// 教龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖 People 类中的 say() 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，在&quot;</span> + school + <span class="string">&quot;教&quot;</span> + subject + <span class="string">&quot;，有&quot;</span> + seniority + <span class="string">&quot;年教龄&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lecturing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经&quot;</span> + age + <span class="string">&quot;岁了，依然站在讲台上讲课&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：构造方法不能被继承。一个类能得到构造方法，只有两个办法：编写构造方法，或者根本没有构造方法，类有一个默认的构造方法。</p></blockquote><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>功能：</p><ul><li>调用父类中声明为 private 的变量。</li><li>获取已经覆盖了的方法。</li><li>作为方法名表示父类构造方法。</li></ul><figure class="highlight java"><figcaption><span>super</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>().move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="string">&quot;动物是人类的好朋友&quot;</span>;</span><br><span class="line">    <span class="comment">// 必须要声明一个 getter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123; <span class="keyword">return</span> desc; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物可以动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="built_in">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗可以走可以跑&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过 getter 方法调用父类隐藏变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请记住：&quot;</span> + <span class="built_in">super</span>.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">动物可以动</span><br><span class="line">狗狗可以走可以跑</span><br><span class="line">请记住：动物是人类的好朋友</span><br></pre></td></tr></table></figure><p>move() 方法也可以定义在某些祖先类中，比如父类的父类，Java 具有追溯性，会一直向上找，直到找到该方法为止。</p><p>通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。</p><figure class="highlight java"><figcaption><span>不可见</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;花花&quot;</span>, <span class="number">3</span>).say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只可爱的小狗，我的名字叫&quot;</span> + name + <span class="string">&quot;，我&quot;</span> + age + <span class="string">&quot;岁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">我是一只可爱的小狗，我的名字叫花花，我<span class="number">3</span>岁了</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li><li>不能在构造方法以外的任何方法内调用构造方法。</li><li>在一个构造方法内只能调用一个构造方法。</li></ul><p>如果编写一个构造方法，既没有调用 super() 也没有调用 this()，编译器会自动插入一个调用到父类构造方法中，而且不带参数。</p><h2 id="继承中方法的覆盖和重载"><a href="#继承中方法的覆盖和重载" class="headerlink" title="继承中方法的覆盖和重载"></a>继承中方法的覆盖和重载</h2><figure class="highlight java"><figcaption><span>覆盖和重载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;花花&quot;</span>);</span><br><span class="line">        <span class="comment">// 子类的实例调用子类中的方法</span></span><br><span class="line">        myDog.say();</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myAnmial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;贝贝&quot;</span>);</span><br><span class="line">        <span class="comment">// 父类的实例调用父类中的方法</span></span><br><span class="line">        myAnmial.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只小动物，我的名字叫&quot;</span> + name + <span class="string">&quot;，我会发出叫声&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法不能被继承，只能通过super()调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖say() 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只小狗，我的名字叫&quot;</span> + name + <span class="string">&quot;，我会发出汪汪的叫声&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">我是一只小狗，我的名字叫花花，我会发出汪汪的叫声</span><br><span class="line">我是一只小动物，我的名字叫贝贝，我会发出叫声</span><br></pre></td></tr></table></figure><p>覆盖原则：</p><ul><li>覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。</li><li>覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。</li><li>覆盖方法不能比原方法抛出更多的异常。</li><li>被覆盖的方法不能是 final 类型，因为 final 修饰的方法是无法覆盖的。</li><li>被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li><li>被覆盖的方法不能为 static。（覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用）</li></ul><p>覆盖和重载的不同：</p><ul><li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。</li><li>方法覆盖要求返回类型必须一致，方法重载对此没有要求。</li><li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。</li><li>方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。</li><li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次。</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>父类的变量可以引用父类的实例，也可以引用子类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        obj.cry();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        obj.cry();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        obj.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 动物的叫声</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不知道怎么叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 猫的叫声</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 狗的叫声</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">不知道怎么叫</span><br><span class="line">喵喵~</span><br><span class="line">汪汪~</span><br></pre></td></tr></table></figure><p>obj 变量的类型为 Animal，它既可以指向 Animal 类的实例，也可以指向 Cat 和 Dog 类的实例。也就是说，父类的变量可以引用父类的实例，也可以引用子类的实例。注意反过来是错误的，因为所有的猫都是动物，但不是所有的动物都是猫。</p><p>obj 既可以是人类，也可以是猫、狗，它有不同的表现形式，这就被称为多态。多态是指一个事物有不同的表现形式或形态。</p><p>多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。</p><p>当使用多态方式调用方法时：</p><ul><li>首先检查父类中是否有该方法，如果没有，则编译错误；如果有，则检查子类是否覆盖了该方法。</li><li>如果子类覆盖了该方法，就调用子类的方法，否则调用父类方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 借助多态，主人可以给很多动物喂食</span></span><br><span class="line">        <span class="type">Master</span> <span class="variable">master</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Master</span>();</span><br><span class="line">        master.feed(<span class="keyword">new</span> <span class="title class_">Animal</span>(), <span class="keyword">new</span> <span class="title class_">Food</span>());</span><br><span class="line">        master.feed(<span class="keyword">new</span> <span class="title class_">Cat</span>(), <span class="keyword">new</span> <span class="title class_">Fish</span>());</span><br><span class="line">        master.feed(<span class="keyword">new</span> <span class="title class_">Dog</span>(), <span class="keyword">new</span> <span class="title class_">Bone</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个小动物，正在吃&quot;</span> + f.getFood());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只小猫咪，正在吃&quot;</span> + f.getFood());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只狗狗，正在吃&quot;</span> + f.getFood());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;事物&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;鱼&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bone</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;骨头&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal animal, Food food)</span> &#123;</span><br><span class="line">        animal.eat(food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">我是一个小动物，正在吃事物</span><br><span class="line">我是一只小猫咪，正在吃鱼</span><br><span class="line">我是一只狗狗，正在吃骨头</span><br></pre></td></tr></table></figure><p>Master 类的 feed 方法有两个参数，分别是 Animal 类型和 Food 类型，因为是父类，所以可以将子类的实例传递给它，这样 Master 类就不需要多个方法来给不同的动物喂食。</p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>判断对象类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 引用 People 类的实例</span></span><br><span class="line">        <span class="type">People</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一个对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> People) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是人类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Teacher) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一名教师&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> President) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是校长&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用 Teacher 类的实例</span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一个对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> People) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是人类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Teacher) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一名教师&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> President) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是校长&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">President</span> <span class="keyword">extends</span> <span class="title class_">Teacher</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">我是一个对象</span><br><span class="line">我是人类</span><br><span class="line"></span><br><span class="line">我是一个对象</span><br><span class="line">我是人类</span><br><span class="line">我是一名教师</span><br></pre></td></tr></table></figure><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>static 修饰符能够与变量、方法一起使用，表示静态。</p><p>静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以 static 修饰的成员又称作类变量和类方法。</p><p>静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。</p><p>static 的内存分配</p><ul><li>静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。</li><li>编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存（类变量）。</li><li>实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响。</li></ul><figure class="highlight java"><figcaption><span>共享和相互独立</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        a.i = <span class="number">10</span>;</span><br><span class="line">        a.j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Demo</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a.i=&quot;</span> + a.i + <span class="string">&quot;, a.j=&quot;</span> + a.j);</span><br><span class="line">        System.out.println(<span class="string">&quot;b.i=&quot;</span> + b.i + <span class="string">&quot;, b.j=&quot;</span> + b.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">a.i=<span class="number">10</span>, a.j=<span class="number">20</span></span><br><span class="line">b.i=<span class="number">10</span>, b.j=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>静态变量也可以通过对象来访问，但不提倡，编译器也会产生警告。</li><li>静态变量在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个 static 变量，它都会被初始化，并占用内存。</li></ul><p>以下情形可以使用静态方法：</p><ul><li>方法不需要访问对象状态，其所需参数都是通过显式参数提供，比如 Math.pow()。</li><li>方法只需要访问类的静态变量。</li></ul><p>总结：</p><ul><li>静态方法只能访问静态变量；</li><li>静态方法不能够直接调用非静态方法；</li><li>如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但不被推荐；</li><li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li><li>静态方法不能被非静态方法覆盖；</li><li>构造方法不允许声明为 static；</li><li>局部变量不能使用 static 修饰。</li></ul><p><strong>静态初始器&#x2F;静态块(Static Initializer)</strong></p><p>静态初始器是一个存在于类中、方法外面的静态块。静态初始器仅仅在类装载的时候执行一次，往往用来初始化静态变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行到了静态块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo.i=&quot;</span> + Demo.i);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Demo</span>().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行：</span><br><span class="line">运行到了静态块</span><br><span class="line">Demo.i=<span class="number">10</span></span><br><span class="line">i=<span class="number">10</span></span><br></pre></td></tr></table></figure><p>静态导入：对于使用频繁的静态变量和静态方法，可以将其静态导入，简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> packageName.className.methonName;  <span class="comment">// 导入某个特定的静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> packageName.className.*;  <span class="comment">// 导入类中的所有静态成员</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>System静态导入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        out.println(<span class="string">&quot;产生的一个随机数：&quot;</span> + random());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：是否可以在 static 环境中访问非 static 变量？<br>答：static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final 所修饰的数据具有“终态”的特征，表示“最终”。规定如下：</p><ul><li>修饰的类不能被继承。</li><li>修饰的方法不能被子类重写。</li><li>修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。</li><li>修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。</li><li>修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TOTAL_NUMBER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 非法，对 final 变量 TOTAL_NUMBER 进行了二次赋值</span></span><br><span class="line">        <span class="comment">// 因为 ++TOTAL_NUMBER 相当于 TOTAL_NUMBER = TOTAL_NUMBER + 1</span></span><br><span class="line">        id = ++TOTAL_NUMBER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Demo</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 一次性的赋值</span></span><br><span class="line">        j = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 非法，对 final 变量 j 进行二次赋值</span></span><br><span class="line">        j = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>一旦将一个类声明为 final，那么该类包含的方法也将被隐式地声明为 final，但是变量不是。</li><li>被 final 修饰的方法为静态绑定，不会产生多态（动态绑定），程序在运行时不需要再检索方法表，能够提高代码的执行效率。</li><li>被 static 或 private 修饰的方法会被隐式的声明为 final。</li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类（Inner Class）&#x2F;嵌套类（Nested Class）：在一个类（或方法、语句块）的内部定义另一个类。</p><p>内部类和外层封装它的类之间存在逻辑上的所属关系，一般只用在定义它的类或语句块之内，实现一些没有通用意义的功能逻辑，在外部引用它时必须给出完整的名称。</p><p>使用内部类的原因：</p><ul><li>内部类可以访问外部类中的数据，包括私有的数据。</li><li>内部类可以对同一个包中的其他类隐藏起来。</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷。</li><li>减少类的命名冲突。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStuff</span><span class="params">()</span> &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.doStuff();</span><br><span class="line">        System.out.println(outer.size);</span><br><span class="line">        System.out.println(inner.counter);</span><br><span class="line">        <span class="comment">// 编译错误，外部类不能访问内部类的变量</span></span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：必须先有外部类的对象才能生成内部类的对象，因为内部类需要访问外部类中的成员变量，成员变量必须实例化才有意义。</p><h1 id="静态内部类、匿名内部类、成员式内部类和局部内部类"><a href="#静态内部类、匿名内部类、成员式内部类和局部内部类" class="headerlink" title="静态内部类、匿名内部类、成员式内部类和局部内部类"></a>静态内部类、匿名内部类、成员式内部类和局部内部类</h1><p><a target="_blank" rel="noopener" href="http://www.weixueyuan.net/view/6007.html">http://www.weixueyuan.net/view/6007.html</a></p><h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。</p><p>从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。</p><p>这种只给出定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。</p><p>使用 abstract 修饰符来表示抽象方法和抽象类。</p><p>抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。</p><p>抽象类不能被实例化，抽象方法必须在子类中被实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		teacher.setName(<span class="string">&quot;王明&quot;</span>);</span><br><span class="line">        <span class="comment">// 我的名字叫王明，我正在讲课，请大家不要东张西望...</span></span><br><span class="line">		teacher.work();</span><br><span class="line"></span><br><span class="line">		<span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line">		driver.setName(<span class="string">&quot;小陈&quot;</span>);</span><br><span class="line">        <span class="comment">// 我的名字叫小陈，我正在开车，不能接听电话...</span></span><br><span class="line">		driver.work();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 共有的 setter 和 getter 方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="comment">// 必须实现该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我的名字叫&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;，我正在讲课，请大家不要东张西望...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;</span><br><span class="line">	<span class="comment">// 必须实现该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我的名字叫&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;，我正在开车，不能接听电话...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于抽象类的几点说明：</p><ul><li>抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。</li><li>不能有抽象构造方法或抽象静态方法。</li></ul><p>在下列情况下，一个类将成为抽象类：</p><ul><li>当一个类的一个或多个方法是抽象方法时；</li><li>当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法主体时；</li><li>当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法主体时。</li></ul><blockquote><p>注：这里说的是这些情况下一个类将成为抽象类，没有说抽象类一定会有这些情况。</p></blockquote><p>一个典型的错误：抽象类一定包含抽象方法。<br>但是反过来说：“包含抽象方法的类一定是抽象类”就是正确的。</p><p>事实上，抽象类可以是一个完全正常实现的类。</p><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>在抽象类中，可以包含一个或多个抽象方法；但在接口（interface）中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。</p><p>接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。</p><p>现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。</p><p>希捷、日立、三星等生产厂家会按照规范生产符合接口的硬盘，这些硬盘就可以实现通用化，如果正在用一块160G日立的串口硬盘，现在要升级了，可以购买一块320G的希捷串口硬盘，安装上去就可以继续使用了。</p><p>模拟 Serial ATA 委员会定义以下串口硬盘接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行硬盘接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SataHdd</span> &#123;</span><br><span class="line">    <span class="comment">// 连接线的数量</span></span><br><span class="line">    <span class="type">int</span> CONNECT_LINE=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String data)</span>;</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    String <span class="title function_">readData</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：接口中声明的成员变量默认都是 public static final，因而在常量声明时可以省略这些修饰符。</p></blockquote><p>接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个 public 的类或接口，如果有则源文件必须取和 public 的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。</p><p>但接口有其自身的一些特性，归纳如下：</p><ol><li>接口中只能定义抽象方法，试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SataHdd</span> &#123;</span><br><span class="line">	<span class="comment">// 连接线的数量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> connectLine;</span><br><span class="line">	<span class="comment">// 编译出错：connectLine 被看做静态常量，必须显式初始化即 connectLine = 4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写数据</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String data)</span>;</span><br><span class="line">	<span class="comment">// 编译出错：必须是 public 类型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 编译出错：接口中不能包含静态方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 编译出错：接口中只能包含抽象方法，即没有“&#123;具体实现代码&#125;”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>接口中没有构造方法，不能被实例化。</p></li><li><p>一个接口不实现另一个接口，但可以继承多个其他接口。</p></li></ol><p>接口的多继承特点弥补了类的单继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行硬盘接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SataHdd</span> <span class="keyword">extends</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="comment">// 连接线的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">CONNECT_LINE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String data)</span>;</span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    String <span class="title function_">readData</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h2><p>大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。</p><p>比如继承链：A -&gt; B -&gt; C -&gt; D -&gt; E。<br>A 是祖先类，如果需要为 C、D、E 类添加某些通用的功能，最简单的方法是让 C 类再继承另外一个类。</p><p>但问题来了，Java 是一种单继承的语言，不能再让 C 继承另外一个父类了，只能让继承链的最顶端 A 再继承一个父类。这样一来，对 C、D、E 类的修改，影响到了整个继承链，不具备可插入性的设计。</p><p>接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。</p><p>我们关心的不是哪一个具体的类，而是这个类是否实现了我们需要的接口。</p><p>接口提供了关联以及方法调用上的可插入性，软件系统的规模越大，生命周期越长，接口使得软件系统的灵活性和可扩展性，可插入性方面得到保证。</p><p>接口在面向对象的 Java 程序设计中占有举足轻重的地位。事实上在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。</p><h2 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h2><p>接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用 new 关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。</p><p>注：</p><ul><li>接口必须通过类来实现（implements）它的抽象方法，然后再实例化类。</li><li>如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。</li><li>不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。</li><li>一个类只能继承一个父类，但却可以实现多个接口。</li></ul><p>实现接口的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名 extends 父类 implements 多个接口（A, B...） &#123;</span><br><span class="line">	实现方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化希捷硬盘</span></span><br><span class="line">		<span class="type">SataHdd</span> <span class="variable">sh1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeagateHdd</span>();</span><br><span class="line">        <span class="comment">// 初始化三星硬盘</span></span><br><span class="line">		<span class="type">SataHdd</span> <span class="variable">sh2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SamsungHdd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串行硬盘接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SataHdd</span> &#123;</span><br><span class="line">	<span class="comment">// 连接线的数量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">CONNECT_LINE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 写数据</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String data)</span>;</span><br><span class="line">	<span class="comment">// 读数据</span></span><br><span class="line">	String <span class="title function_">readData</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维修硬盘接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">fixHdd</span> &#123;</span><br><span class="line">	<span class="comment">// 维修地址</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;北京市海淀区&quot;</span>;</span><br><span class="line">	<span class="comment">// 开始维修</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">doFix</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希捷硬盘</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeagateHdd</span> <span class="keyword">implements</span> <span class="title class_">SataHdd</span>, fixHdd &#123;</span><br><span class="line">	<span class="comment">// 希捷硬盘读取数据</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 希捷硬盘写入数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String data)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 维修希捷硬盘</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFix</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三星硬盘</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SamsungHdd</span> <span class="keyword">implements</span> <span class="title class_">SataHdd</span> &#123;</span><br><span class="line">	<span class="comment">// 三星硬盘读取数据</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 三星硬盘写入数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String data)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某劣质硬盘，不能写数据</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">XXHdd</span> <span class="keyword">implements</span> <span class="title class_">SataHdd</span> &#123;</span><br><span class="line">	<span class="comment">// 硬盘读取数据</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口作为类型使用"><a href="#接口作为类型使用" class="headerlink" title="接口作为类型使用"></a>接口作为类型使用</h2><p>接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类中所实现的接口中的方法，Java 运行时系统会动态地确定应该使用哪个类中的方法，实际上是调用相应的实现类的方法。</p><p>接口可以作为一个类型来使用，如作为方法的参数和返回类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="comment">// 变量a使用A接口类型</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(A a)</span> &#123;</span><br><span class="line">		<span class="comment">// 调用相应的实现类B的方法</span></span><br><span class="line">		a.doSth();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// now in B</span></span><br><span class="line">		test1(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">doSth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doSth</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;now in B&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p>类是对象的模板，抽象类和接口可以看做是具体的类的模板。</p><p>由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。</p><p>相同点：</p><ul><li>都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。</li><li>都不能被实例化。</li><li>都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。</li></ul><p>区别：</p><ul><li>抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="comment">// A 没有定义 method1 的实现</span></span><br><span class="line">	<span class="comment">// 也就是说 B、C 可以根据自己的特点实现该方法，体现了松散耦合的特性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// A 实现 method2 方法，避免 B、C 子类重复实现</span></span><br><span class="line">		<span class="comment">// A 为子类提供了公共的功能，或说 A 约束了子类的行为</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// B method1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// C method1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再换成接口看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="comment">// 接口 A 无法为实现类 B、C 提供公共的功能，也就是说 A 无法约束 B、C 的行为</span></span><br><span class="line">	<span class="comment">// B、C 可以自由地发挥自己的特点现实 method1 和 method2 方法，而接口 A 毫无掌控能力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// B method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// B method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// C method1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// C method2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以灵活的使用 C</span></span><br><span class="line"><span class="comment">// 并且 C 还有机会进行扩展，实现其他接口</span></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于 C 类，将没有机会继承其他父类了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// C method1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// C method2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守：行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</p><p>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>使用变量之前要定义，定义一个变量时必须要指明它的数据类型，什么样的数据类型赋给什么样的值。</p><p>假如我们现在要定义一个类来表示坐标，要求坐标的数据类型可以是整数、小数和字符串，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>、y = <span class="number">10</span></span><br><span class="line">x = <span class="number">12.88</span>、y = <span class="number">129.65</span></span><br><span class="line">x = <span class="string">&quot;东京180度&quot;</span>、y = <span class="string">&quot;北纬210度&quot;</span></span><br></pre></td></tr></table></figure><p>针对不同的数据类型，除了借助方法重载，还可以借助自动装箱和向上转型。我们知道，基本数据类型可以自动装箱，被转换成对应的包装类；Object 是所有类的祖先类，任何一个类的实例都可以向上转型为 Object 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> --&gt; Integer --&gt; Object</span><br><span class="line"><span class="type">double</span> --&gt; Double --&gt; Object</span><br><span class="line">String --&gt; Object</span><br></pre></td></tr></table></figure><p>这样，只需要定义一个方法，就可以接收所有类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">        <span class="comment">// int -&gt; Integer -&gt; Object</span></span><br><span class="line">		p.setX(<span class="number">10</span>);</span><br><span class="line">		p.setY(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 必须向下转型</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (Integer) p.getX();</span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (Integer) p.getY();</span><br><span class="line">		System.out.println(<span class="string">&quot;This point is：&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// double -&gt; Integer -&gt; Object</span></span><br><span class="line">		p.setX(<span class="number">25.4</span>);</span><br><span class="line">        <span class="comment">// String --&gt; Object</span></span><br><span class="line">		p.setY(<span class="string">&quot;东京180度&quot;</span>);</span><br><span class="line">        <span class="comment">// 必须向下转型</span></span><br><span class="line">		<span class="type">double</span> <span class="variable">m</span> <span class="operator">=</span> (Double) p.getX();</span><br><span class="line">        <span class="comment">// 运行期间抛出异常，因为 String 不能被转换成 Double</span></span><br><span class="line">		<span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> (Double) p.getY();</span><br><span class="line">		System.out.println(<span class="string">&quot;This point is：&quot;</span> + m + <span class="string">&quot;, &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(Object y)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，生成坐标时不会有任何问题，但是取出坐标时，要向下转型，在 Java 多态对象的类型转换中我们讲到，向下转型存在风险，而且编译期间不容易发现，只有在运行期间才会抛出异常，所以要尽量避免使用向下转型。运行上面的代码，第12行会抛出 java.lang.ClassCastException 异常。</p><p>如何既可以不使用重载（有重复代码），又能把风险降到最低呢？<br>使用泛型类(Java Class)，它可以接受任意类型的数据。所谓“泛型”，就是“宽泛的数据类型”，任意的数据类型。</p><p>更改上面的代码，使用泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 实例化泛型类</span></span><br><span class="line">		Point&lt;Integer, Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;&gt;();</span><br><span class="line">		p1.setX(<span class="number">10</span>);</span><br><span class="line">		p1.setY(<span class="number">20</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> p1.getX();</span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> p1.getY();</span><br><span class="line">		System.out.println(<span class="string">&quot;This point is：&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y);</span><br><span class="line"></span><br><span class="line">		Point&lt;Double, String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;&gt;();</span><br><span class="line">		p2.setX(<span class="number">25.4</span>);</span><br><span class="line">		p2.setY(<span class="string">&quot;东京180度&quot;</span>);</span><br><span class="line">		<span class="type">double</span> <span class="variable">m</span> <span class="operator">=</span> p2.getX();</span><br><span class="line">		<span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> p2.getY();</span><br><span class="line">		System.out.println(<span class="string">&quot;This point is：&quot;</span> + m + <span class="string">&quot;, &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">	T1 x;</span><br><span class="line">	T2 y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T1 <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(T1 x)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T2 <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(T2 y)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通类的定义相比，上面的代码在类名后面多出了 &lt;T1, T2&gt;，T1, T2 是自定义的标识符，也是参数，用来传递数据的类型，而不是数据的值，我们称之为类型参数。在泛型中，不但数据的值可以通过参数传递，数据的类型也可以通过参数传递。T1, T2 只是数据类型的占位符，运行时会被替换为真正的数据类型。</p><p>传值参数（我们通常所说的参数）由小括号包围，如 (int x, double y)，类型参数（泛型参数）由尖括号包围，多个参数由逗号分隔，如<t>或 &lt;T, E&gt;。</t></p><p>类型参数需要在类名后面给出。一旦给出了类型参数，就可以在类中使用了。<br>类型参数必须是一个合法的标识符，习惯上使用单个大写字母，通常情况下：K 表示键、V 表示值、E 表示异常或错误、T 表示一般意义上的数据类型。</p><p>泛型类在实例化时必须指出具体的类型，也就是向类型参数传值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className variable&lt;dataType1, dataType2&gt; = <span class="keyword">new</span> <span class="title class_">className</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>泛型是 Java 1.5 的新增特性，它以 C++ 模板为参照，本质是参数化类型（Parameterized Type）的应用。</li><li>类型参数只能用来表示引用类型，不能用来表示基本类型，如 int、double、char 等。但是传递基本类型不会报错，因为它们会自动装箱成对应的包装类。</li></ul><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>除了定义泛型类，还可以定义泛型方法，例如，定义一个打印坐标的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 实例化泛型类</span></span><br><span class="line">		Point&lt;Integer, Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;Integer, Integer&gt;();</span><br><span class="line">		p1.setX(<span class="number">10</span>);</span><br><span class="line">		p1.setY(<span class="number">20</span>);</span><br><span class="line">		p1.printPoint(p1.getX(), p1.getY());</span><br><span class="line"></span><br><span class="line">		Point&lt;Double, String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;Double, String&gt;();</span><br><span class="line">		p2.setX(<span class="number">25.4</span>);</span><br><span class="line">		p2.setY(<span class="string">&quot;东京180度&quot;</span>);</span><br><span class="line">		p2.printPoint(p2.getX(), p2.getY());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">	T1 x;</span><br><span class="line">	T2 y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T1 <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(T1 x)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T2 <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(T2 y)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义泛型方法</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T1, T2&gt; <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">(T1 x, T2 y)</span> &#123;</span><br><span class="line">		<span class="type">T1</span> <span class="variable">m</span> <span class="operator">=</span> x;</span><br><span class="line">		<span class="type">T2</span> <span class="variable">n</span> <span class="operator">=</span> y;</span><br><span class="line">		System.out.println(<span class="string">&quot;This point is：&quot;</span> + m + <span class="string">&quot;, &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了一个泛型方法 printPoint()，既有普通参数，也有类型参数，类型参数需要放在修饰符后面、返回值类型前面。一旦定义了类型参数，就可以在参数列表、方法体和返回值类型中使用了。</p><p>与使用泛型类不同，使用泛型方法时不必指明参数类型，编译器会根据传递的参数自动查找出具体的类型。泛型方法除了定义不同，调用就像普通方法一样。</p><p>注：<br>泛型方法与泛型类没有必然的联系，泛型方法有自己的类型参数，在普通类中也可以定义泛型方法。泛型方法 printPoint() 中的类型参数 T1, T2 与泛型类 Point 中的 T1, T2 没有必然的联系，也可以使用其他的标识符代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V1, V2&gt; <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">(V1 x, V2 y)</span> &#123;</span><br><span class="line">    <span class="type">V1</span> <span class="variable">m</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="type">V2</span> <span class="variable">n</span> <span class="operator">=</span> y;</span><br><span class="line">    System.out.println(<span class="string">&quot;This point is：&quot;</span> + m + <span class="string">&quot;, &quot;</span> + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>在 Java 中也可以定义泛型接口，这里不再赘述，仅仅给出示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arsg[])</span> &#123;</span><br><span class="line">		Info&lt;String&gt; obj = <span class="keyword">new</span> <span class="title class_">InfoImp</span>&lt;&gt;(<span class="string">&quot;www.xx.com&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Length Of String: &quot;</span> + obj.getVar().length());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoImp</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Info</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> T <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义泛型构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">InfoImp</span><span class="params">(T <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.setVar(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>如果在使用泛型时没有指明数据类型，那么就会擦除泛型类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 类型擦除</span></span><br><span class="line">		<span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">		p.setX(<span class="number">10</span>);</span><br><span class="line">		p.setY(<span class="number">20.8</span>);</span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (Integer) p.getX();</span><br><span class="line">		<span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (Double) p.getY();</span><br><span class="line">		System.out.println(<span class="string">&quot;This point is：&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">	T1 x;</span><br><span class="line">	T2 y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T1 <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(T1 x)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T2 <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(T2 y)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在使用泛型时没有指明数据类型，为了不出现错误，编译器会将所有数据向上转型为 Object，所以在取出坐标使用时要向下转型，这与本文一开始不使用泛型没什么两样。</p><h2 id="限制泛型的可用类型"><a href="#限制泛型的可用类型" class="headerlink" title="限制泛型的可用类型"></a>限制泛型的可用类型</h2><p>在上面的代码中，类型参数可以接受任意的数据类型，只要它是被定义过的。但是，很多时候我们只需要一部分数据类型就够了，用户传递其他数据类型可能会引起错误。</p><p>例如，编写一个泛型函数用于返回不同类型数组（Integer 数组、Double 数组、Character 数组等）中的最大值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMax</span><span class="params">(T array[])</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(T element : array) &#123;</span><br><span class="line">        max = element.doubleValue() &gt; max.doubleValue() ? element : max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会报错，doubleValue() 是 Number 类的方法，不是所有的类都有该方法，所以我们要限制类型参数 T，让它只能接受 Number 及其子类（Integer、Double、Character 等）。</p><p>通过 extends 关键字可以限制泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;T extends Number&gt; 表示 T 只接受 Number 及其子类，传入其他类型的数据会报错</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; T <span class="title function_">getMax</span><span class="params">(T array[])</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(T element : array) &#123;</span><br><span class="line">        max = element.doubleValue() &gt; max.doubleValue() ? element : max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>extends 后可以是类也可以是接口。如果是类，只能有一个；如果是接口，可以有多个，并以“&amp;”分隔，如 <code>&lt;T extends Interface1 &amp; Interface2&gt;</code>。</li><li>extends 不是继承的含义，应该理解为 T 是继承自 Number 类的类型，或者 T 是实现了 XX 接口的类型。</li></ul><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="? 泛型通配符"></a>? 泛型通配符</h2><p>在类型擦除中我们定义了泛型类 Point&lt;T1, T2&gt; 来表示坐标，坐标可以是整数、小数或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">    T1 x;</span><br><span class="line">    T2 y;</span><br><span class="line">    <span class="keyword">public</span> T1 <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(T1 x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T2 <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(T2 y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要求在其他类，比如 APoint 类定义一个 printPoint() 方法用于输出坐标，怎么办？可以这样定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;This point is: &quot;</span> + p.getX() + <span class="string">&quot;, &quot;</span> + p.getY());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果在使用泛型时没有指名具体的数据类型，就会擦除泛型类型，并向上转型为 Object，这与不使用泛型没什么两样。上面的代码没有指明数据类型，相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">(Point&lt;Object, Object&gt; p)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;This point is: &quot;</span> + p.getX() + <span class="string">&quot;, &quot;</span> + p.getY());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免类型擦除，可以使用通配符 <code>?</code>（可以表示任意的数据类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">(Point&lt;?, ?&gt; p)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;This point is: &quot;</span> + p.getX() + <span class="string">&quot;, &quot;</span> + p.getY());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Point&lt;Integer, Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;&gt;();</span><br><span class="line">		p1.setX(<span class="number">10</span>);</span><br><span class="line">		p1.setY(<span class="number">20</span>);</span><br><span class="line">		printPoint(p1);</span><br><span class="line"></span><br><span class="line">		Point&lt;String, String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;&gt;();</span><br><span class="line">		p2.setX(<span class="string">&quot;东京180度&quot;</span>);</span><br><span class="line">		p2.setY(<span class="string">&quot;北纬210度&quot;</span>);</span><br><span class="line">		printPoint(p2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用通配符</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printPoint</span><span class="params">(Point&lt;?, ?&gt; p)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;This point is: &quot;</span> + p.getX() + <span class="string">&quot;, &quot;</span> + p.getY());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">	T1 x;</span><br><span class="line">	T2 y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T1 <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(T1 x)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T2 <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(T2 y)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，数字坐标与字符串坐标又有区别：数字可以表示 x 轴或 y 轴的坐标，字符串可以表示地球经纬度。</p><p>现在又要求定义两个方法分别处理不同的坐标，一个方法只能接受数字类型的坐标，另一个方法只能接受字符串类型的坐标，怎么办？</p><p>这个问题的关键是要限制类型参数的范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Point&lt;Integer, Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;&gt;();</span><br><span class="line">		p1.setX(<span class="number">10</span>);</span><br><span class="line">		p1.setY(<span class="number">20</span>);</span><br><span class="line">		printNumPoint(p1);</span><br><span class="line"></span><br><span class="line">		Point&lt;String, String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;&gt;();</span><br><span class="line">		p2.setX(<span class="string">&quot;东京180度&quot;</span>);</span><br><span class="line">		p2.setY(<span class="string">&quot;北纬210度&quot;</span>);</span><br><span class="line">		printStrPoint(p2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 借助通配符限制泛型的范围</span></span><br><span class="line">    <span class="comment">// ? extends Number 表示泛型的类型参数只能是 Number 及其子类，&lt;? extends String&gt; 也一样，这与定义泛型类或泛型方法时限制类型参数的范围类似。</span></span><br><span class="line">    <span class="comment">// 不过，使用通配符 `?` 不但可以限制类型的上限，还可以限制下限。限制下限使用 super 关键字，例如 &lt;? super Number&gt; 表示只能接受 Number 及其父类。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumPoint</span><span class="params">(Point&lt;? extends Number, ? extends Number&gt; p)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;x: &quot;</span> + p.getX() + <span class="string">&quot;, y: &quot;</span> + p.getY());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printStrPoint</span><span class="params">(Point&lt;? extends String, ? extends String&gt; p)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;GPS: &quot;</span> + p.getX() + <span class="string">&quot;，&quot;</span> + p.getY());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">	T1 x;</span><br><span class="line">	T2 y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T1 <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(T1 x)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> T2 <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(T2 y)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Java 异常是一个描述在代码段中发生的异常（也就是出错）情况的对象。当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被抛出（throw）。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获（caught）并处理。异常可能是由 Java 运行时系统产生，或者是由你的手工代码产生。被 Java 抛出的异常与违反语言规范或超出 Java 执行环境限制的基本错误有关。手工编码产生的异常基本上用于报告方法调用程序的出错状况。</p><p>Java 异常处理通过5个关键字控制：try、catch、throw、throws、finally。</p><p>声明你想要的异常监控包含在一个 try 块中。如果在 try 块中发生异常，它被抛出。你的代码可以捕捉这个异常（catch）并且用某种合理的方法处理该异常。系统产生的异常被 Java 运行时系统自动抛出。手动抛出一个异常，用关键字 throw。任何被抛出方法的异常都必须通过 throws 子句定义。任何在方法返回前绝对被执行的代码被放置在 finally 块中。</p><p>下面是一个异常处理块的通常形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 监控可能发生异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType1 类型异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType2 类型异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (... e) &#123;</span><br><span class="line">    <span class="comment">// 处理 ... 类型异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 在 try 块结束前被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有异常类型都是内置类 Throwable 的子类。因此 Throwable 在异常类层次结构的顶层。紧接着 Throwable 下面的是两个把异常分成两个不同分支的子类：Exception、Error。</p><p>Exception：用于用户程序可能捕捉的异常情况。它也是你可以用来创建你自己用户异常类型子类的类。在 Exception 分支中有一个重要子类 RuntimeException 运行时异常。业务中可能出现的自定义异常可以通过继承该类实现。</p><p>Error：定义了在通常环境下不希望被程序捕获的异常。用于 Java 运行时系统来显示与运行时系统本身有关的错误，比如：堆栈溢出。这里不讨论关于 Error 类型的异常处理，因为它们通常是灾难性的致命错误，不是你的程序可以控制的。</p><p>异常处理这块不是特别难：<a target="_blank" rel="noopener" href="http://www.weixueyuan.net/java/rumen_7/">http://www.weixueyuan.net/java/rumen_7/</a></p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>操作系统课有讲大致原理，这里主要讲在 Java 原理和应用，最好看懂课本理解好多线程内容。</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>Java 给每个线程安排优先级以决定与其他线程比较时该如何对待该线程。</p><p>线程优先级是详细说明线程间优先关系的整数。作为绝对值，优先级是毫无意义的；当只有一个线程时，优先级高的线程并不比优先权低的线程运行的快。相反，线程的优先级是用来决定何时从一个运行的线程切换到另一个。这叫“上下文转换”(context switch)。决定上下文转换发生的规则（最高优先级优先算法）：</p><ul><li><p>线程可以自动放弃控制。在I&#x2F;O未决定的情况下，睡眠或阻塞由明确的让步来完成。在这种假定下，所有其他的线程被检测，准备运行的最高优先级线程被授予CPU。</p></li><li><p>线程可以被高优先级的线程抢占。在这种情况下，低优先级线程不主动放弃，处理器只是被先占——无论它正在干什么——处理器被高优先级的线程占据。基本上，一旦高优先级线程要运行，它就执行。这叫做有优先权的多任务处理。</p></li></ul><blockquote><p>注：不同的操作系统下相同优先级线程的上下文转换可能会产生错误。</p></blockquote><h2 id="同步性"><a href="#同步性" class="headerlink" title="同步性"></a>同步性</h2><p>因为多线程在你的程序中引入了一个异步行为，所以在你需要的时候必须有加强同步性的方法。</p><p>比如，你希望两个线程相互通信并共享一个复杂的数据结构，例如链表序列，你需要某些方法来确保它们没有相互冲突。也就是说，你必须防止一个线程写入数据而另一个线程正在读取链表中的数据。为此目的，Java 在进程间同步性的老模式基础上实行了另一种方法：管程（monitor）。管程是一种由 C.A.R.Hoare 首先定义的控制机制。</p><p>你可以把管程想象成一个仅控制一个线程的小盒子。一旦线程进入管程，所有线程必须等待直到该线程退出了管程。用这种方法，管程可以用来防止共享的资源被多个线程操纵。</p><p>很多多线程系统把管程作为程序必须明确的引用和操作的对象。Java 提供一个清晰的解决方案。没有“Monitor”类；相反，每个对象都拥有自己的隐式管程，当对象的同步方法被调用时管程自动载入。一旦一个线程包含在一个同步方法中，没有其他线程可以调用相同对象的同步方法。这就使你可以编写非常清晰和简洁的多线程代码，因为同步支持是语言内置的。</p><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>在你把程序分成若干线程后，你就要定义各线程之间的联系。用大多数其他语言规划时，你必须依赖于操作系统来确立线程间通信。这样当然增加花费。然而，Java 提供了多线程间谈话清洁的、低成本的途径——通过调用所有对象都有的预先确定的方法。Java 的消息传递系统允许一个线程进入一个对象的一个同步方法，然后在那里等待，直到其他线程明确通知它出来。</p><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>当 Java 程序启动时，一个线程立刻运行，该线程通常叫做程序的主线程（main thread），因为它是程序开始时就执行的。</p><p>主线程的重要性体现在两方面：</p><ol><li>它是产生其他子线程的线程；</li><li>通常它必须最后完成执行，因为它执行各种关闭动作。</li></ol><p>尽管主线程在程序启动时自动创建，但它可以由一个 Thread 对象控制。可以通过 currentThread() 获得它的一个引用。</p><p>currentThread() 是 Thread 类的公有的静态成员，该方法返回一个调用它的线程的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">( )</span></span><br></pre></td></tr></table></figure><p>一旦你获得主线程的引用，你就可以像控制其他线程那样控制主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentThreadDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前线程名称：&quot;</span> + t);</span><br><span class="line">		<span class="comment">// 更改线程的名称</span></span><br><span class="line">		t.setName(<span class="string">&quot;My Thread&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;改名后：&quot;</span> + t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程优先级-1"><a href="#线程优先级-1" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级被线程调度用来判定何时每个线程允许运行。理论上，优先级高的线程比优先级低的线程获得更多的 CPU 时间。实际上，线程获得的CPU时间通常由包括优先级在内的多个因素决定（例如，一个实行多任务处理的操作系统如何更有效的利用 CPU 时间）。</p><p>一个优先级高的线程自然比优先级低的线程优先。举例来说，当低优先级线程正在运行，而一个高优先级的线程被恢复（例如从沉睡中或等待 I&#x2F;O 中），它将抢占低优先级线程所使用的 CPU。</p><p>理论上，等优先级线程有同等的权利使用 CPU。但你必须小心了。记住，Java 是被设计成能在很多环境下工作的。一些环境下实现多任务处理从本质上与其他环境不同。为安全起见，等优先级线程偶尔也受控制。这保证了所有线程在无优先级的操作系统下都有机会运行。实际上，在无优先级的环境下，多数线程仍然有机会运行，因为很多线程不可避免的会遭遇阻塞，例如等待输入输出。遇到这种情形，阻塞的线程挂起，其他线程运行。</p><p>但是如果你希望多线程执行的顺利的话，最好不要采用这种方法。同样，有些类型的任务是占 CPU 的。对于这些支配 CPU 类型的线程，有时你希望能够支配它们，以便使其他线程可以运行。</p><p>设置线程的优先级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">level 指定了对所调用的线程的新的优先权的设置</span></span><br><span class="line"><span class="comment">level 的值必须在 MIN_PRIORITY 到 MAX_PRIORITY 范围内。通常，它们的值分别是 1 和 10</span></span><br><span class="line"><span class="comment">要返回一个线程为默认的优先级，指定 NORM_PRIORITY，通常值为 5</span></span><br><span class="line"><span class="comment">这些优先级在 Thread 中都被定义为 final 型变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> level)</span></span><br></pre></td></tr></table></figure><p>当涉及调度时，Java 的执行可以有本质上不同的行为。最安全的办法是获得可预先性的优先权，Java 获得跨平台的线程行为的方法是自动放弃对 CPU 的控制。</p><h1 id="多线程实现的几种方式及各自的特点"><a href="#多线程实现的几种方式及各自的特点" class="headerlink" title="多线程实现的几种方式及各自的特点"></a>多线程实现的几种方式及各自的特点</h1><p>主要有4种实现多线程方式：</p><ol><li>继承 Thread 类（无返回值）</li><li>实现 Runnable 接口（无返回值）</li><li>实现 Callable 接口（有返回值）</li><li>使用 ExecutorService、Callable、Future（有返回值）</li></ol><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>Thread 类实现了 Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以通过继承 Thread 实现多线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread.run()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread.run()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>Thread 的 run() 方法实际上调用的就是 target.run()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><p>Callable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Callable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 FutureTask 包装器来创建任务，启动线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;V&gt; oneCallable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">FutureTask&lt;V&gt; oneTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>(oneCallable);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">oneThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(oneTask);</span><br><span class="line">oneThread.start();</span><br></pre></td></tr></table></figure><h2 id="使用-ExecutorService、Callable、Future"><a href="#使用-ExecutorService、Callable、Future" class="headerlink" title="使用 ExecutorService、Callable、Future"></a>使用 ExecutorService、Callable、Future</h2><p>ExecutorService、Callable、Future 三个接口都属于 Executor 框架。</p><p>Executors 提供了一系列工厂方法用于创建线程池：</p><ul><li><p>newFixedThreadPool(int nThreads)：创建固定数目线程的线程池。</p></li><li><p>newCachedThreadPool()：创建一个可缓存的线程池，调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。</p></li><li><p>newSingleThreadExecutor()：创建一个单线程 Executor。</p></li><li><p>newScheduledThreadPool(int corePoolSize)：创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代 Timer。</p></li></ul><p>ExecutoreService 提供了 submit() 方法，传递一个 Callable 或 Runnable，即返回 Future 对象。</p><p>有返回值的任务必须实现 Callable 接口；<br>无返回值的任务必须实现 Runnable 接口。</p><p>执行 Callable 任务后，可以获得 Future 对象，在该对象上调用 get() 可以获得 Callable 任务返回的 Object。如果 Executor 后台线程池还没有完成 Callable 的计算，那么调用返回 Future 对象的 get() 方法时，会阻塞直到计算完成。</p><p>有返回结果的多线程例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始运行&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">taskSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(taskSize);</span><br><span class="line">        <span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">        List&lt;Future&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">            <span class="type">Callable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>(i);</span><br><span class="line">            <span class="comment">// 执行任务并获取 Future 对象</span></span><br><span class="line">            <span class="type">Future</span> <span class="variable">f</span> <span class="operator">=</span> pool.submit(c);</span><br><span class="line">            list.add(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line">        <span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">            <span class="comment">// 从 Future 对象上获取任务的返回值</span></span><br><span class="line">            System.out.println(f.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">totalTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束运行，总运行时间&quot;</span> + totalTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> taskNum;</span><br><span class="line"></span><br><span class="line">    MyCallable(<span class="type">int</span> taskNum) &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskNum = taskNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(taskNum + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(taskNum + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> taskNum + <span class="string">&quot;返回运行结果，运行时间&quot;</span> + totalTime + <span class="string">&quot;ms&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的状态及相互转换"><a href="#线程的状态及相互转换" class="headerlink" title="线程的状态及相互转换"></a>线程的状态及相互转换</h1><p>线程的生命周期分为5种状态：</p><ol><li><p>新建（New）：新创建一个线程对象。</p></li><li><p>可运行（Runnable）：线程对象创建后，其他线程（比如 main 线程）调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权。</p></li><li><p>运行（Running）：Running 的线程获得了 CPU 时间片（timeslice），执行程序代码。</p></li><li><p>阻塞（Blocked）：线程因为某种原因放弃了 CPU 使用权，也即让出了 CPU 时间片，暂时停止运行。直到线程进入可运行状态，才有机会再次获得 CPU 时间片转到运行状态。阻塞的情况分3种：</p></li></ol><ul><li>等待阻塞：Running 的线程执行 o.wait() 方法，JVM 会把该线程放入等待队列（Waitting Queue）。</li><li>同步阻塞：Running 的线程在获取对象的同步锁时，该同步锁被别的线程占用，JVM 会把该线程放入锁池（lock pool）。</li><li>其他阻塞：Running 的线程执行 Thread.sleep(long ms) 或 join() 方法 或 发出了 I&#x2F;O 请求，JVM 会把该线程置为阻塞状态。当 sleep() 状态超时 或 join() 等待线程终止或者超时 或 I&#x2F;O 处理完毕时，线程重新转入 Runnable 状态。</li></ul><ol start="5"><li>死亡（Dead）：线程 run() 或 main() 方法执行结束 或 因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol><p><img src="/transitions_between_thread_states.png" alt="线程状态之间的转换" loading="lazy"></p><h1 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h1><p><strong>临界区</strong></p><p>临界区对应着一个 CriticalSection 对象，当线程需要访问保护数据时，调用 EnterCriticalSection 函数；当对保护数据的操作完成之后，调用 LeaveCriticalSection 函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。</p><p>关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave）</p><p><strong>互斥量</strong></p><p>互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。</p><ol><li>由于也有线程所有权的概念，故互斥量也只能进行线程间的资源互斥访问，而不能用于线程同步；</li><li>由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了”遗弃”问题。</li></ol><p><strong>信号量</strong></p><p>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作。</p><p>事件可以完美解决线程间的同步问题，同时信号量也属于内核对象，可用于进程间的通信。</p><p><strong>事件</strong></p><p>事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。</p><p>事件是内核对象,可以解决线程间同步问题，因此也能解决互斥问题</p><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。即多个线程在操作同一份数据时，避免对同一共享变量的争夺，于是我们引出了等待唤醒机制：wait()、notify()。一个线程进行了规定操作后，就进入等待状态（wait）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify）。</p><ol><li><p>wait()：线程调用 wait() 方法，释放了它对锁的拥有权，然后等待其他的线程来通知它，通知的方式是 notify() 或 notifyAll()，这样它才能重新获得锁的拥有权和恢复执行。要确保调用 wait() 方法的时候拥有锁，即 wait() 方法的调用必须放在 synchronized 方法或 synchronized 块中。</p></li><li><p>notify()：唤醒一个等待当前对象的锁的线程。唤醒在此对象监视器上等待的单个线程。</p></li><li><p>notifyAll()：唤醒在此对象监视器上等待的所有线程。</p></li></ol><p>notify() 或 notifyAll() 方法应该是被拥有对象的锁的线程所调用。如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile：易变的、不稳定的。</p><p>作用：告诉编译器，只要是被该关键字修饰的变量都是易变的、不稳定的。</p><p>为什么是易变的呢？因为 volatile 所修饰的变量是直接存在主存中的，线程对变量的操作也是直接反映在主存中，所以说其是易变的。</p><p><img src="/relationship_between_memory_and_threads.png" alt="Java的内存模型（JMM）中内存与线程的关系" loading="lazy"></p><p>JMM 中的内存分为主内存和工作内存，其中主内存是所有线程共享的，而工作内存是每个线程独立分配的，各个线程的工作内存之间相互独立、互不可见。在线程启动的时候，虚拟机为每个内存分配了一块工作内存，不仅包含了线程内部定义的局部变量，也包含了线程所需要的共享变量的副本，当然这是为了提高执行效率，读副本的比直接读主内存更快。</p><p>那么对于 volatile 修饰的变量（共享变量）来说，在工作内存发生了变化后，必须要马上写到主内存中，而线程读取到是 volatile 修饰的变量时，必须去主内存中去获取最新的值，而不是读工作内存中主内存的副本，这就有效的保证了线程之间变量的可见性。</p><p>volatile 特点：</p><ol><li>内存可见性。即线程 A 对 volatile 变量的修改，其他线程获取的 volatile 变量都是最新的，但不能保证对变量的操作具有原子性。</li><li>禁止指令重排序。</li></ol><p>什么是指令重排序？<br>为了避免内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱，如果变量没有 volatile 修饰，程序执行的顺序可能会进行重排序。</p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHappenBefore</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里有两个共享变量 result 和 flag，初始值分别为 0 和 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 验证结果的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 多线程情况下的重排序现象需要多次试验才能出现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">ThreadA</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">            <span class="type">ThreadB</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果按调用线程的顺序</span></span><br><span class="line">            <span class="comment">// 在 ThreadA 中先给 result = 1，然后 flag = true</span></span><br><span class="line">            <span class="comment">// ThreadB 中的 if(flag) 被执行，result = 1，下方的 if( result == 0) 应该永远不会为真，永远不会打印</span></span><br><span class="line">            <span class="comment">// 但实际情况是，在试验100次的情况下会出现0次或几次的打印结果，而试验1000次结果更明显，有十几次打印</span></span><br><span class="line">            <span class="comment">// 以上这种现象就是由于指令重排序造成的</span></span><br><span class="line">            threadA.start();</span><br><span class="line">            threadB.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里等待线程结束后,重置共享变量,以使验证结果的工作变得简单些</span></span><br><span class="line">            threadA.join();</span><br><span class="line">            threadB.join();</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                result = result * <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;result == 0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T1、T2、T3-三个线程，怎样保证它们按顺序执行？"><a href="#T1、T2、T3-三个线程，怎样保证它们按顺序执行？" class="headerlink" title="T1、T2、T3 三个线程，怎样保证它们按顺序执行？"></a>T1、T2、T3 三个线程，怎样保证它们按顺序执行？</h1><p>比如下面这样的代码，虽然是按顺序 start() 的，但因为并行和指令重排等原因，结果并不是按顺序的，有可能出现 1 2 0 或者 0 2 1 等各种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Thread[] t = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> i.toString();</span><br><span class="line">        t[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        t[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何按顺序？在 start() 后面加上 join() 就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    t[i].start();</span><br><span class="line">    t[i].join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join() 可以让子线程执行完才回到 main 主线程中，让线程变成串行执行，而不是并行。</p><blockquote><p>join(ms) 只等待该线程 ms 毫秒</p></blockquote><h1 id="Lock-接口比-synchronized-块的优势？"><a href="#Lock-接口比-synchronized-块的优势？" class="headerlink" title="Lock 接口比 synchronized 块的优势？"></a>Lock 接口比 synchronized 块的优势？</h1><p>如果需要你实现一个高效的缓存，让其允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">        map.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="wait-和-sleep-方法的不同？"><a href="#wait-和-sleep-方法的不同？" class="headerlink" title="wait 和 sleep 方法的不同？"></a>wait 和 sleep 方法的不同？</h1><p>在等待时 wait 会释放锁，通常被用于线程间交互，线程会让出系统资源，进入等待池等待，其他线程可以占用 cpu。</p><p>在等待时 sleep 一直持有锁，通常被用于暂停执行，其他线程不能占用 cpu，因为 os 认为该线程正在工作，不会让出系统资源。</p><h1 id="实现阻塞队列"><a href="#实现阻塞队列" class="headerlink" title="实现阻塞队列"></a>实现阻塞队列</h1><h2 id="几种主要的阻塞队列"><a href="#几种主要的阻塞队列" class="headerlink" title="几种主要的阻塞队列"></a>几种主要的阻塞队列</h2><p>自 Java 1.5 后，在 java.util.concurrent 包下提供了若干个阻塞队列，主要有以下几个：</p><ul><li><p>ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建 ArrayBlockingQueue 对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。</p></li><li><p>LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建 LinkedBlockingQueue 对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。</p></li><li><p>PriorityBlockingQueue：以上2种队列都是先进先出队列，而 PriorityBlockingQueue 却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。</p></li><li><p>DelayQueue：基于 PriorityQueue，一种延时阻塞队列，DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p></li></ul><h2 id="阻塞队列中的方法-VS-非阻塞队列中的方法"><a href="#阻塞队列中的方法-VS-非阻塞队列中的方法" class="headerlink" title="阻塞队列中的方法 VS 非阻塞队列中的方法"></a>阻塞队列中的方法 VS 非阻塞队列中的方法</h2><p><strong>非阻塞队列中的几个主要方法</strong></p><p>add(E e)：将元素e插入到队列末尾，如果插入成功，则返回 true；如果插入失败（即队列已满），则会抛出异常。</p><p>remove()：移除队首元素，若移除成功，则返回 true；如果移除失败（队列为空），则会抛出异常。</p><p>offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回 true；如果插入失败（即队列已满），则返回 false。</p><p>poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回 null。</p><p>peek()：获取队首元素，若成功，则返回队首元素；否则返回 null。</p><p>对于非阻塞队列，一般情况下建议使用 offer、poll、peek，不建议使用 add、remove。因为使用 offer、poll、peek 可以通过返回值判断操作成功与否，而使用 add、remove 却不能达到这样的效果。</p><blockquote><p>注：非阻塞队列中的方法都没有进行同步措施。</p></blockquote><p><strong>阻塞队列中的几个主要方法</strong></p><p>阻塞队列包括了非阻塞队列中的大部分方法（包括上面列举的5个方法），但要注意这5个方法在阻塞队列中都进行了同步措施。除此之外，阻塞队列提供了另外4个非常有用的方法：</p><p>put(E e)：向队尾存入元素，如果队列满，则等待。</p><p>take()：从队首取元素，如果队列为空，则等待。</p><p>offer(E e,long timeout, TimeUnit unit)：向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回 false；否则返回 true。</p><p>poll(long timeout, TimeUnit unit)：从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回 null；否则返回取得的元素；</p><h2 id="解决生产者——消费者问题"><a href="#解决生产者——消费者问题" class="headerlink" title="解决生产者——消费者问题"></a>解决生产者——消费者问题</h2><p>与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。</p><ol start="6"><li>用Java编程一个会导致死锁的程序，你将怎么解决？</li></ol><p>这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。</p><ol start="7"><li>什么是原子操作，Java中的原子操作是什么？</li></ol><p>非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。</p><ol start="8"><li>Java中的Volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？</li></ol><p>自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性、顺序性和一致性。</p><ol start="9"><li>什么是竞争条件？你怎样发现和解决竞争？</li></ol><p>这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。</p><ol start="10"><li>你将如何使用thread dump？你将如何分析Thread dump？</li></ol><p>在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。</p><ol start="11"><li>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</li></ol><p>这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。</p><ol start="12"><li>Java中你怎样唤醒一个阻塞的线程？</li></ol><p>这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。</p><ol start="13"><li>在Java中CycliBarriar和CountdownLatch有什么区别？</li></ol><p>这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。</p><ol start="14"><li>什么是不可变对象，它对写并发应用有什么帮助？</li></ol><p>另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。</p><ol start="15"><li>你在多线程环境中遇到的共同的问题是什么？你是怎么解决它的？</li></ol><p>多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。</p><h2 id="同步工具类-CyclicBarrier"><a href="#同步工具类-CyclicBarrier" class="headerlink" title="同步工具类 CyclicBarrier"></a>同步工具类 CyclicBarrier</h2><p>CyclicBarrier 是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与 CountDownLatch 不同的是该 barrier 在释放等待线程后可以重用，所以称它为循环（Cyclic）的屏障（Barrier）。</p><p>CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。</p><h3 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parties表示屏障拦截的线程数量，当屏障撤销时，先执行barrierAction，然后在释放所有线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// barrierAction默认为null</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当前线程等待直到所有线程都调用了该屏障的await()方法</span></span><br><span class="line"><span class="comment">* 如果当前线程不是将到达的最后一个线程，将会被阻塞。解除阻塞的情况有以下几种</span></span><br><span class="line"><span class="comment">*    1）最后一个线程调用await()</span></span><br><span class="line"><span class="comment">*    2）当前线程被中断</span></span><br><span class="line"><span class="comment">*    3）其他正在该CyclicBarrier上等待的线程被中断</span></span><br><span class="line"><span class="comment">*    4）其他正在该CyclicBarrier上等待的线程超时</span></span><br><span class="line"><span class="comment">*    5）其他某个线程调用该CyclicBarrier的reset()方法</span></span><br><span class="line"><span class="comment">* 如果当前线程在进入此方法时已经设置了该线程的中断状态或者在等待时被中断，将抛出InterruptedException，并且清除当前线程的已中断状态。</span></span><br><span class="line"><span class="comment">* 如果在线程处于等待状态时barrier被reset()或者在调用await()时 barrier 被损坏，将抛出 BrokenBarrierException 异常。</span></span><br><span class="line"><span class="comment">* 如果任何线程在等待时被中断，则其他所有等待线程都将抛出 BrokenBarrierException 异常，并将 barrier 置于损坏状态。 *如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作（barrierAction），那么在允许其他线程继续运行之前，当前线程将运行该操作。如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，并将 barrier 置于损坏状态。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 返回值为当前线程的索引，0表示当前线程是最后一个到达的线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在await()的基础上增加超时机制，如果超出指定的等待时间，则抛出 TimeoutException 异常。如果该时间小于等于零，则此方法根本不会等待。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将屏障重置为其初始状态。如果所有参与者目前都在屏障处等待，则它们将返回，同时抛出一个BrokenBarrierException。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>对于失败的同步尝试，CyclicBarrier 使用了一种要么全部，要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 InterruptedException）以反常的方式离开。</p><h3 id="使用示例1"><a href="#使用示例1" class="headerlink" title="使用示例1"></a>使用示例1</h3><p>新建5个线程，这5个线程达到一定的条件时，它们才继续往后运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        barrier = <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InnerThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wait for CyclicBarrier.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 barrier 的参与者数量加1</span></span><br><span class="line">                barrier.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// barrier 的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continued.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 wait for CyclicBarrier.</span><br><span class="line">Thread-2 wait for CyclicBarrier.</span><br><span class="line">Thread-3 wait for CyclicBarrier.</span><br><span class="line">Thread-4 wait for CyclicBarrier.</span><br><span class="line">Thread-0 wait for CyclicBarrier.</span><br><span class="line">Thread-0 continued.</span><br><span class="line">Thread-4 continued.</span><br><span class="line">Thread-2 continued.</span><br><span class="line">Thread-3 continued.</span><br><span class="line">Thread-1 continued.</span><br></pre></td></tr></table></figure><h3 id="使用示例2"><a href="#使用示例2" class="headerlink" title="使用示例2"></a>使用示例2</h3><p>新建5个线程，当这5个线程达到一定的条件时，执行某项任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        barrier = <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(SIZE, () -&gt; System.out.println(<span class="string">&quot;CyclicBarrier&#x27;s parties is: &quot;</span> + barrier.getParties()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InnerThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wait for CyclicBarrier.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 barrier 的参与者数量加1</span></span><br><span class="line">                barrier.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// barrier的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; continued.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>基于 ReentrantLock 和 Condition 机制实现。除了 getParties() 方法，CyclicBarrier 的其他方法都需要获取锁。</p><p>属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 拦截的线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;    <span class="comment">//</span></span><br><span class="line"><span class="comment">// 当屏障撤销时，需要执行的屏障操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">// 当前的 Generation，每当屏障失效或者开闸之后都会自动替换掉，从而实现重置的功能。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment">* on each generation.  It is reset to parties on each new generation or when broken.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;    <span class="comment">//还能阻塞的线程数（即parties-当前阻塞的线程数），当新建generation或generation被破坏时，count会被重置。因为对Count的操作都是在获取锁之后，所以不需要其他同步措施。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内联类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="comment">// 当前的屏障是否破坏</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存此时的generation</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">        <span class="comment">// 判断屏障是否被破坏</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">        <span class="comment">// 判断线程是否被中断</span></span><br><span class="line">        <span class="comment">// 如果被中断，调用breakBarrier()进行屏障破坏处理，并抛出InterruptedException</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩余count递减，并赋值给线程索引，作为方法的返回值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程索引降为0，说明当前线程是最后一个到达的线程</span></span><br><span class="line">        <span class="comment">// 执行可能存在的屏障操作 barrierCommand，设置下一个Generation。相当于每次开闸之后都进行了一次reset。</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 同步执行barrierCommand</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 执行成功设置下一个nextGeneration</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果barrierCommand执行失败，进行屏障破坏处理</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程不是最后一个到达的线程</span></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">// 调用Condition的await()方法阻塞</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">// 调用Condition的awaitNanos()方法阻塞</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果当前线程被中断，则判断是否有其他线程已经使屏障破坏</span></span><br><span class="line">                <span class="comment">// 若没有则进行屏障破坏处理，并抛出异常；否则再次中断当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; !g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">// 这种捕获了InterruptException之后调用Thread.currentThread().interrupt()是一种通用的方式。其实就是为了保存中断状态，从而让其他更高层次的代码注意到这个中断。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果屏障被破坏，当前线程抛BrokenBarrierException</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果已经换代，直接返回index（last thread已经执行的nextGeneration，但当前线程还没有执行到该语句）</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时，进行屏障破坏处理，并抛TimeoutException</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前屏障置为破坏状态、重置count、并唤醒所有被阻塞的线程。</span></span><br><span class="line"><span class="comment">// 必须先获取锁，才能调用此方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒trip上等待的所有线程，设置下一个Generation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reset()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置屏障，先进行屏障破坏处理，再设置下一代generation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier与CountDownLatch比较"><a href="#CyclicBarrier与CountDownLatch比较" class="headerlink" title="CyclicBarrier与CountDownLatch比较"></a>CyclicBarrier与CountDownLatch比较</h2><ol><li><p>CountDownLatch：一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行；CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p></li><li><p>CountDownLatch：一次性的；CyclicBarrier：可以重复使用。</p></li><li><p>CountDownLatch 基于AQS；CyclicBarrier 基于锁和 Condition。本质上都是依赖于 volatile 和 CAS 实现的。</p></li></ol><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>暂时先用简单例子帮助理解。</p><p>现在有两个业务类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doService1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务方法1，加法&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;a x b = %d&quot;</span>, a x b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doService2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务方法2，乘法&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;a x b = %d&quot;</span>, a x b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何从第1个业务方法切换到第2个业务方法呢？</p><p>不使用反射，只能修改代码，重新编译运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 不用业务1了，注释掉1，然后重新编译运行</span></span><br><span class="line">        <span class="comment">//new Service1().doService1(a, b);</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service2</span>().doService2(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用反射，首先准备一个配置文件 A.properties，放在 src 目录下：</p><figure class="highlight txt"><figcaption><span>A.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class=reflection.Service1</span><br><span class="line">method=doService1</span><br></pre></td></tr></table></figure><p>在测试类 Test 中，首先取出类名称和方法名，然后通过反射去调用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 从 A.properties 中获取类名称和方法名称</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">springConfigFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/A.properties&quot;</span>);</span><br><span class="line">        Properties springConfig= <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        springConfig.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(springConfigFile));</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> (String) springConfig.get(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> (String) springConfig.get(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据类名称获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">// 根据方法名称，获取方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(methodName, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 获取构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line">        <span class="comment">// 根据构造器，实例化出对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">service</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 调用对象的指定方法</span></span><br><span class="line">        method.invoke(service, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要从调用第1个业务方法，切换到调用第2个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件 A.properties，重新运行即可。</p><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul><li>按流的流向分：输入流、输出流</li><li>按操作单元划分：字节流、字符流</li><li>按流的角色划分：节点流、处理流</li></ul><p>IO流的40多个类都是从如下4个抽象类基类中派生出来的：</p><p>输入流的基类：</p><ul><li>Reader：字符输入流</li><li>InputStream：字节输入流</li></ul><p>输出流的基类：</p><ul><li>Writer：字符输出流</li><li>OutputStream：字节输出流</li></ul><p><img src="/2017/12/26/zh/programing/java/basis/sort_by_operation_method.jpg" alt="按操作方式分类" loading="lazy"></p><p><img src="/2017/12/26/zh/programing/java/basis/sort_by_operation_object.jpg" alt="按操作对象分类" loading="lazy"></p><h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。</p><p>字节流和字符流的区别：</p><ul><li><p>读写单位不同：字节流以字节（8bit）为单位;字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p></li><li><p>处理对象不同：字节流能处理所有类型的数据（如图片、视频等）;字符流只能处理字符类型的数据。</p></li><li><p>字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。</p></li></ul><p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p><h1 id="J-U-C包的JDK源码（CAS、AQS、ConcurrentHashMap、ThreadLocal、CyclicBarrier、CountDownLatch、Atom、阻塞队列等等）"><a href="#J-U-C包的JDK源码（CAS、AQS、ConcurrentHashMap、ThreadLocal、CyclicBarrier、CountDownLatch、Atom、阻塞队列等等）" class="headerlink" title="J.U.C包的JDK源码（CAS、AQS、ConcurrentHashMap、ThreadLocal、CyclicBarrier、CountDownLatch、Atom、阻塞队列等等）"></a>J.U.C包的JDK源码（CAS、AQS、ConcurrentHashMap、ThreadLocal、CyclicBarrier、CountDownLatch、Atom、阻塞队列等等）</h1><h1 id="IO（writer、reader、InputStream、OutputStream）、NIO等"><a href="#IO（writer、reader、InputStream、OutputStream）、NIO等" class="headerlink" title="IO（writer、reader、InputStream、OutputStream）、NIO等"></a>IO（writer、reader、InputStream、OutputStream）、NIO等</h1><h1 id="对象序列化与反序列化"><a href="#对象序列化与反序列化" class="headerlink" title="对象序列化与反序列化"></a>对象序列化与反序列化</h1><p>序列化：把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程。</p><p>反序列化：把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p>为什么要做序列化？</p><ol><li>在分布式系统中，此时需要把对象在网络上传输，就得把对象数据转换为二进制形式，需要共享的数据的 Java 对象，都得做序列化。</li><li>服务器钝化：如果服务器发现某些对象好久没活动了，那么服务器就会把这些内存中的对象持久化在本地磁盘文件中（Java 对象转换为二进制文件）；如果服务器发现某些对象需要活动时，先去内存中寻找，找不到再去磁盘文件中反序列化我们的对象数据，恢复成 Java 对象。这样能节省服务器内存。</li></ol><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h1 id="全局唯一有序-ID"><a href="#全局唯一有序-ID" class="headerlink" title="全局唯一有序 ID"></a>全局唯一有序 ID</h1><p>snowflake ，timestamp 加前面，然后后面加上机器 id 等</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>因为HashMap在JDK1.8中数据结构加入了红黑树)</p><h1 id="AOP、实现动态代理的方式"><a href="#AOP、实现动态代理的方式" class="headerlink" title="AOP、实现动态代理的方式"></a>AOP、实现动态代理的方式</h1><h1 id="Dom4J以及SAX的区别，什么时候用，怎么用"><a href="#Dom4J以及SAX的区别，什么时候用，怎么用" class="headerlink" title="Dom4J以及SAX的区别，什么时候用，怎么用"></a>Dom4J以及SAX的区别，什么时候用，怎么用</h1><h1 id="Maven，为什么要用"><a href="#Maven，为什么要用" class="headerlink" title="Maven，为什么要用"></a>Maven，为什么要用</h1><h1 id="NIO，怎么使用"><a href="#NIO，怎么使用" class="headerlink" title="NIO，怎么使用"></a>NIO，怎么使用</h1><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>GC 机制对 JVM 中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息的保证 JVM 中的内存空间，防止内存泄露和溢出问题的出现。</p></div><div class="article-licensing box"><div class="licensing-title"><p>Java 基础概念</p><p><a href="https://zoctan.github.io/2017/12/26/zh/programing/java/basis/">https://zoctan.github.io/2017/12/26/zh/programing/java/basis/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Zoctan</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2017-12-26</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-21</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-634fc88092b0a58a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/pay_ali.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/pay_wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/01/01/zh/programing/basis/algorithm/sword_to_offer/"><i class="level-item fas fa-chevron-left"></i><span class="level-item"></span></a></div></nav></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#J2SE、J2EE、J2ME"><span class="level-left"><span class="level-item">1</span><span class="level-item">J2SE、J2EE、J2ME</span></span></a></li><li><a class="level is-mobile" href="#JRE、JDK"><span class="level-left"><span class="level-item">2</span><span class="level-item">JRE、JDK</span></span></a></li><li><a class="level is-mobile" href="#语法基础"><span class="level-left"><span class="level-item">3</span><span class="level-item">语法基础</span></span></a></li><li><a class="level is-mobile" href="#StringBuffer"><span class="level-left"><span class="level-item">4</span><span class="level-item">StringBuffer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#主要方法"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">主要方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#StringBuilder"><span class="level-left"><span class="level-item">5</span><span class="level-item">StringBuilder</span></span></a></li><li><a class="level is-mobile" href="#面向对象编程（OOP）"><span class="level-left"><span class="level-item">6</span><span class="level-item">面向对象编程（OOP）</span></span></a></li><li><a class="level is-mobile" href="#访问修饰符-x2F-访问控制符"><span class="level-left"><span class="level-item">7</span><span class="level-item">访问修饰符/访问控制符</span></span></a></li><li><a class="level is-mobile" href="#变量的作用域"><span class="level-left"><span class="level-item">8</span><span class="level-item">变量的作用域</span></span></a></li><li><a class="level is-mobile" href="#方法重载"><span class="level-left"><span class="level-item">9</span><span class="level-item">方法重载</span></span></a></li><li><a class="level is-mobile" href="#程序的基本运行顺序"><span class="level-left"><span class="level-item">10</span><span class="level-item">程序的基本运行顺序</span></span></a></li><li><a class="level is-mobile" href="#包装类、拆箱和装箱"><span class="level-left"><span class="level-item">11</span><span class="level-item">包装类、拆箱和装箱</span></span></a></li><li><a class="level is-mobile" href="#继承"><span class="level-left"><span class="level-item">12</span><span class="level-item">继承</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#super"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">super</span></span></a></li><li><a class="level is-mobile" href="#继承中方法的覆盖和重载"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">继承中方法的覆盖和重载</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多态"><span class="level-left"><span class="level-item">13</span><span class="level-item">多态</span></span></a></li><li><a class="level is-mobile" href="#instanceof"><span class="level-left"><span class="level-item">14</span><span class="level-item">instanceof</span></span></a></li><li><a class="level is-mobile" href="#static"><span class="level-left"><span class="level-item">15</span><span class="level-item">static</span></span></a></li><li><a class="level is-mobile" href="#final"><span class="level-left"><span class="level-item">16</span><span class="level-item">final</span></span></a></li><li><a class="level is-mobile" href="#内部类"><span class="level-left"><span class="level-item">17</span><span class="level-item">内部类</span></span></a></li><li><a class="level is-mobile" href="#静态内部类、匿名内部类、成员式内部类和局部内部类"><span class="level-left"><span class="level-item">18</span><span class="level-item">静态内部类、匿名内部类、成员式内部类和局部内部类</span></span></a></li><li><a class="level is-mobile" href="#abstract"><span class="level-left"><span class="level-item">19</span><span class="level-item">abstract</span></span></a></li><li><a class="level is-mobile" href="#interface"><span class="level-left"><span class="level-item">20</span><span class="level-item">interface</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么使用接口"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">为什么使用接口</span></span></a></li><li><a class="level is-mobile" href="#接口的使用"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">接口的使用</span></span></a></li><li><a class="level is-mobile" href="#接口作为类型使用"><span class="level-left"><span class="level-item">20.3</span><span class="level-item">接口作为类型使用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#接口和抽象类的区别"><span class="level-left"><span class="level-item">21</span><span class="level-item">接口和抽象类的区别</span></span></a></li><li><a class="level is-mobile" href="#泛型"><span class="level-left"><span class="level-item">22</span><span class="level-item">泛型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#泛型方法"><span class="level-left"><span class="level-item">22.1</span><span class="level-item">泛型方法</span></span></a></li><li><a class="level is-mobile" href="#泛型接口"><span class="level-left"><span class="level-item">22.2</span><span class="level-item">泛型接口</span></span></a></li><li><a class="level is-mobile" href="#类型擦除"><span class="level-left"><span class="level-item">22.3</span><span class="level-item">类型擦除</span></span></a></li><li><a class="level is-mobile" href="#限制泛型的可用类型"><span class="level-left"><span class="level-item">22.4</span><span class="level-item">限制泛型的可用类型</span></span></a></li><li><a class="level is-mobile" href="#泛型通配符"><span class="level-left"><span class="level-item">22.5</span><span class="level-item">? 泛型通配符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#异常处理"><span class="level-left"><span class="level-item">23</span><span class="level-item">异常处理</span></span></a></li><li><a class="level is-mobile" href="#多线程"><span class="level-left"><span class="level-item">24</span><span class="level-item">多线程</span></span></a></li><li><a class="level is-mobile" href="#线程模型"><span class="level-left"><span class="level-item">25</span><span class="level-item">线程模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#线程优先级"><span class="level-left"><span class="level-item">25.1</span><span class="level-item">线程优先级</span></span></a></li><li><a class="level is-mobile" href="#同步性"><span class="level-left"><span class="level-item">25.2</span><span class="level-item">同步性</span></span></a></li><li><a class="level is-mobile" href="#消息传递"><span class="level-left"><span class="level-item">25.3</span><span class="level-item">消息传递</span></span></a></li><li><a class="level is-mobile" href="#主线程"><span class="level-left"><span class="level-item">25.4</span><span class="level-item">主线程</span></span></a></li><li><a class="level is-mobile" href="#线程优先级-1"><span class="level-left"><span class="level-item">25.5</span><span class="level-item">线程优先级</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多线程实现的几种方式及各自的特点"><span class="level-left"><span class="level-item">26</span><span class="level-item">多线程实现的几种方式及各自的特点</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#继承-Thread-类"><span class="level-left"><span class="level-item">26.1</span><span class="level-item">继承 Thread 类</span></span></a></li><li><a class="level is-mobile" href="#实现-Runnable-接口"><span class="level-left"><span class="level-item">26.2</span><span class="level-item">实现 Runnable 接口</span></span></a></li><li><a class="level is-mobile" href="#实现-Callable-接口"><span class="level-left"><span class="level-item">26.3</span><span class="level-item">实现 Callable 接口</span></span></a></li><li><a class="level is-mobile" href="#使用-ExecutorService、Callable、Future"><span class="level-left"><span class="level-item">26.4</span><span class="level-item">使用 ExecutorService、Callable、Future</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程的状态及相互转换"><span class="level-left"><span class="level-item">27</span><span class="level-item">线程的状态及相互转换</span></span></a></li><li><a class="level is-mobile" href="#线程同步方式"><span class="level-left"><span class="level-item">28</span><span class="level-item">线程同步方式</span></span></a></li><li><a class="level is-mobile" href="#线程间通信"><span class="level-left"><span class="level-item">29</span><span class="level-item">线程间通信</span></span></a></li><li><a class="level is-mobile" href="#volatile"><span class="level-left"><span class="level-item">30</span><span class="level-item">volatile</span></span></a></li><li><a class="level is-mobile" href="#T1、T2、T3-三个线程，怎样保证它们按顺序执行？"><span class="level-left"><span class="level-item">31</span><span class="level-item">T1、T2、T3 三个线程，怎样保证它们按顺序执行？</span></span></a></li><li><a class="level is-mobile" href="#Lock-接口比-synchronized-块的优势？"><span class="level-left"><span class="level-item">32</span><span class="level-item">Lock 接口比 synchronized 块的优势？</span></span></a></li><li><a class="level is-mobile" href="#wait-和-sleep-方法的不同？"><span class="level-left"><span class="level-item">33</span><span class="level-item">wait 和 sleep 方法的不同？</span></span></a></li><li><a class="level is-mobile" href="#实现阻塞队列"><span class="level-left"><span class="level-item">34</span><span class="level-item">实现阻塞队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#几种主要的阻塞队列"><span class="level-left"><span class="level-item">34.1</span><span class="level-item">几种主要的阻塞队列</span></span></a></li><li><a class="level is-mobile" href="#阻塞队列中的方法-VS-非阻塞队列中的方法"><span class="level-left"><span class="level-item">34.2</span><span class="level-item">阻塞队列中的方法 VS 非阻塞队列中的方法</span></span></a></li><li><a class="level is-mobile" href="#解决生产者——消费者问题"><span class="level-left"><span class="level-item">34.3</span><span class="level-item">解决生产者——消费者问题</span></span></a></li><li><a class="level is-mobile" href="#同步工具类-CyclicBarrier"><span class="level-left"><span class="level-item">34.4</span><span class="level-item">同步工具类 CyclicBarrier</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#提供的方法"><span class="level-left"><span class="level-item">34.4.1</span><span class="level-item">提供的方法</span></span></a></li><li><a class="level is-mobile" href="#使用示例1"><span class="level-left"><span class="level-item">34.4.2</span><span class="level-item">使用示例1</span></span></a></li><li><a class="level is-mobile" href="#使用示例2"><span class="level-left"><span class="level-item">34.4.3</span><span class="level-item">使用示例2</span></span></a></li><li><a class="level is-mobile" href="#实现原理"><span class="level-left"><span class="level-item">34.4.4</span><span class="level-item">实现原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CyclicBarrier与CountDownLatch比较"><span class="level-left"><span class="level-item">34.5</span><span class="level-item">CyclicBarrier与CountDownLatch比较</span></span></a></li></ul></li><li><a class="level is-mobile" href="#反射"><span class="level-left"><span class="level-item">35</span><span class="level-item">反射</span></span></a></li><li><a class="level is-mobile" href="#IO流的分类"><span class="level-left"><span class="level-item">36</span><span class="level-item">IO流的分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符流和字节流"><span class="level-left"><span class="level-item">36.1</span><span class="level-item">字符流和字节流</span></span></a></li></ul></li><li><a class="level is-mobile" href="#J-U-C包的JDK源码（CAS、AQS、ConcurrentHashMap、ThreadLocal、CyclicBarrier、CountDownLatch、Atom、阻塞队列等等）"><span class="level-left"><span class="level-item">37</span><span class="level-item">J.U.C包的JDK源码（CAS、AQS、ConcurrentHashMap、ThreadLocal、CyclicBarrier、CountDownLatch、Atom、阻塞队列等等）</span></span></a></li><li><a class="level is-mobile" href="#IO（writer、reader、InputStream、OutputStream）、NIO等"><span class="level-left"><span class="level-item">38</span><span class="level-item">IO（writer、reader、InputStream、OutputStream）、NIO等</span></span></a></li><li><a class="level is-mobile" href="#对象序列化与反序列化"><span class="level-left"><span class="level-item">39</span><span class="level-item">对象序列化与反序列化</span></span></a></li><li><a class="level is-mobile" href="#锁优化"><span class="level-left"><span class="level-item">40</span><span class="level-item">锁优化</span></span></a></li><li><a class="level is-mobile" href="#全局唯一有序-ID"><span class="level-left"><span class="level-item">41</span><span class="level-item">全局唯一有序 ID</span></span></a></li><li><a class="level is-mobile" href="#红黑树"><span class="level-left"><span class="level-item">42</span><span class="level-item">红黑树</span></span></a></li><li><a class="level is-mobile" href="#AOP、实现动态代理的方式"><span class="level-left"><span class="level-item">43</span><span class="level-item">AOP、实现动态代理的方式</span></span></a></li><li><a class="level is-mobile" href="#Dom4J以及SAX的区别，什么时候用，怎么用"><span class="level-left"><span class="level-item">44</span><span class="level-item">Dom4J以及SAX的区别，什么时候用，怎么用</span></span></a></li><li><a class="level is-mobile" href="#Maven，为什么要用"><span class="level-left"><span class="level-item">45</span><span class="level-item">Maven，为什么要用</span></span></a></li><li><a class="level is-mobile" href="#NIO，怎么使用"><span class="level-left"><span class="level-item">46</span><span class="level-item">NIO，怎么使用</span></span></a></li><li><a class="level is-mobile" href="#动态代理"><span class="level-left"><span class="level-item">47</span><span class="level-item">动态代理</span></span></a></li><li><a class="level is-mobile" href="#GC"><span class="level-left"><span class="level-item">48</span><span class="level-item">GC</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zoctan&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Zoctan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script><script src="/js/post_date_tips.js"></script><script src="/js/add_runtime.js"></script><script src="/js/remove_powered_by.js"></script></body></html>