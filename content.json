{"posts":[{"title":"English Basis","text":"名词所有格有生命名词的所有格 一般加 ‘smy brother’s bagthe boy’s mother 以 -s 和 -es 结尾的复数名词，右上角加 ‘the workers’ clubthe birds’ song 复合名词后加 ‘sher son-in-law’s photo 两人共有一样，只在后一名词加 ‘s ; 如果不共有，两个名词都加Jane and Mary’s fatherJane’s and Tom’s father 无生命名词的所有格 一般 of + n.the gate of schoolthe window of the room 时间/距离/国家/城市/团体/机构，加 ‘stoday’s newspaperten minutes’ walkChina’s industrythe station’s waiting room 注意下列无生命的短语中的所有格 to get one’s money’s worth get sb. out of harm’s way at death’s door at swords’ points by a hair’s breadth within a stone’s throw 冠词冠词位置 通常放在 名词 或 形容词 前Articles can be a problem area in English for students even at advanced level.Now we come to the most important thing. 下列短语中不定冠词应后置 quite/rather/such/what/half + a(n) quite a good bookrather a pitywhat a dayhalf an hour = a half hour so/as/too/how/howerver + adj. + a(n) + n. She is as clever a girl as you can wish to meet.It’s too difficult a book for us.Now I can see how serious a problem it is. 下列短语中定冠词应后置all/both/half/twice/double/three times + theall the informationboth the twinshalf the story 数词基数词 21-99 的二位数，在十位和个位之间加 -fifty-threeeighty-nine 101-999 的三位数，数字 + hundred + and + 二位数或末尾数three hundred and twenty-fivesix hundred and three hundred/thousand/million/billion 表示确切数目时不加 s，反之要加several hundred, five thousand, ten milliontens of, hundreds of, thousands of 在几十年代，in + the + 逢十的数词复数in the 1990s = in the 1990’s = in the nineteen nineties 在几十几岁，in + one’s + 逢十的数词复数in his thirtiesin his sixties 与基数词合成的定语，名词用单数a three-month-old babythe twelfth five-year plan 序数词 基数词加 -th，前面一般加定冠词 thethe sixththe eighteenththe two hundredth 以 y 结尾的基数词，y 变 i，加 -eththe twentieththe fiftieth 不规则的序数词firstsecondthirdfiftheighthninthtwelfth 两位或以上的把最后一个数词变为序数词twenty-firstthirty-secondone hundred and sixtietheight hundred and seventy-fifth 编号 不加冠词 事物名词 + 基数词Part OneLesson ThreeAct TwoGate Three 定冠词 the + 序数词 + 事物名词the First Partthe Third Lessonthe Second Actthe Third Gate 日期 某月某日 March 15(th) 读作 March (the) fifteenth = March fifteen 15(th) March 读作 the fifteenth of March 某年某月某日 March 15(th), 2011 读作 March the fifteenth, two thousand and eleven 15(th) March, 2011 读作 the fifteenth of March, two thousand and eleven 美式 3/15/2011 = 3,15,2011 英式 15/3/2011 = 15,3,2011 其他数词 分数 = 分子(基数词) / 分母(序数词)，分子大于1时，分母的序数词要复数1/3 -&gt; one/a third2/3 -&gt; two thirds1(2/3) -&gt; one and two thirds 小数，小数点后按个位基数词依次读出0.6 -&gt; zero point six5.38 -&gt; five point three eight 代词人称代词人称代词的格 主格 宾格 I me you you he him she her it it we us you you they them 主格可以做 主语：I like English. 主语补足语：Was it he who phoned? 同位语：Lu Xun, he was a great writer. 呼唤语：Hey, you, look out! 分词的逻辑主语：She being ill, I have to stay home. 宾格可以做 宾语：Give me the book, please. 介词宾语：I want to talk the matter over with her. 宾语补足语：I don’t believe the murderer to be him. 人次代词格的处理 作表语时 正式文体中，人称代词在表语位置要用主格 Is it Mary? Yes, it is she.It’s she, the one whom nobody likes.I think it is I who should ask your forgiveness.Is this Joe? It is I. 后接 that 或 who 从句时可用主格，也可用宾格 It was he that answered the question.Nature never deceives us; it is always us who deceive ourselves. 但在日常口语中，大家往往用宾格 Open the door please. It’s me. If I were him, I would take your advice. 作补语时与 to be 前的名词或代词同格，即当 A 是 B 时，A 和 B 同格I was taken to be she.He took me to be her. 在 but 后代词的格but 既可看作连词，也可看作介词，因此后面可接主格，也可接宾格Nobody can solve the problem but she/her. 一般是紧接着主语用主格，在宾语后用宾格 Nobody but she can solve the problem. Everyone lost faith in the plan but me. 在 than 与 as 后可用主格，也可用宾格You are younger than I/me. 为防止歧义，主句中动词为及物动词，than 与 as 后的代词作主语用主格，作宾语后用宾格 He likes Mary better than I. He likes Mary better than me. 物主代词 形容词型 名词型 my mine your yours his his her hers its its our ours their theirs 形容词型物主代词作 定语：He is my teacher. 名词型物主代词作 主语：That isn’t my car. Mine is at home. 宾语：I’ve finished my homework. Have you finished yours? 介词宾语：He is an old friend of mine. 表语：Whose book is this? It’s mine. 反身代词 单数 复数 myself ourselves yourself yourselves himself themselves herself themselves itself themselves 动词时态 · 一般时 进行时 完成时 完成进行时 现在 work(s) is/am/are working have/has worked have/has been working 过去 worked was/were working had wroked had been working 将来 will/shall work will/shall be working will/shall have worked will/shall have been working 过去将来 would/should work would/should be woring would/should have worked would/should have been working 一般现在时 经常性、习惯性事件和行为常用时间状语 often, usually, every day, never 现在的状态、特征或普遍真理和事实The earth moves around the sun. 书报标题、球赛现场报道、小说等情况介绍Owen shoots, but the ball hits the post. 格言Pride goes before a fall. 代替将来时 由 when, after, as soon as, once, until 等引导的时间状语从句 和 由 if 等条件状语从句。 When I graduate, I’ll go to the contryside.If you come this afternoon, we’ll have a meeting. Make sure / Be sure / See (to it) / Make certain / Take care + (that) + 从句。 Be sure you finish it today. 表示按计划、时间表要发生的动作 主语是事物，且句中常带有时间状语，一般现在时； 主语是人，多用现在进行时。 往返位移的动词：arrive, come, drive, fly, go, leave, move, return, ride, sail 开始结束的动词：begin, close, end, open, start, stop The train leaves at nine in the morning. 代替过去时。仅限于 say, tell, hear, learn 等少数用于转述别人不久前对自己说过的话，尤其是所说的情况现在仍然存在。 He says he can’t wait any longer.My friends tell me that you’ve been unwell. 代替完成时 It is + 一段时间 + since 从句 It is 比 It has been 更普通 It is ten years since I moved to Shanghai. 一般过去时 过去某时间发生的且已完成的动作He saw Mr. Wang yesterday. 过去存在或持续了一段时间的某种状态Roman Empire existed for centuries. 过去经常发生的动作或多次反复的行为He rode a horse to school everyday when he was a child. 过去经常发生的动作 used to 和 would + 动词原形 used to：过去常发生，但现在不再如此 would + 动词原形：过去常发生，现在也会发生 used to 可描写过去的状态；would 不能 I used to play chess when I was at shool.During the vacation I would swim in the sea.There didn’t use to be any crime around here in the old day. 过去的事情，主句用过去时，为了时态一致，从句也用过去时，即使情况仍然存在。He said he was English. 描述已去世人的情况Edison was a great inventor. 虚拟语气中，用过去时表示现在It’s time, I wish, I’d rather It’s time you had a holiday.I wish you lived closer to us.I’d rather you did it now. 过去的经验，过去时 + ever / never / onceDid you ever see a lion?She never heard such a beautiful song before. 如果要表示 过去一直到现在为止的经验，用现在完成时。 代替过去完成时，说话人不强调先后，不强调因果关系He said he was sorry for what he said.Did you find the pen you lost?When the clock struck ten, we all went to bed. 一般将来时 will, won’t 预测的将来，根据分析判断，认为某事肯定会发生，或某人肯定会做某事The weather will be good tomorrow.Why not come over at weekend? The children will enjoy seeing you. will 预测某事即将发生时，要加副词修饰 Look at the sky. It will probably rain later. 即将发生，时间很短，很快就来了，要加副词修饰 较长的未来，时间长，不加副词，表示肯定 will, won’t 意愿和决心的将来，指个人的意愿或强调所下的决心I will come with you at the weekend, whatever my parents say!After what has just happened, I won’t believe a word you say again. will, won’t 必然趋势或结果的将来，与安排或意愿无关。常搭配 if，表示一件事发生，另一件事就必然发生。I’ll be sixteen years old next month.If we go on like that, we’ll lose all our money. 其他将来时结构 be going to + 动词原形 根据目前状况判断某事即将发生Look at those black clouds. It is going to rain. 根据目前的意愿将要某事We are going to have a meeting today. when 或 if 引导的状语从句，随着一件事发生，另一件事就将发生，主句不能用 be going toWhen he comes, I shall/will give him your message.If you come out for a walk, you will feel much better. be to + 动词原形 按计划、安排即将要做的事I am to have tea with Jack this afternoon. 正式安排，常见于报纸广播，用于宣布官方计划或决定The Prime Minister is to speak on television tonight. 意志 / 命令 / 可能性You are bring my luggage upstairs. 表示愿望的 if 从句，只有主句的行为发生后，if 从句的愿望才能实现If a man is to succeed, he must work very hard. be about to + 动词原形眼下就要发生的事，不接将来时间状语。常用 be about to…when 正要…突然Come on! The check-in desk is about to close.I was about to leave when you phoned me. be due to + 动词原形定于(某时做某事)，常搭配时间状语The repairs are due to start on 26th May. be on the point of, be likely to, be sure to 现在进行时 正在进行的动作或某些体感动词的持续状态They are playing tennis now.My foot is hurting and my back is aching. 少数瞬间动词用进行时表示不断重复的动作He is jumping with joy.Someone is knocking at the door. 少数动词用进行时表示一个临时行为，即虽然说话时没有真正在做，但现阶段正在从事且还没有结束的行为She’s staying in my house this time.I don’t really work here; I am just helping out until the new secretary arrives. 这类动词：live, work, study, stay, help 在一个特定时间段内反复进行的事情I’m feeding the neighbour’s cat this week while she’s in hospital.Jack’s having a tough time at the office at the moment and he’s smoking about fifty cigarettes a day! 计划或安排即将发生的事，即最近或较近的将来，给人一种期待感，常伴有表示将来的时间状语We are leaving here tomorrow.They are getting married next month. 常用于表示开始、终结、往来行动的动词：arrive, begin, close, come, drive, end, fall, finish, fly, go, land, leave, open, move, return, start, stop, take off, travel 搭配 always, constantly, continually, forever 表达某种感情色彩，如不耐烦、不满意、赞美、惊奇She is always complaining.He is forever finding fault with me. 离现在较近的过去Do you hear what she is saying?You know I’m telling the truth. 解释和归纳前面的话When I say somebody is lazy, I’m not referring to you.If you climb mountains in such bad weather, you are asking for trouble. 表示 关切、礼貌、强调、赞美 等 Are you feeling better today? I’m hoping you will come. I’m telling you the truth. You are doing fine work at school. 下列介词短语表示进行中under discussionunder wayunder constructionunder repairunder medical treatment 过去进行时 过去某一时刻、某一阶段正在进行In 1980 he was studying in a university. 行为的短暂性 或强调它的不断变化和发展During my training I was earning a lot less than my wife.His symptoms were becoming more pronounced each day. 常和一般过去时一起使用，用于描述一个动作进行过程中另一个动作发生Darkness was falling over the city when I came back home.Seventy cars were crossing the river when the bridge collapsed. 强调在过去一个临时的时间段里反复进行的事For the first three months she was receiving chemotherapy on weekly basis. 搭配 always, constantly, continually, forever 等表达某种感情色彩My brother was always losing his keys. 将来进行时 将来某个特定时间要进行的动作What will you be doing this time tomorrow?When I get home, you will probably be watching television.I hope he will be feeling better when you come tomorrow. 早先已安排将来要做的 或 预定会发生的事He will be staying with us again next year.I will be seeing her over Christmas vacation. 常用于委婉地询问别人的计划 或 拒绝邀请 Will you be coming at six tomorrow? Will you be staying long? If you will be wanting anything, just let me know. I’m sorry, I can’t come to your wedding as I’ll be working on that day. 把将来的事件看作是惯例或常规，此将来事件往往会持续一些时间Winston will be performing with his steel band every night of the music festival.We’ll be having our weekly meeting tomorrow so I’ll present your proposal then. 将来进行时重在表达作为惯例或常规，此事肯定会发生 I’ll be seeing Mr. Kennedy at the court tomorrow - he’s always there on Thursdays - so we can discuss your case briefly then. 现在进行时重在表达此事是个新的安排而非惯例或常规 We’re having our weekly meeting tomorrow instead of Friday this week. 一般现在时重在表达此事是按时间表要发生的事 We have our weekly meeting tomorrow so I’ll present your proposal then. will be + -ing 表示现在，will 用作情态动词，有揣测的意思，常搭配 nowThey’ll be watching television now.Hurry up. They will be waiting. 现在完成时 动作在说话前已完成，但对现在有影响。句子无具体时间状语He has gone to Fuzhou.I have lost my wallet. 常用的不明确时间状语：already, yet, just, recently, lately, still, ever, so far, seldom, never 动作开始于过去，持续到现在，也许还会持续下去He has studied English for 5 years.I have been here since 1993.Up to now, everything has been successful. 常用连词： for, since常用包括现在时间在内的状语：so far, now, in the past few years, today, this week, up to now, for as long as I can remember 用在时间和条件状语从句，表示将来某时完成的动作I’ll go to your home when I have finished my homework.If it has stopped snowing in the afternoon, we’ll go to the park. 用于下列序数词及 the only 构成的句型It/This is the first/last/only + 名词 + (that) + 现在完成时It is the first time that I’ve seen such a wonderful building.It is the only book that he has ever written. 用于形容词最高级构成的句型It/This is + the best/worst/most interesting + 名词 + (that) + 现在完成时This is the best film that I’ve ever seen.This is the most interesting book that I’ve ever read. 过去完成时 描述过去某一时刻或某一动作前完成的动作或状语He asked me whether I had seen the film the night before.By the end of last year we had built five new houses.At the time of the trial last summber Hinckley had been in prison for eight months. 常搭配 before, after, when, until 等引导的时间状语从句，使被描述事件发生的先后表达得更清楚The train had left before I reached the station.He felt a lot better after he had taken the medicine.When we got back, the babysitter had gone home.Until yesterday I had ever heard about it. before + 过去完成时 表示 不等…就，句中的过去时动作先发生，或阻止其后面的动作发生主句(过去时，动作先发生) + before + 从句(过去完成时)She sacked him before he’d had a chance to explain. 常用过去完成时的结构 By/Towards/Before the end of + 过去时间 + 句子(过去完成时) At the time of + 过去事件 + 句子(过去完成时) By + 过去时间 + 句子(过去完成时) By the time + 句子(过去时) + 句子(过去完成时) Hardly/Scarcely/Barely + 过去完成时(倒装) + when + 句子(过去时) No sonner + 过去完成时(倒装) + than + 句子(过去时) 主句(过去完成时) + for as long as I could remember 过去没有实现的愿望We had hoped that you would be able to visit us, but you did not.She had thought about paying us a visit, but was prevented from doing so. 常用词：expect, hope, intend, mean, suppose, thinking about, want, wish 在虚拟结构中用过去完成时表示过去 将来完成时 / 将来完成进行时 将来完成时 表示将来某时刻前某行为已经完成，或预计将已完成 简单句常用 by, by then, before, within the next week 等表示将来时间的介词短语引导 复合句常用 before, when By the end of next week, they’ll have reached the destination.By the time he arrives, we’ll aleady have left California.By then we’ll have eaten all the food we brought.I’ll have finished reading the book before the next lesson.Perhaps we’ll have finished our work before she arrives.When we get there, they’ll probably have left. 将来完成进行时 强调动作的延续性，表示该事情到将来某个时候已经持续了一段时间I’ll have been teaching for thirty years in July.By the end of next month, I’ll have been living here for 18 years. 过去将来时 从过去的某时间看将要发生的动作或存在的状态，would + 动词原形They were sure that they would succeed. 常用于宾语从句He said he would call for me at six.She asked me what I would do the next morning. was/were going to do 过去的预见或意图，也常表示计划没有实现The sky was then overcast with black clouds. There was going to be a storm. was/were to do, was/were about to, was/were due to 按计划、安排将在过去将要发生的事情As I was to leave the next day, I went to bed early. was/were to + have done 原计划、原打算 或 本应当做的事没有做或没有发生I was to have seen him last Wednesday, but he didn’t come. 现在完成进行时 一个从过去某一时刻开始的动作，一直延续到说话时还在进行或刚结束常用 for, since, how long 等引导的时间状语Her telephone has been ringing for a long time. 表示一个重复性的动作，常表示 关切、惊异、愤怒 等感情色彩You have been coughing a lot lately. 搭配 lately, recently 表示动作或行为的临时性Helen’s been spending a lot of time at the club lately.People have been eating less meat recently because of the price. 被动语态 · 一般时 进行时 完成时 现在 is/are done is/are being done have/has been done 过去 was/were done was/were being done had been done 将来 will be done · will have been done 过去将来 would be done · would have been done 虚拟语气用于条件状语从句 · 条件状态从句 主句 与现在事实相反 If + 主语 + 动词过去式 主语 + would/should/could/might + 动词原形 · (be 动词一律 were) · 与过去事实相反 If + 主语 + 动词过去完成式 主语 + would/should/could/might + have + 过去分词 与将来事实相反 谓语用动词过去式 主语 + would/should/could/might + 动词原形 · 谓语用 were to + 动词原形 · · 谓语用 should + 动词原形 祈使句 与将来事实相反中 should + 动词原形 表示实现的可能性很小 were to + 动词原形 表示绝对不可能 用于宾语从句下列动词后接宾语从句，用 (should) + 动词原形 建议：suggest, propose, recommend, advise, move, motion 主张：insist, maintain, hold, urge 要求：ask, request, require, demand, desire, prefer, arrange 命令：order, command We suggested that we (should) have a meeting.The doctor ordered that she (should) stay in bed for a few days. 用于表语从句、同位语从句下列动词后接表语从句 同位语从句，用 (should) + 动词原形 建议：suggestion, proposal, recommendation, advice, motion, idea, resolution, wish 要求：aim, request, requirement, demand, desire, necessity 命令：order My idea is that he (should) do exercises first.Our decision is that the school remain closed. 用于主语从句在主语从句中(常用 it 作形式主语)，谓语动词的虚拟语气结构用 (should) + 动词原形 或 should + have + 过去分词，表示惊奇、不相信、惋惜、理应如此 It is/was + 某些形容词 + that + 句子(虚拟语气)形容词 necessary, important, natural, desirable, advisable, strange, urgent, preferable It is not necessary that everyone be a scientist.It is strange that he should have gone away withour telling us. It is/was + 名词 + that + 句子(虚拟语气)名词 a pity, my desire, a shame, no wonder It is a pity that you should be so careless.It is his desire that a medical team should stay here. It is/was + 过去分词 + that + 句子(虚拟语气)过去分词 desired, suggested, decided, proposed, requested, ordered, recommender, required It has been decided that the meeting be put off till tomorrow.It is required that you give us a talk on international affairs. 用于定语从句定语从句和主句的时态可参照虚拟条件从句和主句的搭配 Anybody who should do that would be laughed at.= If anybody should do that, he would be laughed at. A man who stopped working would amount to nothing.= If a man stopped working, he would amount to nothing. Any person who had behaved that way would have been dismissed.= If any person had behaved that way, he would have been dismissed. wish / if only + 句子 用法 谓语动词形式 现在未实现的愿望 过去式(be 动词用 were) 过去未实现的愿望 过去完成式 或 could have + 过去分词 将来不可能实现的愿望 could/might/would + 动词原形(不用 should) 译为 可惜…、…就好了、悔不该…、但愿…，引导的从句时态不受主句影响 现在未实现的愿望I wish I knew his phone number.I wish it were spring all the year round.If only I were a bird! 有时也可用 could, mightI wish I could help you.I wish I might be with you. 过去未实现的愿望I wish/wished I had taken your advice.If only I had taken his advice. 将来不可能实现的愿望could/might + 动词原形 表示可能性would + 动词原形 表示愿望或礼貌请求 I wish I could dance but I’m afraid I’ve got two left feet.If only we could see the situation through his eyes. 主句 + as if/though + 从句 与现在事实相反，过去式(be 动词用 were) 与过去事实相反，过去完成式 When a pencil is partly in a glass of water, it looks as if it were broken.He talks to me as though I were a child. would rather + 从句 从句用过去时，表示现在或将来 从句用过去完成时，表示过去 I would rather you paid me now.I would rather you painted the wall green next time.I would rather she hadn’t done that. suppose (that) 等引导的表示假设的句子suppose/supposing (that), even if/though, what if, imagine (that) + 句子 句子用过去时，表示现在或将来 句子用过去完成时，表示过去 Suppose he asked you to marry him, what would you say?Even if he were wrong, you should not treat him like that.What if you came tomorrow instead of today?Imagine that we were on a lonely island now. If it were not for 与 But for译为 如果没有；要不是因为 虚拟现在If it were not for / But for + 名词 + 主句(过去将来时) If it were not for the rain, the crops should (would) die.But for the rain, we should have a pleasant journey. 虚拟过去If it had not been for / But for + 名词 + 主句(过去将来完成时) If it had not been for your timely help, I would have failed.But for your help, I would not have finished the work. 错综时间 If it were not for + 虚拟过去 If it had not been for + 虚拟现在 If it were not for his short sight, he would have been a pilot.If it had not been for the doctor’s care, I should not be speaking to you now. 某些连词引导的条件、目的和让步状语从句 条件状语从句on condition (that) 条件是，so long as 只要 I lent it to him on condition that he should return it.So long as it be fine, I will start. 目的状语从句in order that 为了，for fear (that) 唯恐，in case (that) 以防 I have come all the way from Vienna in order that you should thoroughly understand me.He’s working hard for fear that he should fall behind.He doesn’t dare (to) leave the house in case he should be recognized. 让步状语从句whether 无论，though 虽然，whatever 不管什么 And I support such testing, whether it be in public schools or in a homeschooling situation.Though he be the President himself, he shall hear us.Whatever be the reason for his action, we cannot tolerate such disloyalty. 祝愿及某些固定表达 祝愿(常用动词原形)God bless you!Heaven forbid!May you succeed!Long live our motherland! 固定表达 So be it 那就这样吧，顺其自然 Be that as it may 尽管如此 If need be 如有必要 If he doesn’t want to see us, then so be it.Be that as it may, I won’t lose heart.If need be, I can come early tomorrow. Be + 主语 + ever so 形容词，译为 无论怎样… Be + 主语 + 表语 A or 表语 B，译为 无论是 A 或 B 动词的非谓语形式不定式 · 主动态 被动态 一般时 to do to be done 进行时 to be doing 完成时 to have done to have been done 完成进行时 to have been doing 否定形式 not to do 作主语it 往往作形式主语To see is to believe.It is right to give up smoking. 作表语The important thing is to save lives.My job is to help patients. 作宾语He wanted to go.She deserved to win because she was the best. 作宾语补足语He asked me to do the work with him.The news of his failure caused the students to give up hope. 作定语She’s finally made a decision to leave.The farmers thought of ways to protect their crops. 作状语目的、结果、条件、原因 作独立成分to be frankto be exactto be sureto begin withto tell the truthto say the leastto say nothing ofto make a long story shortneedless to say 搭配疑问词 who, which, when, where, how, what，作名词How to solve the problem is very important.My question is when to start. 动名词 · 主动态 被动态 一般时 doing being done 完成时 having done having been done p222 分词介词介词/前置词，是一种虚词，不能单独做句子成分，必须与名词或代词构成介词短语，才能在句中充当一个成分。 介词分类 简单介词 at, in, on, besides, since, for 合成介词 inside, out of, onto, without 短语介词 because of, next to, instead of, due to 二重介词 from behind, until after 分词介词concerning / regarding / respecting,considering, following, given, including,owing to, saving 介词短语在句中的作用 定语A friend in need is a friend indeed.The houses opposite ours are being pulled down. 状语With production up by 60%, the company has had another excellent year.In the absence of mathematics, science would not exist. 表语Japan is to the east of China.He is always among the first to come to school. 宾语补足语Make yourself at home.We found her in better spirits. 介词宾语He came out from behind the door.We have been living here since before liberation. 介词后直接接形容词at best 至多at present 目前for good 永远in brief 简而言之 省略介词直接接名词of + age/color/height/length/size/shape/volume 作表语时，可省略 of They were (of) the same age. He was (of) medium height. The sky is (of) the color of jade. 常用介词 用法 常用介词 时间 at, in, on, by, for, through 在附近 near, by, beside, at 地点 at, in, on 除…外 besides, except, except for, but, but for 方位 in, to, on 经由，通过，穿过 across, by, through 在…上/下 above, below, over, under, on, beneath 方式 by, through, with 原因 through, with, from, for, at, owing to, due to, because of, on account of, thanks to 价格，比率，对比 at, by, for, against 属性，特性 of, with 比较 as, like, in spite of, despite 时间at 时间的一点、时刻They come home at sunrise (at noon, at midnight, at ten o’clock, at daybreak, at dawn). 较短暂的一段时间，某个节日 或大事的日子He went home at Christmas (at New Year, at the Spring Festival, at night, at midsummer).At the beginning (middle, end) of that month he was sick.His grandfather died at seventy-two. in 在某个较长的时间(如世纪、朝代、年、月、季节，以及泛指的上午、下午和傍晚)He was born in 1942.He did it in the holidays. 在一段时间后 用于将来时间时，谓语动词为 一时性的动作，in 译作 在…以后He will arrive in two hours. 谓语动词为 延续性的动作，in 译作 在…以内These products will be produced in a month. after 用于将来时间时也指 一段时间后，但其后的时间是 一点，而不是一段after two o’clock on 具体的时日或特定的时间，如某日、某节日、星期几等On May 4th (On Sunday, On New Year’s day, On Christmas Day), there will be a celebration.He will come to meet us on our arrival. 某个特定的早晨、下午、晚上He died on the eve of victory.He arrived at 10 o’clock on the night of the 5th. 准时，按时If the train should be on time, I should reach home before dark. by 不迟于，在…前He must have returned by now.Jack had made some friends by the time you came. 在…间，在…的时候He worked by day and slept by night.I don’t like travelling by night. for (年、月、日、时等)…之久He was absent from school for a week.I have been here for three days. 指定的时刻The operation was fixed for Friday.The ceremony was arranged for two o’clock/March 1st. through 从…开始到结束，同 throughout He guarded us all through the night. We work hard all through the year. It rained throughout the night. 在附近near 相对的近，实际距离可能还很远 Suzhou is near Shanghai. There is a post office near our school. by, beside 靠近，实际距离不会很远，但 beside 比 by 更具体地表示出 在…旁边 He was sitting beside her. There is a big tree by the river. at 在旁边，多表示有目的的行为所处的位置，而 by, beside 仅表示位置关系 The students are sitting at the desks listening to the teacher. Several students are sitting by/beside the windows talking about a film. 地点at 较小的地方I shall wait for you at the station.The car is waiting at the traffic lights. at the bus stopat the doorat the traffic lightsat the deskat the top/bottom ofat the end of 门牌号码前He lives at 115 Fuzhou Road. in 较大的地方或在里面He lives in Shanghai/in the city centre.He is in a shop/in the kitchen/in the garden. 小的地方 如果说话人住在那，可用 in 商店、机关、学校，看作一个地点(point)用 at；看作一个场所(place)用 in I met him at the post-office.I’m now working in the post-office. on 一般与面与线接触 在…上The picture was hanging on the wall.He put the book on the table and sat on the chair. 在…旁边He lives in a house on the river.Xiamen is on the sea.New York is on the Hudson River. He sails on the river every day. 在…里He lives on Fifth Avenue.He has few friends on the campus. 方位in 在某范围内 Guangdong lies in the south of China. to 在某范围外 Fujian lies to the south of Jiangsu Province. on 毗邻、接壤 Mongolia lies on the north of China. 经由、通过、穿过across 穿过、跨过，表示横过一个平面或横过一条直线，或指静止的对面的位置 A bird flew across the sky. Kate went across the street to make some purchases. A smile of peasure passed across the his face. by 经由、取道、通过，表示移动的方向 He rose quickly and went out by another door. She crossed the stream by a little bridge. I shall return possibly by Nanjing. through 从…通过、穿过，表示通过三维的空间 The sunlight was coming in through the window. He got us in through the back door. 在…上/下above 在…上、高于…(相对高度，不一定在正上方)，反义词 below A bird is flying above the woods. The dead sea is below the sea level. 还可以指位置、职位、程度、价值、品德、年龄高于或低于所提及的人或物 over 在…上(垂直之上 或附于某物之上并将之遮住)、从…上越过，反义词 under There is a lamp over our heads. Spread a cloth over the table. The dog jumped over the table. on 在…上(与表面接触) He put a map on the desk. They sat on the grass. beneath 几乎紧贴在某物之下 The earth felt soft beneath our feet. He wore a woolen vest beneath his shirt. 方式by 方式、方法、手段 一般的方法或方式We often met by appointment.The bicycle is made by machine, not by hand. by weight 按重量计的方式by volume 按体积计的方式by auction 以拍卖的方式by contract 以承包的方式 传达、传递的方式或媒介How did you send the letter, by airmail or by e-mail? by express 以快递by letterby postby raido 用交通工具、通讯工具。后接名词单数，不加冠词He came by train but his wife came by bus. through 媒介、方法，译作 以、通过、经由 I obtained my position through a friend. He succeeded through hard work. 原因through 因为，常搭配 neglect, carelessness, mistake, fault，表示偶然或消极的原因，如疏忽、过错、不慎 He cut himself through carelessness. The experiment failed through no fault of ours. with 因为、由于，外界影响到内部 He is down with high fever. The little girl was shivering with cold. from 动机、疲劳、痛苦、死亡等原因 She did it from a sense of duty. He often dozed off from tiredness. for 为了某一目的、事因 Forgive me for keeping you waiting. The boys all jumped for joy at the news. at 原因，当听到、看到、想到 She looked surprised at seeing us. At this news they felt very glad. due to 常作表语，也可状语 Our delay is due to traffic jam. That Shelly became a poet may have been due to his mother’s influence. Later, he was released due to poor health. owing to 常作状语，不用作表语 Owing to his lack of experience, John failed to do the work well. Now his crops completely failed, owing to a disease that had set in. because of, on account of 常作状语，不用作表语 Because of her bad leg, Jane couldn’t walk as fast as the others. At first Philip hesitated on account of the expense. 但若主语不是一个名词而是事实，可作表语 We stayed at home; that was because of the snow. His health is failing; that is on account of the lack of healthy forms of exercise. thanks to 只作状语，不用作表语 Thanks to your kind help, we finished early. Thanks to your generous donation, we can rebuild our laboratory. 价格、比率、对比at 比率、单位、价格 You bought this bike at a high price. The population is growing at a surprising rate. The train runs at about 120 miles an hour. She will get it at any cost. Normally, we walk at a/the speed of four miles per hour. by 度量单位或标准、以…计 按照，相当于 according to It is nine o’clock by my watch. I set my watch by the standard clock of the custom house. 以…计、成(百/千)地、某种行事方式 by + the + 计量单位(单数)，以…计 Meat is sold by the pound. They are paid by the hour. He buys them by the hundred. by + 复数数词(不加冠词)，成(百/千)地 The words in a book are counted by thousands. They sat down in ranks, by hundreds, and by fifties. by + 单数数词(不加冠词)，某种行事方式 Here eggs are sold by weight. These goods are for the most part made by hand. 尺寸、距离、增减程度 The hole high up in the wall is about 18cm by 9cm. (18厘米长，9厘米宽) Industrial production rose by nearly two-fifths in the past three years. for 交换或交换值 They rented it to us for fifteen dollars a month. He agreed to give her 500 dollars for the picture. against 对比 We have six girl students in our class this year against ten last year. Against the U.S. dollar its value increased by more than 15 percent. 属性、特性of + 抽象名词 形容词特性 后置定语 A man of wisdom = a wise man fifty years of age = fifty years old 作表语 This matter is of great importance. (= very important) Your information is of great value to us. (= valuable) 此类抽象名词有 age, color, help, height, length, no use, shape, size, thickness, width 日常用时，of 常被省略 I want another pair of shoes (of) the same size. of a + 名词 不同物质的共同性质，of 前的名词与 of 后的名词是同位关系 用在短语 an angel of a wife = The wife is an angel. a fool of a man = The man is a fool. a poem of a night = The night is a poem. 用在句子 Birds of a feather flock together. 物以类聚，人以群分 These machines are of a kind. 这些机器都是同种类型的 with 表示属性、特性时，后面接的通常不是抽象名词，而是具体名词，用于说明人或事物的形状 a coat with four pockets. a magazine with a pretty girl on the cover. 比较as + 名词 描述某人的工作，身份，所扮演的角色或某物所起的作用(比较对象 本身就是) Simon’s working as a waiter during the summer vacation. Use your payroll number as a password for the computer. like + 名词 比较两个看上去相似的东西(比较对象 貌似而其实不是) They were behaving like children! When Mike puts on his dark suit he looks like a waiter. Despite, In spite of, Despite the fact that 简单句陈述句 肯定句I’m looking forward to hearing from you soon. 否定句 谓语动词是 be, have, 助动词或情态动词，后加 notHe is not a student. 谓语动词是行为动词，又没有助动词或情态动词，前加 don’tI don’t want to do that. 否定词 no, hardly, neverHe has no brothers or sisters. 两者的全部否定 neither 或 neither…nor…Neither of them knows French.Neither John nor Mary is here. 两者的部分否定 both + notBoth of them didn’t attend the meeting. 三者以上全部否定 none, nothing, nobody, no oneNone of these answers is/are right.Nobody agrees with what you said. 三者以上的部分否定 总体意义词 + not (all, many, every)Not many people like music.Not every girl likes singing and dancing.All these books are not mine.All that glitters is not gold. 按语义本应放在 that 从句中的否定词 not 被移到主句的谓语动词中，通常用在 相信、臆测一类词(believe, expect, imagine, suppose, think)I don’t think it is very cold today.We don’t believe that he can do it. 疑问句 一般疑问句 谓语是 be, have，将它们放在主语前Have you any English books?= Do you have any English books? 谓语是行为动词，将助动词 do 或情态放在句前Do you have a meeting every week? 否定疑问句用肯定还是否定，应根据实际情况Isn’t she a doctor? Yes, she is.Can’t you do it? No, I can’t.Didn’t you meet him? Yes, I did.Haven’t you finished the homework? No, I haven’t. 特殊疑问句 特殊疑问词作主语或主语的定语，与陈述句语序相同Who is in the room?Whose father works in Beijing? 特殊疑问词作宾语、状语、表语或修饰这三种成分的时候，疑问词 + 一般疑问句Where do you come from?When will you go? Why + 一般疑问句否定式，表示劝告、建议、责备等Why don’t you come earlier? 含有插入语的特殊疑问句特殊疑问词 + do you think, do you suppose, do you say + 陈述句语序When do you think he will come?Which train did you say you had taken?What do you suppose has happened? 反义疑问句p286 复合句名词性从句主语从句及形式主语 主语从句在作主语，放在主句谓语动词前引导词有 连词 that, whether 代词 who, what, which 副词 when, where, how, why That she was able to come made us very happy.Whether she will come or not is still a question.What we need is more time.Who will go makes no difference.Which team will win the match is still unknown.When they will start is not known yet.Where she has gone is a mystery.How this happened is not clear.Why he did that wasn’t quite clear. 形式主语为避免头重脚轻，由 it 作形式主语，把主语从句放到句末 It + be + 形容词 + that 从句It is strange that he knows nothing about it. It + be + 名词 + that 从句It is a pity that they have failed in the match. It + 动词 + 宾语 + that 从句It depends on its quality and price whether a new product sells well. It + 动词的被动结构 + that 从句It is still unknown which team will win the match. 常见被动结构It turned out that…It has been proved that…It is well-known that…It must be pointed out that… 表语从句 表语从句位于系动词后引导词有 连词 that (有时可省略), whether, as if 代词 who, what, which 副词 when, where, how, why The fact is (that) she never liked him.It could be this part of the ice sheet is not necessarily sensitive to global warming.The question is who can complete the difficult task. because 引导的表语从句只有一个句型This/That/It is because (that)… I think it’s because you are doing too much.It may be because I am no mathematician. reason 作主语，表语从句不可用 why 或 because 引导，只能 thatThe reason why…is that + 表语从句 One reason why Hamlet is such a successful play is that it appeals to many different people. 表语从句不能用 if 引导，但可以用 as ifHe looked as if he was going to cry. 同位语从句两个成分处于相同地位，起修饰作用的叫同位语同位语是后置修饰语，对与之同位的名词(本位词)提供补充说明，起修饰和描绘作用 Wang Lin, a diligent student, refused all help that was offered him.Playing football, his only interest in life, has brought him many friends. 有时也可以置于本位语前Formerly a worker himself, he is now an engineer.Normally a timid boy, Tom jumped into the river and saved the drowning girl. 若用句子作同位语，叫同位语从句下列名词常接同位语从句belief, conclusion, decision, discovery, evidence, report, explanation, fact, hope, idea, information, news, opinion, possibility, principle, problem, promise, truth, wish 引导同位语从句的关联词用 that 时不能被替换His delay is due to the fact that the car went wrong halfway.The news that our team has won the match is true. 引导词有 代词 what 副词 when, where, how, why, whether 疑问词前有时可加 of 或 as to You have no idea how worried I was.He has no idea what a remarkable woman Mary is.She had no idea (as to) why she thought of him suddenly.I have a small doubt (as to) whether he is suitable for the job.My original question, why he did it at all, has not been answered. 主句谓语较短，同位语从句常被分隔主语(本位语) + 谓语 + 同位语从句An idea occurred to him that he might do the experiment in another way.The rumour spread that a new school would be built here. 本位语是 advice, proposal, request, suggestion 等祈使对方怎么做的动作名词，同位语从句谓语要虚拟语气The suggestion came from the chairperson that the rule (should) be adopted. 同位语从句和定语从句的区别 从意义看 同位语从句是名词性从句，对名词加以补充说明 定语从句是形容词从句，对名词加以修饰和限定 It is a fact that she has done her best.It is a fact that you can’t deny. 从结构看 同位语从句常由 that 引导，虽然不充当成分，但也不可省略 定语从句由关系代词引导，代替先行词，在从句中充当主语或宾语成分，充当宾语时常可省略 The news that our team has won the game is really encouraging.The news (that) he told me is really encouraging. 宾语从句及形式宾语宾语从句在句中作及物动词或介词的宾语 引导词有 连词 that, whether, if 代词 who, whose, what, which 副词 when, where, how, why 引导宾语从句的连词 that 通常不能省略 搭配 agree, aruge, assure, hold, indicate, maintain, inform, object, suggest 时，that 常不省略 I assure you that you’re mistaken.He objected that it was impossible. 主句谓语动词后接两个并列的宾语从句，连接第二个宾语从句的 that 不可省略 He said he couldn’t tell you right away and that you wouldn’t understand.I know you aren’t a doctor and that you want your son to become a doctor. 作介词的宾语A modern city has been set up in what was a wasteland ten years ago.The shopkeeper did not want to sell for what he thought was not enough.Mary wrote an article on why the team has failed to win the game. 介词后通常不跟由 that 引导的从句，但可以跟 the fact that 从句He was held responsible for the fact that his dog had bitten his neighbor. 形式宾语谓语动词 consider, find, make, regard, see, take, think 等后接 宾语从句 + 宾语补足语时，用 it 作形式宾语，把宾语从句置于宾语补足语后，此时 that 不省略主语 + 谓语 + it + 宾语补足语 + that + 宾语从句 We find it necessary that we practise speaking English every day.He always takes it for granted that he can pass the exam without hard work. 直接引语转换成间接引语 直接引语是陈述句，改为 that 引导宾语从句He said, “I’m very glad.”He said that he was very glad. 直接引语是一般疑问句，改为 if, whether 引导宾语从句He said, “Can you come this afternoon, John?”He asked whether John could go that afternoon. 直接引语是特殊疑问句，改为 who, what, when 等疑问词引导宾语从句He said, “Where is Mr. Wang?”He asked where Mr. Wang was. 直接引语是祈使句，改为 主语 + ask/tell/order sb. (not) to do sth.He said, “Open the door please, John!”He asked John to open the door.He said, “Don’t talk in class!”He ordered us not to talk in class. whether 与 if 的用法 只能用 whether 不能用 if 表示 是否 的情况 表语从句The question is whether the film is worth seeing. 同位语从句Answer my question whether you are coming. 主语从句Whether we shall attend the meeting hasn’t been decided yet. 用 it 作形式主语，则 whether 和 if 都能引导主语从句It hasn’t been decided whether/if we shall attend the meeting. 在介词之后(介词可省略)It all depends (on) whether they will support us. 名词 + as to + whetherThere is some question as to whether the public should be told about the accident. 后接动词不定式He doesn’t know whether to stay or not. 后接 or notWe didn’t know whether or not she was ready. 避免 if 引起的歧义Please let me know whether you like it. 定语从句在复合句中修饰名词或代词的从句叫定语从句。 引导词有 代词 who, whom, whose, which, that 副词 where, when, why 准关系代词 as, but, than 引导名词性从句或状语从句复合关系代词 what, whatever, whoever, whichever · 主语 宾语 定语 人 who/that (whom)/(that) whose 物 which/that (which)/(that) whose who, whom, whose 引导的定语从句This is the man who helped me.Is Sheba the dog who was run over and nearly killed last year?Do you know the man whose name is Wang Yu?Do you see the house whose windows are all broken? which 引导的定语从句The building which stands near the river is our school. of which/whom 引导的非限制性定语从句 名词、不定代词或数量词 + of which/whom:none, neither, any, either, most, many, much, (a) few, both, half, each, one, two + of whom(人) / of which(物) He’s written a book, the name of which I’ve forgotten.The book contains 40 poems, most of which were written when he was at college.We interviewed fourteen applicants for the post, none of whom we thought suitable.The committee consists of 20 members, five of whom are women. of which/whom 在从句中作主语时，有两种结构Do you see the house, the windows of which are all broken?= …, of which the windows …? The eighty passengers, ten of whom were British, all escaped without serious injury.= …, of whom ten were British, … 名词 + of which 作主语，常可用 whose + 名词取代 of which 前的名词应带定冠词 in which case 引导的定语从句 非限制性定语从句中，用抽象名词 case, point, reason, situation, time 等总结主句的内容时，以 介词 + which + 抽象名词 构成从句，对所提的事进行补充说明。 The plane may be several hours late, in which case there’s no point in our waiting.Ten years of hard work changed her greatly, for which reason he could hardly recognize her at first sight. the way 后接定语从句That’s the way he spoke.That’s the way that he did it.That’s the way in which you answered the question. × That is the way how he spoke.√ That is how he spoke. the way 后不能用 how 引导定语从句，因为 how 不能作关系副词 that 引导的定语从句 关系代词 that 在定语从句中可以指人或物，在从句中作主语或宾语This is the boy that broke the window.The letter that I received was from my father. 必须由 that 引导的情况 先行词是不定代词 all, few, little, much, something, nothing, anythingAll that we have to do is to practise every day.Much that you have read is nonsense. 先行词被 all, any, every, each, few, little, no, some 修饰I have read all the books (that) you gave me.Any paper that you read will give the same story. 先行词被序数词或形容词最高级修饰The first lesson that I learned will be forgotten.This is the most interesting book that I have ever read. 先行词被 the only, the very, the same, the last 修饰He is the only person that I want to talk to.This is the very book that I want to buy. 先行词既有人也有物They talked of things and persons that they remembered.The train ran over to a boy and his dog that were just corssing the track. 以 who, which 引起的问句，为避免重复，常用 thatWho is the man that is talking to John?Which was the hotel that was recommended to you? 作关系副词，修饰表示时间的名词 day, time, moment 等，代替 whenIt happened on the day that/when I was born. 关系代词作表语或宾语补语的情况 who, whom 不能作表语 which 作表语，可指人或物指人时，一般指从事某种职业或有某种特性，品质或才能的人引导的定语从句既可以是限制性，也可以非限制性He is no longer the man which I thought him to be.Anna is a vegetarian, which no one else is in our family.This is not the type of modern house which my own is. that 作表语，可指人或物引导的定语从句只能是非限制性He is not the liar that he appeared to be.He is not the man (that) he was when I saw him first. 复合关系代词 what 作表语，可指人或物Things are not what they seem.She isn’t what she used to be. 关系代词的省略 关系副词 when, where, why 引导的定语从句兼有连词作用常用于表示时间、地点、原因等名词后 whenAt the time when I saw him, he was quite strong. whereYou have reached the point where a change is needed. whyCan you tell me the reason why you are so unhappy? 特殊用法 省略先行词 this/that/it is 后可省略 the time, the place, the reason 直接跟 when, where, why That was (the time) when he lived there. It is (the place) where I was born. That’s (the reason) why he spoke. 可被 that 或 介词 + which 取代的情况 the day/time/moment when = the day/time/moment that = the day/time/moment on which the place where = the place that = the place in which the reason why = the reason that = the reason for which 介词 + where/when 引导的定语从句 from where 引导定语从句，where 代表主句提供的地点After supper he usually stood near the window, from where he could see the tower. since/by when 引导定语从句，when 代表主句提供的事件背景I bought this dictionary two years ago, since when I have used no others. 准关系代词 as 引导状语从句的连词 as 可用作关系代词，引导定语从句，因而被称为准关系代词。but, than 也能作准关系代词 as 引导限制性定语从句 such …asSuch people as were mentioned by him were honest.(as 作主语)We have such grape as you never saw.(as 作宾语)I’ve never seen such a clever man as he is.(as 作表语) the same…asModern statesmen are often faced with the same problem as defeated the ancient Romans.(as 作主语)I like the same book as you do.(as 作宾语) as…asAs many children as came were given some cakes.所有来的小孩都得到了蛋糕(as 作主语)He is as diligent a man as ever lived.(as 作主语)He was telling the kids as funny a story as he did last time.(as 作宾语) as 引导非限制性定语从句 只代表主句或主句的一部分所表达的意思(不能指代名词或代词)，可以放在主句前、中、后，在从句中作主语或宾语 As is known to all, he is the best student in our class.(as 指代整个句子，作主语，置于句首)He opposed the idea, as could be expected.(as 指代整个句子，作主语，置于句末)As we all know, he studies very hard.(as 指代整个句子，作宾语，置于句首)Taiwan is, as you know, an inseparable part of China.(as 指代整个句子，作宾语，置于句中) as is said aboveas is known to allas is often the caseas is reported in the newspaper 主句具有否定意义，as 引导的定语从句位于主句后，as 指代的主句不包括否定意义，并可用 but 取代 Insects do not have bones, as people have.= …, but people have bones.as 指代的主句为 Insects do have bones Whales are not fish, as some people think.= …, but some people think they are.as 指代的主句为 Whales are fish 但 as 引导的定语从句在主句前时，as 指代的主句仍包含否定意义As has been said above, grammar is not a set of dead rules. which 和 as 引导的非限制性定语从句 which 引导的从句不能放在主句前，而 as 引导的从句既可在主句前，也可以放在主句后 √ As is often the case, he is absent.× Which is … He saw the girl, as/which he had hoped. 作关系代词，as 和 which 都可以指代一个句子，但 as 有 正如、就像 的意思，which 没 He is a foreigner, as I know from his accent.(as 指代一个句子，正如、就像)He has to work on Sundays, which he doesn’t like.(which 指代一个句子，没正如、就像的意思) 当从句的谓语动词是 be 或相当于连系动词的 seem, become 等时，可用 as 或 which 作主语；当从句的谓语动词是行为动词时，只能用 which 作主语 He married he, as/which was/seemed natural.He saw the girl, which delighted him. as 作连词，引导状语从句，构成省略形式 as + 过去分词，翻译时如定语The bridge as shown in the picture is really wonderful.(as shown = as it is shown)See the answers as given at the end of this book.(as given = as they are given) 准关系代词 but but 作关系代词时的3个特征 本身含有否定意义，相当于 who/which/that … not but 的先行词往往是否定意义的代词或名词词组，通过双重否定达到强烈肯定的修饰效果 but 在从句中作主语，谓语动词的数要与先行词一致，时态与主句相呼应 There is no rule but has exceptions.= There is no rule that has not exceptions. There is no one but knows about this affair.= There is no one who doesn’t know about this affair. There are few dictionaries but have a misprint or two.= There are few dictionaries that don’t have a misprint or two. but 引导状语从句时 but = that notI never go past my old school but I think of my headmaster.= I never go past my old school that I don’t think of my headmaster. 准关系代词 than 作关系代词，引导定语从句从句谓语动词的数和时态须与前面被比较级修饰的先行词保持一致Don’t give him more money than is necessary; Money burns a hole in his pocket.He smoked fewer cigarettes than were normally available. 作连词，引导状语从句He did more than was required of him.The really serious cases are fewer than has been suggested. 作连词，引导状语从句，构成省略形式 than + 过去分词 (than 后省略了形式主语 it 和动词 be)Our trip to Shanghai was more fun than expected.A snowstorm is moving across the Northeast and it’s worse than predicted. 常见结构than allowedthan expectedthan imaginedthan measuredthan plannedthan predicted 复合关系代词 what 复合关系代词概念定语从句中 what 是个由名词(先行词)和关系代词组成的复合词，也就是兼做先行词的关系代词，称作复合关系代词what 可指人或物，指人时 what = the person that，指物时 what = the thing(s) which Thank you for the gift. This is exactly what I wanted.I like Jack. He never pretends to be what he isn’t. what 已包含先行词的含义，所以注意以下句子× This is the book what I want.√ This is the book that I want. / This is what I want. what 在从句中的作用 what 的名词作用，作主语、宾语、表语What surprised me most was his way of speaking.(what 作主语)We can learn what we did not know.(what 作宾语)Is the city different from what it was ten years ago?(what 作表语) what 的形容词作用，修饰名词，译作 仅有的，全部的Don’t worry. I will give you what help I can.= Don’t worry. I will give you any help that (as much help as) I can.I gave him what money I had with me. what 在作定语时，常与 few, little 连用修饰名词，译作 尽管不多，但已是全部I will lend you what few reference books I can spare.= I will lend you all the few reference books that I can spare. We contributed what little money we had towards the earthquake-stricken area.= We contributed all the little money that we had towards the earthquake-stricken area. What little he said on the subject was full of wisdom. what 引导的名词性从句在句中的作用 从句作主语What I want is a quiet room away from the noise of traffic.What is over is over. 从句作表语Things are not what they seem.I should like to be a teacher. That’s what I want to be. 从句作宾语Why don’t you tell the police what you told me yesterday?Never put off till tomorrow what can be done today. 从句作介词的宾语Don’t poke your nose into what doesn’t concern you.He gave me a practical illustration of what was to be done. 从句作宾语补足语What has made China what she is today?You can call me what you like. what 用于比喻的结构A is to B what C is to DA 对于 B 犹如 C 对于 D 一样 Parks are to the city what lungs are to the body.Virtue is to the soul what health is to the body. what 组成的常用短语and what not 其他、等等Guess what! 告诉你个消息！What of it? 那又怎样What if …?know what’s what 内行、有判断力 复合关系代词 whoever, whichever, whatever 引导名词性从句 引导让步状语从句 whoever = anybody who whoever = no matter who whichever = any that whichever = no matter which whatever = anything that whatever = no matter what whoever, whichever, whatever 作名词，引导名词性从句，指未知的或不确定的人或物，在从句中作主语或宾语 Whoever comes first will get the prize.You can give the prize to whomever you meet first.Here are two books. You may choose whichever you like.We will do whatever is needed to improve our English. whatever, whichever 兼作形容词，修饰从句中的名词，并引导名词性从句，whatever 译作 仅有的，全部的 Whatever water was left was used for the children.She applied whatever strength she had left to the task.You should wear whichever dress suits you best. whoever, whichever, whatever 作副词，引导让步状语从句 Whoever you are, you must obey the law.Whichever you choose, the others will be offended.Whatever you may think, I’m going ahead with my plans. 限制性定语从句 / 非限制性定语从句 限制性定语从句是对主句先行词加以限制或分类，是句中不可缺少的部分，主句和从句间不能用逗号分开 Is this the book that you were looking for?Would all those who have booked dinner please go to the restaurant now? 非限制性定语从句是对主句先行词的补充说明，没有它不影响主句意思的完整，常用逗号把主句和从句分开As was expected, he performed the task with success.The sun, which had been hidden all day, now came out in its splendour.I have two sisters, who are both students. 非限制性定语从句中的关系代词 which 可指代整个主句或主句某一部分，不能用 that 取代，作宾语的关系代词不能省略We were given a lovely double room, which had a sea view.This book of yours, which I finished reading last night, was very interesting. 插入语 分句作插入语He is, I hear, a great scholar.His only demand is to give the tickets to those who he thinks deserve. 可作插入语的分句I believe, I find, I guess, I hearI imagine, I remember, I suppose, I think 状语分句作插入语That is, as far as I know, not what he really wants. 可作插入语的状语分句as far as I knowas I told you beforeif you like what 构成的惯用插入语 what + be + 比较级形容词 译作 而且，尤有甚者Tom participated and, what is more surprising, won the prize.He said nonthing, and, what is worse, laughed at us. what we call, what is called 译作 所谓的Most of what we call “geniuses” are successful only because they have made great efforts. 类似结构what we considerwhat is consideredwhat is nowwhat is thought to bewhat is referred to aswhat you refer to aswhat is known as 状语从句状语从句在句中作状语，修饰主句中的动词、形容词、副词状语从句在主句前，常用逗号分开；在主句后，一般不用逗号状语从句有9种 时间、条件、原因、让步、目的、结果、方式、比较、地点 时间状语从句 when, while, as 当…的时候 when 强调特定时间 When spring came, he felt like a trip.When he was eating his breakfast, he heard the doorbell ring. while 从句用持续性动词，表示一段时间，而不是一点 While he was eating his breakfast, he heard the doorbell ring.We must strike while the iron is hot. as 强调同一时间里两个相继发生的情况，或两个动作一前一后，有时有 随着 的意思 As he was eating his breakfast, he heard the doorbell ring. (强调同一时间)As I was going out, it began to rain. (强调先后)As spring warms the good earth, all flowers begin to bloom. (随着) before 两件事的先后关系主句肯定，before 引导的从句动作后发生主句否定，before 引导的从句动作先发生I started my meal before he arrived.He didn’t arrive before I returned. till 知道，since 自从，once 一旦，by the time 到…为止 till/until 用于肯定句时，主句用持续的动词 live, last, stand, stay, wait, work He worked until it was dark.She stood there until he had passed out of sight. till/until 用于否定句时，主句用非持续的动词 begin, become, get up, reach, start He did not get up till his mother came in.No man really becomes a fool until he stops asking questions.Do not start until I give the word. since 自从…以来Electricity has been widely used since it was discovered.It has been / It is six years since we entered the middle school. once 一旦，引导的状语从句可以同时表时间和条件Once (it is) printed, this dictionary will be very popular.Once you see her, you will find what I say is true.Once you understand the rule, you will have no further difficulty.= As soon as you understand the rule, you will have no further difficulty. (时间)= If you once understand the rule, you will have no further difficulty. (条件) by the time + 现在时，主句用将来完成时By the time he arrives, we will already have left California. by the time + 一般过去时，主句用过去完成时By the time he arrived, we had already left California. as soon as, instantly, immediately, directly, presently从句动作一发生，主句动作随即发生，译作 一…就…as soon as 最普通instantly 最强presently 最弱As soon as I finish the work, I’ll go to see you.Immediately (when) the button was pressed, the mine exploded.Directly I had done it, I knew I had made a mistake. no sooner…than, hardly…when 译作 刚…就…主句动词用过去完成时，从句用过去时如果 no sooner, hardly 在句首，主句须倒装hardly…when 可换 scarcely…before The sun had no sooner started to shine than it was clouded over again.I had hardly sat down when he stepped in.Hardly had I entered the room when I heard a loud noise.No sooner had she sat down than the phone rang.The day had scarcely broken before he got up to work. time 词组引导，某一特定时刻发生或存在的情况the first time, the last time, next time, every time, each time, any time I thought her nice and honest the first time I met her.Every time I went to his house, he was out. the first time = when…for the first timeI thought her nice and honest when I met her for the first time. 下列名词词组转化成时间连词引导从句，表示两个动作紧接着发生，译作 一…就…the moment, the second, the minute, the instant, the daythe month, the week, the year, the morning, the afternoon She came to the scene the moment she heard the news.I recognized her the instant I saw her. 原因状语从句 because, for 因为，as 由于，since 既然 because 直接的原因，着重在从句，语气最强主句为否定句时，从句 because 要用逗号和主句隔开，不然会产生歧义I didn’t visit him, because I wanted to borrow some books.我没去拜访他，因为我想借几本书I didn’t visit him because I wanted to borrow some books.我不是因为想借几本书才去拜访他 for 不说明直接原因，只提供补充说明，不可放在主句前，要用逗号或分号和主句分开I didn’t go to see him, for a heavy snow was falling.有时表示推断或解释Someone in the house must be ill, for a doctor has just come out. as 十分明显的原因，常在主句前，着重在主句，原因只是附带说明As it is snowing, we shall not go to the park.As this book is written in simple English, it is suitable for beginners. since 对方已知的，无须加以说明的既成事实理由= as it is the fact that… 着重在主句Since you are ill, I’ll go alone.Since all the cakes looked good she couldn’t decide which to choose. seeing that = considering that 近似 sinceSeeing that the weather is bad, we’ll stay at home. now that 近似 sincesince 原先已存在的情况；now that 由于新情况出现而促成某事发生Now that it has stopped rainning, let’s start at once. in that 因为，多指某一方面的原因I like the city, but I like the country better in that I have more friends in the country. not…becauseShe didn’t marry you because you had money.她不是因为你有钱才嫁给你 not that…but that 不是因为…而是因为Not that I don’t like the film, but that I have no time for it. 地点状语从句 引导词 where, wherever, anywhere, everywhere Put it where you can see it.I’ll find him, wherever he is.You can’t camp anywhere/where/wherver you like. We shall go where working conditions are difficult. (状语从句)We shall go to the place where working conditions are difficult. (定语从句) 条件状语从句 if 正面条件If your dog is depressed, he probably needs more exercise. unless 否定条件= if…not / except ifThere will be a picnic unless it rains. only if 使某事成为现实的必要条件= on (the) condition that= as/so long as= provided/providing (that) You may go swimming on condition that you don’t swim too far away from the river bank.We’ll visit Europe next year, provided we have enough money. 假设条件suppose/supposing (that), what if, in case Suppose (that) I don’t have a day off, what shall we do?What if the money doesn’t arrive on time? given that + 句子，given + 短语，译作 倘若，考虑到Given that she is interested in children, I am sure teaching is the right career for her.Given his age, he is really a fast learner. 祈使句/名词词组(,) + and/then/or + 简单句(常用将来时)Give me somewhere to stand, and I will move the earth.= If you give me somewhere to stand, I will move the earth. can’t…and…You can’t study hard and fail in the exam.= If you study hard, you can’t fail in the exam. 让步状语从句 although = even though, though 虽然Although I didn’t know anybody at the party, I had a very good time. though / as 引导的倒装句Patient though/as he was, he was unwilling to wait three hours.Hard as/though he tried, she failed to pass the exam. while 而、虽然、尽管Tom is very outgoing while Ken is shy and quiet. 译作 虽然、尽管 时多放在句首，从句和主句主语多为同一人或物While I admit that the problems are difficult, I don’t agree that they cannot be solved. if 尽管、即使，granted/granting (that) 即使、就算If a jewel falls into the mud, it remains as precious as before.Granted that he’s not brilliant, he at least works hard.Granting (that) you are right, you should not treat her that way. even if 即便不把从句当成既成事实，指某种可能的情况不会阻止另一种情况的发生，所以从句要用现在时来表示将来I’m going to apply for the job, even if it pays very little.They’ll stay by you even if you don’t succeed. p347 目的状语从句 结果状语从句 方式状语从句 比较状语从句 状语从句中省略主语的情况 Itp364 实词(代词) 人称代词 非人称代词 虚词(助词) 作形式主语 作形式宾语 强调语句 It is 和 There be 倒装p374 完全倒装 部分倒装","link":"/2022/10/25/zh/english/basis/"},{"title":"词根","text":"radi 根radical 根本的eradicate 根除radiate 辐射radiant 辐射的radio 收音机radioactive 放射性的radium 镭 pose 摆放expose 暴露compose 组成/创造propose 求婚/提名/提议dispose 扔掉/处理/安排Man proposes, God disposes. 尽人事，听天命。oppose 反对depose 废除/罢免deposit 沉淀物/定金 vers(t) 转reverse 扭转/颠倒avert 转移/避免convert 转变/换算divert 转移/改道introvert 内向的人extrovert 外向的人anniversary 周年纪念controversy 争论 press 压compress 压缩depress 抑郁/萧条suppress 镇压/抑制repress 抑制impress 印象深刻express 表达 duce 引produce 生产/产生/引起induce 诱惑/引诱seduce 诱惑/色诱deduce 推理/推断educe 使显现——educate 教育traduce 中伤/诽谤introduce 介绍/引入/提出reduce 减少 gress 走congress 国会/代表大会regress 退化/退化——recede 退潮/衰退aggressive 激进的progress 进步transgress 越轨/违反/违背 form 形式conform 与…一致/相符uniform 制服/统一的reform 改革transform 改变/使变化deform 变形/使畸形formal 正式的formula 公式/方案 vade 走invade 入侵evade 逃出pervade 遍及/弥漫 spire 气inspire 鼓舞/使有灵感expire 死亡/到期conspire 合谋aspire 立志/渴望spirit 精神/灵魂 sens(t) 感觉sense 感觉/意义——nonsense 胡说/胡扯presentiment 预感consent 同意resent 反感/厌恶sensible 合理的sensitive 敏感的——insensitive 不敏感的 claim 喊proclaim 宣布/宣告reclaim 拿回/收回/使改正/感化/回收再利用acclaim 喝彩/称赞exclaim 惊呼 tract 拉/抽extract 抽出/提起contract 收缩/合同subtract 扣除/减去abstract 抽象/摘要distract 分心attract 吸引——unattractive flu 流fluent 流利的affluent 富裕的superfluous 过多的fluctuate 波动 nounce 说announce = declare = proclaim 宣布denounce = reproach = condemn 谴责/职责pronounce 发音/宣布——pronounced 明显的 ject 射inject 注射/注入eject = expel = dislodge 喷射/驱逐project 投射/工程/计划reject 拒绝/排斥——declineobject 反对subject 隶属/服从/主题/学科 clude 关includeexcludepreclude 防止/阻止conclude 结束/得出结论/推论 dom 房屋domain 领土/领域domestic 家内的/国内的dominate 控制/支配dominant 占支配地位的predominate 占主导地位——predominance 主导地位 sol 单独sole 唯一的solo 独奏solar 太阳solitude 独处solitary 独自的isolate 隔离/孤立 ceivereceiveconceive 怀孕perceive 感觉deceive 欺骗After receiving the news of brother’s conceiving, I perceived to be deceived. vac 空vacation 假期——vocation 职位evacuate 疏离/撤离vacuum 真空/空缺After vacation, a vacant man evacuated from Japan. cred 相信credit 信用/信誉/学分credible 可以相信的——incredible 难以置信的credibility 可信度discredit 不信/怀疑credulous 轻信/易受骗的accredit 委派/信任creed 信条/教义 ficsufficient = adequate = enoughproficient = excellent = good 精通的efficient 有效率的deficient 缺乏的/有缺陷的Sufficient proficiency creates high efficiency and avoids deficiency. nov 新novel 新颖的/小说novice 初学者/新手innovation 创新renovate 修复/翻新 dur 持久durable 持久的endure 持续/继续(存在)/忍受duration 持续时间 tend 伸手extendcontend 竞争/声称/主张intend 想要/打算/计划pretend 假装/伪装attend 照料/出席He pretends to contend his intention to attend an extended conference. vis 看visiblevisualvisualize 想象vision 视力envision 想象/设想envisage 想象/设想revise 修订supervise 监督 not 知道notify (使知道) 通知note (使知道东西) 笔记/便条/记录/注意notable = remarkable = noteworthy 值得注意的notice (使知道) 公告/告示/注意notion (对某事知道) 见解/看法/概念notorious (坏事被知道) 臭名昭著 mot 移动promote (往前移动) 促销/升至/促进/提高demote (往下动) 降级/降职remote (往回移动) 偏僻的/遥远的/久远的emotion (激动出来) 情绪/情绪/激动motive (移动原因) 动机motivate (使移动) 成为…动机/促进/激励motion (动) 运动/手势motor (使移动东西) 发动机To be promoted is an emotional motive for a demoted person in a remote village. sist 站assist (站着听命令) 帮助/援助persist (一直站着) 坚持/继续存在consist (站在一起) 由..组成/存在于insist (站在里面) 坚持/简称resist (站在相反立场) 抵抗/反抗He insists that persistence consists in an irresistible assistant. spr 散开spray 喷洒/扫射sprawl 蔓延/伸开四肢坐/躺spread 蔓延/扩散sprinkle 撒/洒/用…点缀spring 泉水/春天sprout 发芽/毛发长出 stitute 站/放institute (在大楼里) 学院/制定/创立constitute (放在一起) 组成/构成destitute (站在社会下层) 贫穷的prostitute (站在街道前) 青楼男子(女子)substitute (放在后备箱下) 替代(品)A group of destitute prostitutes constitutes an non-substitutable institute. sign 标记/签名sign 签名/签署/迹象/征兆signature 签名significant 重要的/有意义的signify 表示/象征signal 信号assignment 任务assign 布置/委派resign 辞职consign 把…委托给design 设计The signal and sign of Jony’s resignation signifies that Apple must consign the significant designing assignment to other people. spect 看prospect (向前看) 前途/前景respect (再次看) 尊重/尊敬expect (往外看) 预期/期待/期望inspect (往里看) 检查/视察/检验suspect (向下看) 怀疑/嫌疑犯The suspect expects that the inspector can respect his prospect. vok 喊 (voice)provoke (向前喊) 激怒/激发/引起evoke (喊出来) 引起/唤起revoke (喊回来) 撤销/撤回advocate (喊) 提倡/倡导/主张The revoked proposal evokes and provokes the advocate’s dissatisfaction. serve 保reserve 保留/预定/预约preserve 维护/保存/保持conserve 保存/节约/节省observe 观察/遵守/遵从deserve 值得/应得/应受The observers say that the preserved and reserved cultural heritage deserves better conservation. tribute 给contribute (全部给) 贡献/导致distribute (分给) 分配/分发attribute (成功给) 归因于The distributor attributes his success to his mother’s contribution to him. priv 单个private 私人的privillege 特权deprive 剥夺He was deprived of the privilegeof using a private plane. mit 发送submit 提交/屈服/服从commit 犯罪/使自己致力于/承诺permit 允许/许可transmit 传播/传输/传递admit 承认/准许…进入emit 发出/散发emission 排放/散发 struct 建造structure 结构/构造construct 建设/建造/构建destruction 破坏/毁灭instruct 指导/教导obstruct 阻塞/阻拦/阻挠 volv 转/卷involve 卷入/涉及/包括/使参与evolve 进化/演化/逐步发展revolve 旋转devolve 转交/转给convolve 使卷曲/使缠绕intervolve 互卷/互相牵连 dict 说dictionary 字典addict 使上瘾/使沉溺/上瘾者contradict 反驳/与…相矛盾predict 预测indicate 暗示/表明/显示dedicate 致力于/奉献indict 控告/起诉 hibit 拿exhibit 展览/展出/表现/显示prohibit 禁止/阻止inhibit 抑制/阻止An illegal exhibition is inhibited and prohibited. pel 推expel 逐出/驱逐/开除propel 推动/推进compel 强迫/迫使dispel 消除impel 迫使/促使repel 击退/打退/厌恶 fer 带confer 商讨/商议prefer 更喜欢/偏好differ 不同/有区别transfer 转变/转会infer 推论/推断refer to 提及/谈及/涉及suffer 遭遇/经受","link":"/2022/10/26/zh/english/root_words/"},{"title":"Redshift 调节色温","text":"前记最近看电脑时间越来越长，电脑的光太刺眼了，眼睛很不舒服，所以搜了下 Linux 下可以使用的色温软件，找到了这两款软件： F.lux：It makes the color of your computer’s display adapt to the time of day, warm at night and like sunlight during the day.（官网 | Github） Redshift：It adjusts the color temperature of your screen according to your surroundings.（官网 | Github） 它们都支持 Windows 和 Linux。 以前在 Windows 用过 F.lux，所以这次先试了它。可能是白天测试的原因，没有色温变化，而我想要白天夜晚都可以控制色温的，所以放弃了 F.lux。 Redshift 在简单的安装后就能使用了，挺方便的，所以设置为了开机自启，以下是安装过程和设置过程： Debian 安装1sudo apt-get install redshift 配置切换到 ~/.config 目录下，并新建文件 redshift.conf，配置内容如下： 1234567891011121314151617181920212223242526272829[redshift]; 白天屏幕温度temp-day=5800; 夜晚屏幕温度temp-night=4600; 昼夜是否平滑过度(1/0)transition=1; 全局屏幕亮度;brightness=0.9; 昼夜屏幕亮度(version &gt;= 1.8)brightness-day=0.9brightness-night=0.7; 屏幕gammagamma=0.9; 位置提供方式(redshift -l list)location-provider=manual; 调整工具(redshift -m list)adjustment-method=randr; 屏幕调整工具设置[randr]; 第1 块屏幕(0)screen=0[manual]; 位置提供方式设置; 经纬度(北京)lat=39.90lon=116.41 开机自启切换到 /etc/systemd/user 目录下，新建文件 redshift.service，配置内容如下： 12345678910111213[Unit]Description=Redshift display colour temperature adjustmentDocumentation=http://jonls.dk/redshift/After=display-manager.service[Service]Environment=DISPLAY=:0ExecStart=/usr/bin/redshiftRestart=alwaysRestartSec=20[Install]WantedBy=default.target 对于新创建的 unit 文件或修改了的 unit 文件，要通知 systemd 重载此配置文件： 1systemctl daemon-reload 然后以用户级别启动开机自启服务： 1systemctl --user enable redshift.service 开启/停止/重启像其他用户服务一样使用： 开启：systemctl --user start redshift.service 停止：systemctl --user stop redshift.service 重启：systemctl --user restart redshift.service Arch 安装Arch 就更简单了，直接 sudo pacman -S redshift 即可，而且有图形化界面，除了上面的配置外其他的直接通过按钮即可开启。","link":"/2018/04/15/zh/others/redshift_adjusts_the_color_temperature/"},{"title":"V2ray + Cloudflare 拯救被墙 VPS IP","text":"前记前几年买了搬瓦工的一台最便宜的 VPS，大概一年120元，期间试过 Shadowsocks，V2ray，目前稳定在 V2ray + Cloudflare。 VPS IP 早几年就被 the great wall 封了，所以才用了 V2ray + Cloudflare 方案，不定时还要更新 CDN 的 IP，不然也会有被屏蔽的麻烦。 搬瓦工的官网需要翻墙才能上，安装完系统也要翻墙，所以先找个免费的限时 VPN 挂着。 VPS 安装 V2ray 脚本 Cloudflare CDN IP 测速脚本 Cloudflare CDN IP 测速脚本2 Windows 客户端 Android 客户端 系统安装VPS 配置： 500G 免费流量，满足日常需求。 系统 Centos 7 BBR，直接在控制面板安装即可。 准备域名 到 Namesilo 买一个最便宜的，名称最好不要带什么侮辱单词或者变形的，不然还会被墙。 到 Cloudflare 解析刚才买的域名：添加二级域名A记录解析到 VPS IP，让小黄云变灰色 DNS only。 回到 Namesilo，修改域名 DNS 服务器为 Cloudflare 的信息。 安装 V2ray连上 VPS 一键安装 Vmess + websocket + TLS + Nginx + Website： 1yum update -y &amp;&amp; yum install curl -y &amp;&amp; bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) 域名填刚才在 Cloudflare 解析的二级域名； 端口不要用443，换成其他的； 记录下安装好的 Vmess 链接。 检查是否运行正常： 12systemctl status v2raysystemctl status nginx 两个都显示为绿色的 active(running) 则说明运行成功。 使用打开客户端，粘贴刚才记录的 Vmess 链接。 使用 Cloudflare CDN IP 测速脚本选择速度快的 IP，填到地址(address)中。 done，尽情翻吧~","link":"/2022/10/12/zh/others/v2ray_cloudfare_save_ban_ip/"},{"title":"实习心得","text":"前言实习正好一个多月，现在回顾一下这一个月都干了什么收获了什么。 第1星期第1星期主要是上级校验我动手做东西的能力。 头2天熟悉公司的规章制度，接下来就分派下了一个仿照现有功能的任务，包括前后端。要求在第一个星期内完成，也就是我需要在剩余的3天半内完成，本来认为任务挺简单的，数据库，现成 Demo 也在，除了任务描述的不是特别清晰外，其他都自我感觉良好，然后就开启了趟坑之路。 后端问题技术栈要求：Struts2、Spring、Jdbc。 因为没用过 Struts2，所以经过和上级协调后我换成了 SpringBoot + JdbcTemplate。（要及时与上级沟通） 数据库是 Oralce 的，但以前没有用过，而且 Maven 怎么也下载不了 Oracle JDBC 的驱动，经过一番折腾后写出了这篇笔记：使用 Docker Oracle。 关于 JdbcTemplate 的使用参考了 Spring JdbcTemplate方法详解，在本任务里就是单纯的查询结果集。 值得注意的是对结果集的操作，如果查出来的是实体，可以直接使用 new BeanPropertyRowMapper(Bean.class)，比如 jdbcTemplate.query(FIND_ALL, new BeanPropertyRowMapper(MemberBean.class)) 避免对 resultMap 一个个地进行映射。 基本上后端搭建方面就是上面的两个问题，以下是关于业务方面的问题解决。 业务问题 一开始因为不会树查询，所以在看完表结构后做成了由 Java 控制的递归查询： 1 一级义工分会：跳过 2 一级服务总队：向上 SELECT 一次 WHERE id = parentId 3 二级义工分会：~2次 4 二级服务总队：~3次 5 基层义工组织：~4次递归查询上层机构，最后按 List 输出。 在查询的机构比较靠上层，以及机构数据量不大时，上面的递归查询时间还可以接受，但是数据稍微多点就异常缓慢，甚至让人觉得卡顿。在咨询了上级后才知道还有树查询这种方法，搜索后发现了一篇比较好的关于 Oracle 树查询的文章。（请教经验丰富的上级，得出相关的解决方法） 同样的还有下面这个，也是树查询解决： 照葫芦画瓢，写出了这样的查询语句： 1234SELECT dept.name, dept.id, dept.parentId, LEVELFROM YG_DEPT_T deptSTART WITH dept.id = 1CONNECT BY dept.parentId = PRIOR dept.id 结果证明，查询速度比原来的方法快多了。 其他关于前端控件的问题，基本按照文档说明即可解决。 总结第一个星期接触到了 Oracle 数据库，搭建过程中加深了我对 docker 的使用印象，业务上的树查询也让我认识到了自身对数据库的熟练度还不够的问题，需要加强练习。 任务在星期四下午就完成了，上级对完成速度、功能完整度以及额外完成的导出 Excel 功能都比较满意，也算是对自己的认可了。 接下来的一天多时间里，在得到了经理的允许下，把电脑换成了 Linux，看了几篇关于 SpringCloud 的文章。 第3-4星期第2星期前4天完成了几个关于 SpringCloud 组件的使用及 Demo，写了相关的笔记：SpringCloud。 然后星期五上级就分派了一个移动端的子模块开发任务给我，原本是想让我前后端都进行做的，但因为原型问题，以及我表达了对前端并不十分熟练的问题后，我的任务就变成了纯后端开发。 第3-4星期这期间，我主要就是和原先 PC 端的同事进行交流，对接业务逻辑，编写业务代码和相关的文档接口，编写时用到了 Java8 的函数式编程思想，基控制器的装饰器模式，以及熟练了 MyBatis。 第5星期第5星期基本的接口都已经写完了，前4天主要是写单元测试，和完善整个接口文档中的业务流程。在接近尾声时也让上级看了下我上面写的 SpringCloud 笔记，所以估计接下来的几天里要搭建好 Spring Security OAuth2 的 Demo。 总结这一个月里主要的收获就是折腾出了使用 Docker Oracle。以及 SpringCloud 相关的笔记：SpringCloud，熟练了 Java 开发部署流程，加强了与团队的沟通配合能力。","link":"/2018/06/22/zh/work/internship_experience/"},{"title":"IELTS","text":"考试形式口语：12分钟左右。考试采用一对一的面试形式，考察考生日常会话、对熟悉话题作一定长度的描述以及与考官之间的互动能力。 Part 1：一般3.5分钟 Part 2：一般3.5分钟，半分钟念考题，1分钟准备，1-2分钟作答 Part 3：一般5分钟。Part II考完马上进入Part 3，考官可能会问你6-8个问题 听力：30分钟听4段录音，每段10道题，共40道题，难度递增。前3段录音分两次听完，段内（第1-3篇）会给两次读题的机会（没仔细算过，可能是30秒左右），一段听完会有30秒时间检查答案。录音只听一遍。全部4段听完有10分钟抄答案，听力共40分钟 阅读：60分钟读3篇文章，共40道题（14+13+13），难度递增。考试的文章以英语国家日常生活素材为基础，可能从报纸、广告、说明书及书籍中摘取，考察考生对信息的理解及运用的能力。试题包括一篇较长的描述性、而非论证性的文章。 写作：60分钟写2篇文章，一篇小作文（20分钟，&gt;150词）和一篇大作文（40分钟，&gt;250词）小作文要求考生写信，询问信息或解释一种情况；大作文要求考生根据所给出问题或观点写一篇大约250字的短文，考生要求能够使用恰当的语气和语域（包括词汇、语法等）表达自己的观点，并反驳其他观点。","link":"/2022/10/25/zh/english/ielts/ielts/"},{"title":"同义替换","text":"resemblelike / look like / be similar to similarresemble / like / compare recognizeperceive / acknowledge / realize / appreciate / admin / identify / comprehend / understand / know / aware / conscious consciousaware / intended adjustchange / modify / shift / alter approachmethod / way / how fundamentalrudimentary / preliminary / basic rely ondepend on domestichome / local / national measurecalculate / evaluate / assess traitcharacteristic / feature / property coinfirst used / create / invent establishconstitute / build / create / construct / set up / install artificialsynthetic / man-made promptimmediately / motivate motivateactuate / drive / stimulation / encourage / stimulate / keep active / boost / help / inspire / egg on / persuade exchangeshare / swap over / replace / switch over underliebased on / ground / root radicalutmost ignoreneglect / overlook / underestimate viewhorizon / overlook fertilizerchemical / toxic / unnatural rather thanbut / yet / however / whereas / nonetheless / nevertheless / not with standing / although / though / instead of ratherfirst / prefer to / would rather andas well as / and also / with / in addition thanks tostem from / derive from / owing to / due to / according to / because of / on account of / as a result of / leading to / because / since for / in that / as / therefore / hence becausewhy / as a result / therefore / cause resultoutcome / consequence / conclusion diversitydifference / different / various / a variety of / a number of / a range of detectlook for / find / seek / search trackwhereabouts / trace tracefind / detect finddetect / discover / spot / see / sight isolateinaccessible / unable to get avoidescape / evitable apply … to …use for offsetmake up / counterbalance / compensate alternativesubstitute fitsuit / adapt to feemoney / cost / price / expense / budget / fund / financial / economic\\ monetary / capital deriveoriginate provisionpreparation / arrangement / supplement / recruitment imitatesimulate / mimic / aper / copy plagiariseplagiarize / copy copycounterpart / repeat / reproduce massivehuge / extensive / large / big / enormous / tremendous tremendousswingeing / vast focus onbe centered on / stress / emphasize / highlight / heat diagnosetell / analyze / detection / examine distinguishtell apart / differentiate militarymartial / battle / weapon / not peaceful defectdeficiency / disadvantage / weakness / shortage / drawback / shortcoming / problem / negative lackfail / shortage / insufficient / fewer / not enough constrainchain / bound / control / limitation / restriction / curb / qualification restrictblock / limit / not permit curriculumcourse / syllabus standardbenchmark / criteria regulationsupervision / rules / criterion / norm impairhurt / break / damage determineconclude / decide resistancerebellion / immunity / resistivity minimizeminish / diminution / reduce / micrify chronicstanding / extend / lasting wholesomehealthy / good / beneficial / useful / advantageous / helpful well-beinghappiness / felicity / health fitnesswellness / adaptability / health / medical / gym advantagemerit / benefit / positive / good thing / strength accelerateimprove / speed up promoteadvance / lift / improve / develop enhanceimprove / increase / boost soarsharply / ascend / increase climbraise / scale / go up / increase conventionusage / institution / conference / tradition traditioncustom / convention / local culture / lifestyle legallegitimate / lawful / law / reasonable / logical obstacledam / barrier preventblock / impede / avoid / stop / forbid / out of bounds / hinder / deter prohibitprevent / not allowedimperativenecessary / essential / urgent / inevitable / certain magneticgeomagnetic / attractive principlemechanism / rule principalmain / chief / supreme / primary / elementary paramountmain / principal preferencetendency / favour / priority / like / precedence lossfailure / losing / gone witnessproof / watcher / view secrete分泌/隐匿secret秘密excrete / discharge / exude / steam / shed / issue inheritsucceed to / receive optionelection / choice onlymerely / unique / exclusive / particular extinctderacinate / die out exaggerateenlarge / broaden / overstate potentialfeasibility / maybe / possible / possibility transmitsend / communicate transfermove / relocate transporttransit / carriage / send / vehicle / bus / train / boat / ship / ferry / subway migratetransplant / move quantitywealth / volume / number attemptsample / essay / try peripheralambient / circumjacent / unimportant environmentcontext / circumstance / surrounding / neighbourhood / vicinity / setting / installation mortalitydeath rate stimulusincentive / spur / animation / excitement / motive / goals dynamicsmechanics / kinetics / move contributedonate / endow / charity / give / subscribe expertiseprofessional knowledge / skill / ability settleschedule / arrange / fix unexpectedlyaccidentally / precipitously / surprising swiftrapid / fast / quick surviveoutlive / remain particularextraordinary / special / detailed / especially specificprecise / decided / detailed / particular / example complicateexacerbate / sophisticate / entangle detailedstrict / particular co-operationcollaboration / synergism / work together fragiledelicate / crumbly / vulnerable / sensitive / assailable delicatefragile / subtle fairexpo / exhibition / impartial / equal / equivalent / even / unbiased evenfair / really / yet integratecomplete / gleichschaltung / combine inducecause / attract / lead to erodeweather / eat into / damage deliverypost / handing over / send vanishblank / disappear stableconstant / steady / unchanged haltrest / stand / stop co-ordinateharmonize / co-operate harmonizeaccord / unify / reconcile abandondesert / quit / give up retainkeep / maintain signalsign / mark / symbol / indication cluecue / action / plot / hint / connotation / reminder / imply / implication plotaction / conspire / plan differdivide / vary organizestructure / form / arrange / plan organizationcommunity / business / company / corporation / structure formationconstitution / fabric / layout / structure / pattern structureoutline / framework grantaccept / agree / offer / confirm / uphold / authorize authorityjurisdiction / rod / government officialformal / state / authority concuraccept / identify / agree boundaryregion / territory / barrier barrierblock / bottleneck / boundary blightdesolation / undermine / founder / destroy toleratestomach / stand / abide / bear patienttolerant bearsupport / tolerate compatiblecompossible / well-matched be consistent withtie in with / fit in with / in accord with attitudeviewpoint / behavior / opinion altituderaise / elevation / height arrayseries of / order accumulatestore up / gather associationalliance / society / union applicationadhibition / utilization utilizationemployment / usage / exploitation / application allergicsupersensitive / anaphylactic / hypersusceptible / irritable / can not eat aidassistance / friend / help supportencourage / facilitate / help / assistance / aid / tip aggressionviolence / invasion / infringement / attack adversitydisaster / tragedy / trouble addictiveacquired / habit agreeablelovely / grateful / pleasant bunglefailure / losing / mishandle handleoperate / exert / deal with / cope with / figure out / work out / take care of engagementdate / contract / commitment commitmentassurance / guarantee / engagement guaranteecertification / warranty / assure / undertake confusecloud / discombobulate / puzzle puzzlebaffle / discomfit / confuse conferafford / award / grant concentratecentre / localise / focus conceallock / pocket / hide obscuredark / overcurtain / hide / covert contrastparallel / differential / compare / contradistinguish / match / parabole communalcommunity / communist / public burdenliability / weight / load obligationliability / goal / responsibility responsibleaccountable / liable commentopinion / judgement / thinking / remark commuteexchange for / travel civicmunicipal municipalcommunalistic / civic capacitycompetence / ability / volume / room / space / size facultycapacity / ability volumebulk conflictinterference / battle / collision / unharmonious certifyseal of / evidence / verify caterhumor / serve catastrophicmiserable / calamitous / disastrous / tragedy / meltdown devastatewreck conservativestandpat / backward-looking / traditional crisisrisk demographicpopulation statistic democraticrepublic postponedelay deadlinelimit / time pressure / on time dazzleunclear / flash dampwet criticismcondemn convictionguilty credibilityreliance collapsecrash correlationlink controversialdisputed / questioned contingentoccurrent / chancy / uncertain dentalteeth depressionfrustration distributespread illustrateelaborate eco-friendlyenvironmentally-friendly dramaticstriking dominantoverbearing domainfield durablelasting / stronger / longer documentationrecord divertdistract displayshow disparatedifferent exposedisclose detainhold disruptdestroy designateappoint elderlyaged eliminatedispose evolveprogress / develop strideevolve / progress quotationciting / citation / extract extractabstract / quotation extendfinger / expand expandadd / enlarge / increase / spaces explicitprecise / decided / clear cleardefinitive experimentproof / test proofevidence / testimony fatiguetiredness / weariness / exhausted / frazzled exploituse / develop exceptionalespecial / extreme / utmost extremeultra / excessive / utmost elusivehard estatereal estate / property moralethical eventuallyfinally equatorgeology geologygeologic map / cliff / fossil / rock / landscape entrepreneurboss encyclopaediaentire range of knowledge faminefames / hunger erraticallyunpredictably finitenarrow / limited limitedfinite / just a few / a little / small / a small number of / not many / miniature harbourhaven / hold inaccuratefalse / improper / incorrect conformreconcile / in accordance with / in line with / according influenceinfection / impression / impact / effect impressiveaffecting / touching assumptionconception / perhaps / hypothesis / tentative hardshipaffliction / bitterness / difficult difficulttough / problem / hard / not easy / not simple habitatlive / territory / home / production place / residence fitnesswellness / adaptability / health / medical / gym graphiciconic / picture harshsevere / rough giftedcapable / talented genehereditary factor / nature / factor executeperform / implement / enforce / carry out fulfillaccomplish / come true / realize / execute fragmentdebris / piece foeanti / opponent / enemy hostileopposed / enemy / offensive offensiveevil / rank / hostile inactivelazy / passive freezerigidize / chill / froze / ice / cold inappropriateinadequate / hard involveconcern / associate / relate to / connect / link opportunityoccasion / opening / chance / odds / hope look-inchance of success / chance logpage / register / record limbextremitas / arm or leg likelihoodfeasibility / probability / possibility landscapeview / picture / scene linguisticphilologic / language keenenthusiastic / strong introvertedshyness interiorinner indulgefulfill / acolasia / spoil spoilharry / indulge interruptstop labelticket / tag / mark / display interferenceintrusive / interdependence interactionsocial activities intensetense / strong intelligencementality / mind mentalspiritual / inner / intelligent plaguecause trouble / disease infestharry / plague / parasitize = parasitise lopsidedimbalanced / uneven installmenthire-purchase / payment on its completion mainlybasically / mostly / primarily nocturnalnightly / night mouldpattern / matrix / form themetopic / subject / motif surveillancesupervision / observation / monitor / detectophone / invigilator nativecrude / inherent / original moisturerainfall / humidity meteorologicalaerography / weather malfunctionget out of order / breakdown mercuryenergy / liquid metal mechanismtheory / machinery / method spousemateship / courtship matefellow / friend / peer marinenautical / sea manifestindicate / prove / obvious manage to doaccomplish / achieve / success / contrive mammalsuckler / animal animalcreature / mammal / wildlife / species notorietyinfamy manufacturemachining / process / produce yieldproduce / succumb producemanufacture / yield / generate / make objectiveintention / purpose / target / goal / aim / key areas overcomeexceed / surmount / defeat persuadeprevail on / convince permitallow peakmountaintop / top participatetake part in / join paralyseanaesthetize / cannot move surpassexceed / overtake / catch up / transcend / excel more thansurpass / beyond / over / exceed / above optimumgreatest / only / best impossibilityout of the question organmachinery / apparatus / a part of a body ordinaryusual / general / common oddremaining / strange / bizarre / suspicious obtainacquire / earn / get pessimisticgloomy / negative odourwind / smell phaseaspect / process rateprice / rank / measure raretenuous / unusual uncommonunusual / special / unique / rare scopelimits / range rangerow / scope qualifyfulfill purifyclean prospertriumph / success prolonglengthen / extend privatebackroom / personal physicalmaterial / body pressingimpending / urgent predictanticipate / expect praisecomplimentary / commend povertypoor poorweak portableman-carried / conveyable plenty oflots of / many / a great deal of / large quantities of / loads of reactbear on / respond posecause respondanswer / react / reply / feedback solicitorattorney / lawyer solelyall alone / only shelternook / shade / shadow scenicgraceful / beautiful ruindestroy skepticismdoubt revisionrectify / editing reproducemultiply / breed recreationpastime / entertainment entertainmentamusement / recreation / leisure reluctantgrudging / unwilling revivevivification relativeopposite / relevant excludereject religiouspious / sacred refer toconsult / talk about reductioncut / decrease / curtail / lower / fewer / drop / fall shortenweaken / cut down steerdrive / manage rehearsaldry run / preparation supremacysovereign / paramount / priority throughoutend-to-end / anywhere termsemester / word tensionnervous / upset symptompremonitor / indication / sign tollring / charge suppressinhibit / hold replacesupplant / supersede / displace sustainablecontinuable / long-term sufficiencyadequate / enough substancematter succumbsurrender / yield subdividebreak down triggertriggerhappy / begin tropicalintertropical / hot uniformunification / consistent valuableworthiness versatilevarious / all-around visiblevisual / view / see / image visualizeimagine violentimpetuous / fierce innateinherent / intrinsic / inborn consulttake advice / ask for advice obeycomply / comply with / observe confidentialclassified / secret / undisclosed initialpremier / original / at first / start / begin / early on therapycure / treatment cognitiverecognitive / epistemic / mental patternmanner / mode endangerjeopard = jeopardize / threaten / cow hazardventure / risk / throw jeopardizeharm / compromise / endanger be liable tobe apt to microbebacterium / organism / germ germseed / plantule / bacteria / virus be subject tosuffer / face superiorranking / upper / lofty practiceconvention / execute / exercise reservebook emigratemove / go away statuesculpture / carving artworkillustration / art / painting / drawing / craft jewelleryrings / bracelets / precious stones / gem / diamond / luxurious publicitywebsite / media / news / marketing onlinenet / internet / website presspush / news / media / newspaper / radio picturephoto / photograph / camera / image foodfeed on / eat vegetationplant / tree / forest / botanic exportoutput / abroad / overseas internationalcountries / continents / global in advancepreviously / ahead / before moviecinema / film / documentary studentscholar / academic / pupil / undergraduate / postgraduate learnacquire / get / obtain educationcultivation / training / schools / colleges / institution remotedistant / isolated nearclose / not far from / nearby accommodationresidence / living / dwelling / dorm outdoorgardens / park / open air noisyfurious / boisterous / not quiet / disturbing placedistrict / where / spot / location / area coastlineshoreline / shore / seaside urbancity / metropolitan countrysiderural area / village omitleave out / cancel doubledual / twice majoritymost minimumlowest / at least maximumup to / at most rigorousrigid / precise idealdream / full / perfect analysisperspective / understand / perceive / know affectimpact / influence / effect misunderstandwrong idea / confuse / puzzle / perplex behindwith / back / rear injuryharm / damage / hurt / dangerous / frighten protectsecure / watch / preserve / safeguard / shelter stealscrump / theft warningadmonition / alarm / alert poisonoustoxic / dangerous riskycritical / perilous / dangerous / not safe / hazard trendpossibility / likely / tendency caretend / think of / caution besidenext to / near / border belowdown / under entrancethreshold / portal / access / main gate / door boringtrying / frivolous / not interesting / boredom classifyvariety / kind / category / sort / type every daydays / daily every monthmensal / monthly / four weeks annualyearly / every year at presentfor now / already / exiting / currently / nowadays permanentlong-lasting temporaryextraordinary / interim / a short time ancientadvanced / aged / medieval / in the past / once / historical / old / former more oftenvery often / frequent soonlater newestmodern / latest updaterenovate / refresh / more current / upgrade / modern out of dateobsolete / outmoded / old fashioned tacticsstrategy / method well-knownproverbial / famous / fame depressdeject / discourage / disappoint / dispirit / frustrate shape likeseem like / look like / seem aloneindependent / single / by themselves renovaterestore / fix / repair orderregulation / sequence roundcycloidal / crooked / curve hospitalitytreatment / prepare / refreshment cheaplow price salemarketing / sell / retail staffoffice clerk / recruit / worker / employee youthyoung / boy / child / teenager discount10% off / on sale all agesyoung and old occupationemployment / career / profession / job workjob / item administermanage rely ondepend on / count on requestask for / inquiry space travelaircraft / rocket / satellite traveltourism / trip / passenger / flight specialize inmajor in / focus / emphasis / concentrate assignportion / part / allocate partportion / component / proportion / percent / section / element / ingredient proportionfraction componentelement importantcrucial / significant / major / main / primary / considerable / material pollutantcontaminant informationdetails / data / graph / chart statisticnumerical statement / data / figure turnswitch repetitionover and over viableworking / feasible / realistic / practical availablehave / accessible / open disusedantiquated / empty / abandoned straightforwardupright / simple / direct / first-hand demonstratedisplay / show / exhibition typicalrepresentative / common / average computerlaptop trustless suspicious / believe refurbishrepolish / redecorate handyquick / convenient powerforce / energy fuelcatalyst / elding / coal / firewood / petrol / gas / gasoline continueahead / go on / keep doing accuratelyexactly / true / precisely","link":"/2022/10/26/zh/english/ielts/replace_words/"},{"title":"BT","text":"BT 站点the pirate bayproxyrarbg Tracker 加速每天更新：精选列表完整列表HTTP(S)列表 为什么下载速度慢因为 BT 下载文件全都是其他用户上传给你的，所以 BT 下载速度就等于其他用户的上传速度。链接到的做种上传用户越多，你的下载速度就越快，而用户通过 Peer、DHT、Tracker 获得。 Peer：在获得一个有效用户后才会起作用，该用户会把它知道的其他用户信息告诉你。 DHT Peer：加强版，分布式储存用户信息，获得用户的效率更高，但需要下载热门资源来养。 Tracker：记录所有正在上传/下载同一资源的用户信息并提供给你，帮助你与其他用户建立连接。 因此，想要下载速度快，就要找到更多用户，但前提是有用户，否则总不能凭空制造用户、凭空下载文件是吧。注意 BT 只适合下载热门资源，对于冷门资源，再怎么折腾都没啥用（毕竟 Peer、DHT、Tracker 都只是起到辅助作用），因此没速度的话，还是建议去找找其他种子、网盘什么的碰碰运气，不要在一棵树上吊死~ 另外，不仅要关注用户数量，还要关注用户质量，因为国内绝大部分家庭宽带都没有公网 IP，因此上传速度比较捉急，另一方面也是运营商上传不对等，还老是干扰 BT、限制 UDP 协议，这也是国内BT环境这么差的主要原因之一。 申请不到公网 IPv4 的用户，建议改用 IPv6（这个都是公网），也能有效提高下载/上传速度。 迅雷会员加速的本质就是解除连接用户限制，让你可以连接到更多的用户，来 有效 提高下载速度。 迅雷之所以叫吸血雷，是因为 迅雷一边吸取其他 BT 软件用户上传速度，一边却屏蔽其他 BT 软件，只把上传速度提供给其他迅雷用户 ，所以对于其他客户端来说，迅雷只进不出，俗称吸血雷，长此以往形成恶性循环，用迅雷的人越来越多，其他 BT 软件下载速度越来越慢。 为什么有些 Tracker 不回应这是很常见的情况，很多因素都会导致这种情况的出现。 首先，目前热门 Tracker 基本都是国外服务器（毕竟国内要备案），因此可能会出现链接问题。（一般 HTTPS 的链接成功率更高，HTTP、UDP 这种明文的容易被运营商干扰、屏蔽。其次，一些 Tracker 域名/ IP 可能被你当地运营商屏蔽了（特别是移动这个问题比较严重）。相应，一些 Tracker 服务器也可能屏蔽了 国内用户 / 你的 BT 软件（这就要问问迅雷了）。最后，一些 Tracker 服务器没有你当前正在下载资源的相关信息。不过也不用担心影响 BT 软件，毕竟 BT 软件重试几次就会忽略了（多线程）。","link":"/2022/10/10/zh/hardware/nas/bt/"},{"title":"Windows Nas","text":"前言闲置的旧笔记本装了 Windows Sever 2019 做 Nas，当一个过渡产品，看看 Nas 是否真的是自己的刚需。 项目仓库","link":"/2022/10/10/zh/hardware/nas/windows_nas/"},{"title":"三极管控制散热风扇","text":"前言风扇直接连阵脚会一直转，加个三极管，可以通过脚本控制开关。 硬件准备散热风扇、三极管（S8050）、母对母杜邦线 风扇：风扇红线接5V、黑线接地。 三极管：把平的那面对准自己，三个引脚分别是 E、B、C。分别是E发射机、B基极、C集电极。可以理解为E极是正极、C极是负极、B极是信号极控制是否通电。和二极管一样，正极接电源正极，负极接电源的负极。 接线方式 风扇红线 接 树莓派5V，比如：04号引脚。 风扇黑线 接 三极管C。 三极管E极 接 树莓派0V，比如：06号引脚。 三极管B极 接 GPIO，比如：08号引脚。 Python 控制脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/env python3# -*- coding: utf-8 -*-import datetimeimport osimport timeimport RPi.GPIO as GPIO# GPIO14 08号引脚GPIO_OUT = 14# 日志位置LOG_PATH = '/tmp/fan_control.log'# 调试模式IS_DEBUG = Falseclass Fan: def __init__(self): # BOARD编号方式，基于插座引脚编号 GPIO.setmode(GPIO.BCM) GPIO.setwarnings(False) # 设置08号引脚为输出模式 GPIO.setup(GPIO_OUT, GPIO.OUT) &quot;&quot;&quot; 读取 CPU 温度 &quot;&quot;&quot; def read_cpu_temperature(self): with open(&quot;/sys/class/thermal/thermal_zone0/temp&quot;, 'r') as f: temperature = float(f.read()) / 1000 log('DEBUG', 'Current CPU temperature is {}'.format(temperature)) return temperature &quot;&quot;&quot; 启动风扇 &quot;&quot;&quot; def start_fan(self): log('INFO', 'Power on') GPIO.output(GPIO_OUT, GPIO.HIGH) &quot;&quot;&quot; 停止风扇 &quot;&quot;&quot; def stop_fan(self): log('INFO', 'Power off') GPIO.output(GPIO_OUT, GPIO.LOW) &quot;&quot;&quot; 控制风扇 &quot;&quot;&quot; def control_fan(self): # 标记风扇开关状态 is_closed = True try: while True: temperature = self.read_cpu_temperature() if is_closed: # 温度高于50°即启动风扇 if temperature &gt;= 50: self.start_fan() is_closed = False else: # 温度低于45°即停止风扇 if temperature &lt;= 45: self.stop_fan() is_closed = True # 每10s检查一次 time.sleep(10) except Exception as e: GPIO.cleanup() log('ERROR', e)&quot;&quot;&quot;日志:param level 级别:param msg 消息&quot;&quot;&quot;def log(level, msg): log_msg = '{} [{}] {}'.format(datetime.datetime.now(), level, msg) if not IS_DEBUG and level == 'DEBUG': return try: with open(LOG_PATH, 'a') as f: f.write(log_msg + '\\n') except Exception as e: print(&quot;Unable to log: {}&quot;.format(e))if __name__ == '__main__': os.environ[&quot;TZ&quot;] = 'Asia/Shanghai' time.tzset() log('INFO', '[*] Started') Fan().control_fan() log('INFO', '[*] Quit') 为了实现开机自动运行，可以把启动脚本写在rc.local中","link":"/2018/07/21/zh/hardware/raspberry/triode_control_cooling_fan/"},{"title":"AI 绘画","text":"AI 作图的方向不错，目前想到图片/音乐这类都是无国界的，全世界都能传播。 数据来源：商业画手（版权问题，不过只要数据量足够多，很难去人工识别哪些部分是来源商业的）CC免费（质量不高，可以考虑） Stable Diffusion Web UI Stable Diffusion Text-to-Image 高分辨率图像合成 BLIP: 用于统一视觉-语言理解和生成任务，生成图像标注 腾讯模糊照片修复 泄露的 NovelAI 模型 NovelAI 使用stable-diffusion-webui部署NovelAi/Stable Diffusion1.4 /1.5保姆级教程、命令解释、原理讲解(colab、windows、Linux ) - SeASnAkE的文章 - 知乎https://zhuanlan.zhihu.com/p/574200991 复制或移动下载好的NovelAI模型到项目文件夹 stable-diffusion-webui复制GFPGANv1.4.pth 到 stable-diffusion-webui 根目录。 复制novelaileak\\stableckpt\\animefull-latest\\model.ckpt 到 stable-diffusion-webui\\models\\Stable-diffusion目录下，并改名为final-pruned.ckpt, 可能有同学会问，为什么是这个模型，我只能告诉你，这是成年人的快乐 ：）。 复制novelaileak\\stableckpt\\animefull-latest\\config.yaml 到 stable-diffusion-webui\\models\\Stable-diffusion目录下，并改名为final-pruned.yaml。 复制novelaileak\\stableckpt\\animevae.pt 到 stable-diffusion-webui\\models\\Stable-diffusion目录下，并改名为final-pruned.vae.pt。 复制novelaileak\\stableckpt\\modules\\modules下的所有文件 到 stable-diffusion-webui\\models\\hypernetworks目录下，如果hypernetworks目录不存在，新建文件夹即可。","link":"/2022/10/15/zh/programing/ai/painting/"},{"title":"计算机网络","text":"网络的网络 网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商（Internet Service Provider）拥有通信线路以及路由器等联网设备，可以从互联网管理机构获得许多 IP 地址。个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。 互联网交换点（Internet eXchange Point）允许两个 ISP 直接相连而不用经过第三个 ISP。 互联网的组成 边缘部分：所有连接在互联网上的主机，用户可以直接使用； 核心部分：由大量的网络和连接这些网络的路由器组成，为边缘部分的主机提供服务。 主机之间的通信方式客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 浏览器-服务器（B/S）：浏览器是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务器。 电路交换、报文交换、分组交换 电路交换 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 报文交换 报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。 分组交换 分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。 存储转发允许在一条传输线路上传送多个主机的分组，也就是说两个用户之间的通信不需要占用端到端的线路资源。相比于报文交换，分组比报文更小，因此分组交换的存储转发速度更快。 时延总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 发送时延：主机或路由器发送数据帧所需要的时间。 传播时延：电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。 处理时延：主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据部、进行差错检验或查找适当的路由等。 排队时延：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 计算机网络体系结构 各层对应的网络设备 中继器、集线器 &gt; 物理层网桥、交换机 &gt; 数据链路层路由器 &gt; 网络层网关（不是设备） &gt; 网络层（常见） 数据在各层之间的传递过程 在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 数据链路层CSMA/CD 协议 CSMA/CD 全称：载波监听多点接入/碰撞检测 多点接入：说明这是总线型网络，许多计算机以多点的方式连接到总线上。 载波监听：每个站都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测：在发送中，如果监听到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 整体过程： 准备发送，并在发前，检测信道。 检测信道：若忙：则不停检测；若空闲，并在96比特时间（帧间最小间隔）内保持空闲的话，就发送。 发送过程中不停检测，即网络适配器要边发边监听：a.争用期内一直未检测到碰撞，则发送成功，回到阶段1。b.失败：检测到碰撞，停止发送，并发送人为干扰信号，再采取指数退避算法，等待r倍512比特时间后，返回阶段2。如果重传达到16次仍不成功，则停止重传，向上报错。 MACMAC 地址是 6 字节（48 位）的地址，用于唯一标识网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。 MAC 帧：类型：标记上层使用的协议；数据：长度在 46-1500 之间，如果太小则需要填充；FCS：帧检验序列，使用的是 CRC 检验方法；前同步码：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。 TCP/IP 体系结构 TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。 IP 地址分类，子网划分： 类 起始 网络号 主机号 最大可指派网络数 第一个网络号 最后一个网络号 A 0 8位 24位 2^7-2 1 126 B 10 16位 16位 2^14-2 128.1 191.255 C 110 24位 8位 2^21-2 192.0.1 223.255.255 D 1110 多播 TCP/UDP 区别基本区别： 基于连接与无连接 TCP 要求系统资源较多，UDP 较少 UDP 程序结构较简单 流模式（TCP）与数据报模式(UDP) TCP 保证数据正确性，UDP 可能丢包 TCP 保证数据顺序，UDP 不保证 TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道 UDP 应用场景： 面向数据报方式 网络数据大多为短消息 拥有大量 Client 对数据安全性无特殊要求 网络负担非常重，但对响应速度要求高 三次握手和四次挥手三次握手：互相确认对方都可以收也可以发。四次挥手：互相确认对方都收到自己要关闭的信息，并且对方已经没有要传输的信息了。 三次握手例子：第一次握手：A 打电话给 B：你可以听到我说话吗？第二次握手：B 收到 A 的信息，回复：我可以听到你说话，你听得到我说话吗？第三次握手：A 收到 B 的信息，回复：可以听到你说话，我要给你发信息啦！ 三次握手之后，A 和 B 都能确定：我说的话，你能听到；你说的话，我也能听到。这样，就可以开始正常通信了。 如果是两次：无法确认发起方可以收到。如果是四次：在三次已经可以确认时，增加次数可以提高通信的可靠性，不过会浪费资源而已。 四次挥手例子：第一次挥手：A：喂，我不说了 (FIN)。第二次挥手：B：我知道了(ACK)。等下，上一句还没说完。Balabala…..（传输剩余数据）第三次挥手：B：好了，说完了，我也不说了（FIN）。第四次挥手：A：我知道了（ACK）。A 等待2MSL，保证 B 收到了消息，否则重说一次“我知道了（ACK）”。 四次挥手之后，把该说的话都说完，并且 A 和 B 都知道自己没话说了，对方也没花说了，然后就挂掉电话（断开链接）了。 滑动窗口 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算：RTTs = (1 - a) x RTTs + a x RTT 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算：RTO = RTTs + 4 x RTTd，其中 RTTd 为偏差。 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。 快重传与快恢复 在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。 在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 应用层域名系统 DNS把主机名解析为 IP 地址，被设计成分布式系统。 层次结构 一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。 域名服务器可以分为以下四类： 根域名服务器：解析顶级域名； 顶级域名服务器：解析二级域名； 权限域名服务器：解析区内的域名； 本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。 区和域的概念不同，可以在一个域中划分多个区。在域 abc.com 中划分了两个区：abc.com 和 y.abc.com： 因此就需要两个权限域名服务器： 解析过程 主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。 迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归的方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。 Web 页面请求过程这个过程可以大致分为两个部分：网络通信和页面渲染。 网络通信解析 URL a.浏览器判断地址是否是通过域名访问的。DNS 解析：从浏览器的缓存中去找网址对应的 IP 地址 -&gt;从 OS 系统的 DNS 缓存中找 -&gt;从路由器的 DNS 缓存中找 -&gt;从 ISP 的 DNS 缓存中找。如果都没有找到：向 ISP 或公共的域名解析服务发起 DNS 查找请求（递归查询）。 比如：baidu.com 查找过程: 根域名服务器 -&gt; .com 域名服务器 -&gt; baidu.com 域名服务器。 b.若地址不含端口号，则根据协议补充默认端口号。如 HTTP 协议是 80 端口，HTTPS 是 443 端口。 建立 TCP 连接 TCP 协议通过三次握手建立连接。1️：客户端通过 SYN 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 SYN_SEND；2️：服务器如果有开着的端口并且决定接受连接，就会返回一个 SYN+ACK 报文段给客户端，状态设置为 SYN_RECV；3️：客户端收到服务器的 SYN+ACK 报文段，向服务器发送 ACK 报文段表示确认。此时客户端和服务器都设置为 ESTABLISHED 状态。连接建立，可以开始数据传输了。 应用层客户端发送 HTTP 请求 HTTP 请求包括请求头和请求主体两个部分。请求头包含了重要的信息：请求的方法（GET/POST）、目标URL、遵循的协议（HTTP/HTTPS/FTP…）、返回的信息是否需要缓存、客户端是否发送Cookie 等。 服务器接收数据 服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在传输层通过 TCP 协议将分段的数据包重新组成原来的 HTTP 请求报文。 服务器响应请求 Web 服务程序接收到客户端发送的 HTTP 请求后，解析请求，查找客户端请求的资源，并返回响应数据。 响应 = 响应行 + 响应头 + 响应主体。 响应行：HTTP/版本号 状态码 状态信息（比如： HTTP/1.1 200 OK）响应头：服务器设置的一些信息，比如 Cookie 等。响应主体：要返回的资源，比如 HTML 文件。 页面渲染浏览器渲染页面的过程：解析 HTML -&gt; 构建 DOM 树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。 DOM 树：由 HTML 文件中的标签排列组成。渲染树：由 DOM 树中加入 CSS 或 HTML 中的 style 样式形成，只包含需要显示在页面中的 DOM 元素，如 元素、display 属性值为 none 的元素都不在树中。 浏览器还没接收到完整的 HTML 文件时，就开始渲染页面，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。 在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。 GET 和 POST 区别GET：请求获取指定的资源，报文主体没有任何语义。 安全 幂等（任意多次请求所产生的响应均与一次执行的响应相同） 可缓存的（除非有 Cache-ControlHeader 约束） POST：根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。 不安全 不幂等 （大部分实现）不可缓存 这里指的“安全”在不同情况下是有不同解释的： 网络安全：两者都是一样的，HTTP 下两者都是明文，HTTPS 下两者都是密文。 RFC2616 9.1.1：GET 被称为安全方法，而 POST 却不是，因为 GET 和 HEAD 方法应该只用于检索数据，而不是添加、更新和删除。 HTTP 状态码 状态码 意义 1xx 信息，服务器收到请求，需要请求者继续执行操作 2xx 成功，操作被成功接收并处理 3xx 重定向，需要进一步的操作以完成请求 4xx 客户端错误，请求包含语法错误或无法完成请求 5xx 服务器错误，服务器在处理请求的过程中发生了错误 HTTP/1.0 和 HTTP/1.1 区别HTTP/1.1 支持长连接（PersistentConnection） HTTP/1.0 会话方式： 建立连接 发出请求信息 回送响应信息 关掉连接 HTTP/1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。 HTTP/1.1 支持持久连接, 并且默认使用该方式，但也需要增加新的请求头来帮助实现。例如，请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；请求头的值为 close 时，客户端通知服务器返回本次请求结果后关闭连接。 HTTP/1.1 请求的流水线（Pipelining）处理 请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。 例如，一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP/1.1 允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。 HTTP/1.1 Host 字段 HTTP/1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的 URL 并没有传递主机名（Hostname）。 但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。 HTTP/1.1 的请求消息和响应消息都应支持Host头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。 HTTP/1.1 状态码 100（Continue） 客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就返回响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。 优点：允许客户端在发送完整请求前先用请求头试探服务器，确认服务器是否接收，再决定要不要继续发。（节约带宽） HTTP/1.1 Chunked transfer-coding 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。 HTTP/1.1 Cache 的新特性 当缓存对象的 Age 超过 Expire 时变为 stale 对象，Cache 不需要直接抛弃 stale 对象，而是与源服务器进行重新激活（revalidation）。 HTTP 缓存机制Pragma：用来包含实现特定的指令，最常用的是Pragma:no-cache。（HTTP/1.1 协议中，含义和 Cache-Control:no-cache相同）Expires：文件在本地缓存的过期时间，如果浏览器发现缓存中的文件没有过期，则不发送请求（有例外，后面介绍）。Cache-Control：指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control 并不会修改另一个消息处理过程中的缓存处理过程。 请求中的缓存指令：no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached。响应中的指令：public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。 public：响应可被任何缓存区缓存。private：对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请 求无效。no-cache：请求或响应消息不能缓存。no-store：防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age：客户端可以接收生存期 &gt;= 指定时间（以秒为单位）的响应。min-fresh：客户端可以接收响应时间 &lt; 当前时间加上指定时间的响应。max-stale：客户端可以接收 &gt; 超时期间的响应消息。 Session 和 Cookie 区别 Cookie 放在客户端，Session 放在服务器。 Cookie 不安全。黑客可以分析存放在本地 Cookie 并进行 Cookie 欺骗。 Session 会在一定时间内保存在服务器上。当访问增多，会占用你服务器的性能。 单个 Cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个 Cookie。 实现 Session 有两种方式： Cookie 实现。如果浏览器支持 Cookie，创建 Session 的时候把 SessionID 放在 Cookie 里。 重写 URL。如果浏览器不支持 Cookie，服务端可以通过重写 URL 的方式实现 Session，即 URL 后面加上 SessionID。 DNS 解析过程操作系统首先检查本地的 hosts 文件是否有这个网址映射关系：-&gt; yes.就先调用这个 IP 地址映射，完成域名解析。-&gt; no.查找本地 DNS 解析器缓存，是否有这个网址映射关系：——&gt; yes.直接返回，完成域名解析。——&gt; no.首先找TCP/IP 参数中设置的首选 DNS 服务器，暂且叫它本地 DNS 服务器：———–&gt; 1.查询的域名，在服务器的本地配置区域资源中，返回解析结果给客户端，完成域名解析。———–&gt; 2.不由本地 DNS 服务器区域解析：—————&gt; a.但服务器缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析。—————&gt; b.本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询：——————-&gt; a) 未用转发模式：本地 DNS 就把请求发至根 DNS，根 DNS 服务器收到请求后会判断这个域名由谁授权管理，并返回一个负责该顶级域名服务器的一个 IP。———————&gt; 1.本地 DNS 服务器收到 IP 信息后，将会联系负责该域名的这台顶级域名服务器。———————&gt; 2.顶级域名服务器收到请求后，如果自己无法解析，就会找一个管理该域名的下一级 DNS 服务器地址给本地 DNS 服务器。———————&gt; 3.本地 DNS 服务器收到这个地址后，就会找这个下一级 DNS 服务器服务器，重复上面的动作进行查询，直至找到域名主机。——————-&gt; b) 转发模式：本地 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，如此循环。——————-&gt; 不管是本地 DNS 服务器用的是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，再由本地 DNS 服务器返回给客户端。 从客户端到本地 DNS 服务器是递归查询，而 DNS 服务器之间的交互查询是迭代查询。 常用协议端口 端口 协议 20/TCP FTP 文件数据传输 21/TCP FTP 控制信令的传输 23/TCP TELNET 终端仿真 25/TCP SMTP 简单邮件传输 53/UDP DNS 域名解析 67/TCP DHCP 服务端 68/TCP DHCP 客户端 69/UDP TFTP 简单文件传输 80/TCP HTTP 超文本传输 110/TCP POP3 邮局协议版本3 443/TCP HTTPS 加密的超文本传输 1521/TCP Oracle 数据库 1863/TCP MSN Messenger 文件传输 3389/TCP Microsoft RDP 微软远程桌面 5631/TCP Symantec pcAnywhere 远程控制数据传输 5632/UDP Symantec pcAnywhere 主控端扫描被控端 5000/TCP MS SQL Server","link":"/2018/02/14/zh/programing/basis/computer_network/"},{"title":"跨域资源共享 CORS 详解","text":"CORSCORS：跨域资源共享（Cross-origin resource sharing），是一个 W3C 标准。 作用：允许浏览器向跨源服务器发出 XMLHttpRequest 请求，从而克服 AJAX 只能同源使用的限制。 简介CORS 需要浏览器和服务器同时支持。基本所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 对用户：整个 CORS 通信过程，都是浏览器自动完成，不需要自己参与。 对开发者：CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。 浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，该过程对用户透明。 实现 CORS 通信的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信。 两种请求浏览器将 CORS 请求分为：简单请求（Simple Request）、非简单请求（Not-so-simple Request）。 只要同时满足以下两大条件，就属于简单请求。 请求方法是这三种方法之一：HEAD、GET、POST HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于 application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足以上两个条件的，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 简单请求基本流程对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是由浏览器自动在头信息中增加一个 Origin 字段。 比如，浏览器发现这次跨源 AJAX 请求是简单请求： 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... Origin 字段用来说明本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据该值，决定是否同意这次请求。 如果 Origin 指定的源，不在许可范围内，服务器会返回一个 HTTP 响应，其头信息没有包含 Access-Control-Allow-Origin 字段，浏览器收到后就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。注：该错误无法通过状态码识别，因为 HTTP 响应的状态码有可能是200。 如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以 Access-Control- 开头。 Access-Control-Allow-Origin 必需。 它的值要么是请求时的 Origin 字段的值，要么是 *，表示接受任意域名的请求。 Access-Control-Expose-Headers 可选。 CORS 请求时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到6个基本字段： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。 比如，上面的例子中要获取 FooBar 字段，就要 getResponseHeader('FooBar')。 Access-Control-Allow-Credentials 可选。 它的值是一个布尔值，表示：是否允许发送 Cookie。默认情况下 Cookie 不包括在 CORS 请求中。 true：服务器明确允许 Cookie 可以包含在请求中（这个值只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可）。 withCredentials 属性上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。 如果要把 Cookie 发到服务器，要满足两个条件： 服务器同意：Access-Control-Allow-Credentials: true。 开发者在 AJAX 请求中打开 withCredentials 属性： 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意接受 Cookie，浏览器也不会发送 或 服务器要求设置 Cookie，浏览器也不会处理。 如果省略 withCredentials 属性，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials：xhr.withCredentials = false; 注意：如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为 *，必须指定明确的、与请求网页一致的域名。同时 Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。 非简单请求预检请求非简单请求是那种对服务器有特殊要求的请求，比如 PUT 或 DELETE 请求，或者 Content-Type 字段的类型是 application/json。 非简单请求的 CORS 请求，会在正式通信前进行一次 HTTP 查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 下面是一段浏览器的 JavaScript 脚本： 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP 请求的方法是 PUT，并且发送一个自定义头信息 X-Custom-Header。 浏览器发现这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的 HTTP 头信息： 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里的关键字段 Origin，表示请求来自哪个源。 除了 Origin 字段，”预检”请求的头信息还包括两个特殊字段： Access-Control-Request-Method 必须。 列出浏览器的 CORS 请求会用到哪些HTTP方法，比如上面的 PUT。 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，比如上面的 X-Custom-Header。 预检请求的响应服务器收到”预检”请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以响应： 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 响应中的关键是 Access-Control-Allow-Origin 字段，表示 http://api.bob.com 可以请求数据。该字段也可以设为 *，表示同意任意跨源请求：Access-Control-Allow-Origin: *。 如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 响应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获。控制台会打印出如下的报错信息： 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器响应的其他 CORS 相关字段: 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 Access-Control-Allow-Methods 必需。 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。 注：返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 Access-Control-Max-Age 可选。 指定本次预检请求的有效期，单位：秒。上面示例中的有效期是1728000秒，即允许缓存该条响应1728000秒，在此期间，不用发出另一条预检请求。 浏览器的正常请求和响应一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的响应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 下面是”预检”请求之后，浏览器的正常 CORS 请求： 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的 Origin 字段是浏览器自动添加的。 下面是服务器正常的响应： 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin 字段是每次响应都必定包含的。 与 JSONP 比较CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。 JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 优势在于支持老式浏览器，可以向不支持 CORS 的网站请求数据。","link":"/2018/07/21/zh/programing/basis/cross_domain_resource_sharing/"},{"title":"操作系统","text":"操作系统1.一个二进制文件运行出结果，操作系统做了什么（这是一个很全面的题） 2.死锁的条件及银行家算法、资源分配图之类的 3.进程间通信方式 1信号、管道、消息队列、共享内存 4.Linux的五种IO方式（阻塞与非阻塞、同步与异步的理解） 123456789阻塞IO模型非阻塞IO模型IO复用模型信号驱动IO异步IO模型 5.Linux的select、poll、epoll的区别 6.进程与线程区别、内核级线程与用户级线程 7.页面置换算法，尤其是lru 8.进程调度算法 9.Linux中断响应机制 10.虚拟内存机制 11.冯诺依曼体系 12.shell 命令的执行过程 13.程序运行中的栈式结构，栈溢出攻击 14.同步与阻塞 15.并行与并发，线程调度，并行级别 16.信息熵 17.内核态与用户态，中断 18.CPU 与内存与磁盘 19.缓存行与伪共享 20.内存分配管理，段页式。","link":"/2018/02/14/zh/programing/basis/operating_system/"},{"title":"下载等待","text":"广告。增加停留时间就意味着用户有更多的机会看到令自己感兴趣的广告并点击，然后就有更高的收入了； 推荐。可以立即推荐有关的下载，有的人下载完东西就直接关闭了网站，不会看到相关的下载信息，就没有更多的浏览量； 条款。我们在下载的时候一般都会涉及到相关条款（免责条款），如果在下载页面放置基本不会有人注意，但放在这里，很多纠纷就能够说过去； 缓冲。防止误下载；防止盗链；给服务器寻找资源做缓冲（更优下载路线），倒计时一完成就能过够开始下载，不用再看着空白页面等待。","link":"/2018/07/22/zh/programing/design_ideas/download_waiting/"},{"title":"合并请求VS并行请求","text":"减少HTTP请求，是雅虎前端性能优化35条军规的第1条，2006年雅虎提出了这35条军规，从那以后，就深深地影响到了一批又一批的前端开发者，即使在12年后的今天，影响力依旧不减… 但是，雅虎军规中还有1条是：拆分资源以最大化利用浏览器并行下载的能力。现在问题就来了，减少HTTP请求，但网页所需的资源并不能减少（否则网页就不再是之前的网页了），所以减少HTTP请求，主要是通过合并资源来实现的，一边是建议合并资源，一边是建议拆分资源，显然是有冲突的地方，那么到底该怎么做呢？网上有些文章也讨论过这个问题，但大多是停留在想当然的理论分析上，而且忽略了TCP传输机制的影响。 HTTP请求过程一个HTTP请求的主要过程是： DNS解析(T1) -&gt; 建立TCP连接(T2) -&gt; 发送请求(T3) -&gt; 等待服务器返回首字节（TTFB）(T4) -&gt; 接收数据(T5)。 如下图所示，是Chrome Devtools中显示的一个HTTP请求，显示了HTTP请求的主要阶段，注意，Queueing阶段是请求在浏览器队列中的排队时间，并不计入HTTP请求时间。 从这个过程中，可以看出如果合并N个HTTP请求为1个，可以节省（N-1)* (T1+T2+T3+T4) 的时间。 但实际场景并没有这么理想，上面的分析存在几个漏洞： 浏览器会缓存DNS信息，因此不是每次请求都需要DNS解析。 HTTP 1.1 keep-alive的特性，使HTTP请求可以复用已有TCP连接，所以并不是每个HTTP请求都需要建立新的TCP连接。 浏览器可以并行发送多个HTTP请求，同样可能影响到资源的下载时间，而上面的分析显然只是基于同一时刻只有1个HTTP请求的场景。 实验论证我们来做4组实验，对比一个HTTP请求加载合并后的资源所需时间，和多个HTTP请求并行加载拆分的资源所需时间。每组实验所用资源的体积大小有显著差异。 实验环境： 服务器：阿里云ECS 1核 2GB内存 带宽1M Web服务器：Nginx (未启用Gzip) Chrome v66 隐身模式，禁用缓存 Client 网络：wifi 带宽20M 实验代码地址：https://github.com/xuchaobei/examples/tree/master/minimizing%20http%20vs%20parallel%20http 实验 1测试文件：large1.css、large2.css … large6.css，每个文件141K;large-6in1.css，由前面6个css文件合并而成，大小为846K。parallel-large.html引用large1.css、large2.css … large6.css， combined-large.html引用large-6in1.css。 代码如下： 123456789101112131415// parallel-large.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Parallel Large&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large1.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large2.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large3.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large4.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large5.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large6.css&quot; /&gt; &lt;/head&gt; &lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt; 12345678910// combined-large.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Combined Large&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large-6in1.css&quot; /&gt; &lt;/head&gt; &lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt; 分别刷新2个页面各10次，利用Devtools的Network计算CSS资源加载的平均时间。 注意事项 large1.css、large2.css … large6.css的加载时间，计算方式为从第一个资源的HTTP请求发送开始，到6个文件都下载完成的时间，如图2红色框内的时间。 两个html页面不能同时加载，否则带宽为两个页面所共享，会影响测试结果。需要等待一个页面加载完毕后，再手动刷新加载另外一个页面。 页面两次刷新时间间隔在1分钟以上，以避免HTTP 1.1连接复用对实验的影响。 实验结果： 文件 large-6in1.css large1.css、large2.css … large6.css 平均时间(s) 5.52 5.3 我们再把large1.css、large2.css … large6.css合并为3个资源large-2in1a.css、large-2in1b.css、large-2in1c.css，每个资源282K，在combined-large-1.html中引用这3个资源： 123456789101112// combined-large-1.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Parallel Large 1&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large-2in1a.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large-2in1b.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;large-2in1c.css&quot; /&gt; &lt;/head&gt; &lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt; 测试10次，平均加载时间为5.20s。 汇总实验结果如下： 文件 large-6in1.css large1.css、large2.css … large6.css large-2in1a.css、… large-2in1c.css 平均时间(s) 5.52 5.30 5.20 从实验1结果可以看出，合并资源和拆分资源对于资源的总加载时间没有显著影响。实验中耗时最少的是拆分成3个资源的情况（5.2s），耗时最多的是合并成一个资源的情况(5.52s)，但两者也只不过相差6%。考虑到实验环境具有一定随机性，以及实验重复次数只有10次，这个时间差并不能表征3种场景有明显的时间差异性。 实验 2继续增加css文件大小。 测试文件：xlarge1.css、xlarge2.css 、xlarge3.css，每个文件1.7M；xlarge-3in1.css，由前面3个css文件合并而成，大小为5.1M。parallel-xlarge.html引用xlarge1.css、xlarge2.css 、xlarge3.css， combined-xlarge.html引用xlarge-3in1.css。 测试过程同上，实验结果： 文件 xlarge-3in1.css xlarge1.css、xlarge2.css、xlarge3.css 平均时间(ms) 37.72 36.88 这组实验的时间差只有2%，更小了，所以更无法说明合并资源和拆分资源的总加载时间有明显差异性。 实际上，理想情况下，随着资源体积变大，两种资源加载方式所需时间将趋于相同。 从理论上解释，因为HTTP的传输通道是基于TCP连接的，而TCP连接具有慢启动的特性，刚开始时并没有充分利用网络带宽，经过慢启动过程后，逐渐占满可利用的带宽。对于大资源而言，带宽总是会被充分利用的，所以带宽是瓶颈，即使使用更多的TCP连接，也不能带来速度的提升。资源越大，慢启动所占总的下载时间的比例就越小，绝大部分时间，带宽都是被充分利用的，总数据量相同（拆分资源导致的额外Header在这种情况下完全可以忽略不计），带宽相同，传输时间当然也相同。 实验 3减小css文件大小。 测试文件：medium1.css、medium2.css … medium6.css，每个文件9.4K；medium-6in1.css，由前面6个css文件合并而成，大小为56.4K。parallel-medium.html 引用 medium1.css、medium2.css … medium6.css， combined-medium.html 引用 medium-6in1.css。 实验结果： 文件 medium-6in1.css medium1.css、medium2.css … medium6.css 平均时间(ms) 34.87 46.24 实验3的时间差是33%，虽然数值上只差12ms。先不多分析，继续看实验4。 实验 4继续减小css文件大小，至几十字节级别。 测试文件：small1.css、small2.css … small6.css，每个文件28B；small-6in1.css，由前面6个css文件合并而成，大小为173B。parallel-medium.html引用small1.css、small2.css … small6.css， combined-medium.html 引用 small-6in1.css。 实验结果： 文件 small-6in1.css small1.css、small2.css … small6.css 平均时间(ms) 20.33 35 实验4的时间差是72%。 根据实验3和实验4，发现当资源体积很小时，合并资源和拆分资源的加载时间有了比较明显的差异。图3和图4是实验4中的某次测试结果的截图，当资源体积很小时，数据的下载时间（图中水平柱的蓝色部分所示）占总时间的比例就很小了，这时候影响资源加载时间的关键就是DNS解析(T1) 、 TCP连接建立(T2) 、发送请求(T3) 和等待服务器返回首字节（TTFB）(T4) 。但同时建立多个HTTP连接本身就存在额外的资源消耗，每个HTTP的DNS查询时间、TCP连接的建立时间等也存在一定的随机性，这就导致并发请求资源时，出现某个HTTP耗时明显增加的可能性变大。如图3所示，small1.css加载时间最短（16ms），small5.css加载时间最长(32ms)，两者相差了1倍，但计算时间是以所有资源都加载完成为准，这种情况下，同时使用多个HTTP请求就会导致更大的时间不均匀性和不确定性，表现结果就是往往要比使用一个HTTP请求加载合并后的资源慢。 更复杂的情况对于小文件一定是合并资源更快吗？ 其实未必，在一些情况下，合并小文件反而有可能明显增加资源加载时间。 再说些理论的东西。为了提高传输效率，TCP通道上，并不是发送方每发送一个数据包，都要等到收到接收方的确认应答（ACK）后，再发送下一个报文。TCP引入了”窗口“的概念，窗口大小指无需等待确认应答而可以继续发送数据的最大值，例如窗口大小是4个MSS（Maximum Segment Size，TCP数据包每次能够传输的最大数据分段），表示当前可以连续发送4个报文段，而不需要等待接收方的确认信号，也就是说，在1次网络往返（round-trip）中完成了4个报文段的传输。如下图所示（MSS为1，窗口大小为4），1 - 4000 数据是连续发送的，并没有等待确认应答，同样的，4001 - 8000也是连续发送的。请注意，这只是理想情况下的示意图，实际情况要比这里更复杂。 在慢启动阶段，TCP维护一个拥塞窗口变量，这个阶段窗口的大小就等于拥塞窗口，慢启动阶段，随着每次网络往返，拥塞窗口的大小就会翻一倍，例如，假设拥塞窗口的初始大小为1，拥塞窗口的大小变化为：1，2，4，8……。如下图所示。 实际网络中，拥塞窗口的初始值一般是10，所以拥塞窗口的大小变化为：10，20，40 … ，MSS的值取决于网络拓扑结构和硬件设备，以太网中MSS值一般是1460字节，按每个报文段传输的数据大小都等于MSS计算（实际情况可以小于MSS值），经过第1次网络往返后，传输的最大数据为14.6K，第2次后，为(10+20) 1.46 = 43.8K， 第3次后，为(10+20+40) 1.46 = 102.2K。 根据上面的理论介绍，实验4中，不管是合并资源，还是拆分资源，都是在1次网络往返中传输完成。但实验3，拆分后的资源大小为9.4K，可以在1次网络往返中传输完成，而合并后的资源大小为56.4K，需要3次网络往返才能传输完成，如果网络延时很大（例如1s），带宽又不是瓶颈，多了两次网络往返将导致耗时增加1s，这时候合并资源就可能得不偿失了。实验3并没有产生这个结果的原因是，实验中网络延时是10ms左右，由于数值太小而没有对结果产生明显影响。 总结对于大资源，是否合并对于加载时间没有明显影响，但拆分资源可以更好的利用浏览器缓存，不会因为某个资源的更新导致所有资源缓存失效，而资源合并后，任一资源的更新都会导致整体资源的缓存失效。另外还可以利用域名分片技术，将资源拆分部署到不同域名下，既可以分散服务器的压力，又可以降低网络抖动带来的影响。 对于小资源，合并资源往往具有更快的加载速度，但在网络带宽状况良好的情况下，因为提升的时间单位以ms计量，收益可以忽略。如果网络延迟很大，服务器响应速度又慢，则可以带来一定收益，但在高延迟的网络场景下，又要注意合并资源后可能带来网络往返次数的增加，进而影响到加载时间。 其实，看到这里，是合是分已经不重要了，重要的是我们要知道合分背后的原理是什么，和业务场景是怎样的。","link":"/2018/10/10/zh/programing/design_ideas/merge_requests_and_parallel_requests/"},{"title":"短链接服务系统开发","text":"功能简单描述功能很简单，实现将长网址缩短的功能，如：https://javadoop.com/post/url-shortener/a/b/c/d/e/f -&gt; https://abc.com/alsk2 为什么要转短链？因为要控制每条短信的字数，对于公司来说，短信里面的字可都是钱呀。 为什么不用 t.cn，url.cn 等短链服务呢，它们生成的链接不是更短吗？是的，它们确实能实现更短的链接，可是要收钱的，而且这里面充满了商业数据呀。 短链服务总的来说，就做两件事： 将长链接变为短链接，当然是越短越好。 用户点击短链接的时候，实现自动跳转到原来的长链接。 长链转短链在转短链的时候，其实就是要将一个长长的链接映射为只有 4 到 7 个字母的字符串。 这里我用了 MySQL 来存储，存放 short_key 和 original_url 的记录。 数据表很简单，最主要的列有以下几个： id: 逻辑主键，BIGINT short_key: 短链中的字符串，域名部分一般不需要加进去，加入唯一索引 UNIQUE original_url: 原长网址，限 256 字符 另外，基于业务需要，可以加入业务标识 biz、过期时间 expire_time 等。 在生成 key 的时候，一种最简单的实现方式是使用随机字符串，因为是随机码，所以可能会出现失败，通常就需要重试。随着记录越来越多，就越容易发生 key 重复的情况，这种方案显然不适合数据量大的场景。 我们不容易保证我们随机生成的 key 不重复，但是我们容易实现的就是 id 不重复，我们只要想个办法把 id 和 key 一一对应起来就可以了。 单表场景，直接使用数据库自增 id 就能实现 id 唯一。多库多表，大家肯定都有一个全局发号器来生成唯一 id。 直接将 id 放在短链上可以吗？这样就不需要使用 key 了。功能上是没有问题的，不过问题就是还是会太长，然后由于 id 通常都是基本自增的，会引发很多问题，如被别人用一个简单的脚本给遍历出来。 接下来，我们讨论怎么将 id 变为 key。 在短链中，我们通常可以使用的字符有 a-z、A-Z 和 0-9 共 62 个字符，所以，接下来，我们其实就是要将 10 进制的 id 转换为 62 进制的字符串。 转换方法很简单，大家都学过二进制和十进制之间的转换，这里贴下简单的实现： 12345678910111213private static final String BASE = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;public static String toBase62(long num) { StringBuilder sb = new StringBuilder(); int targetBase = BASE.length(); do { int i = (int) (num % targetBase); sb.append(BASE.charAt(i)); num /= targetBase; } while (num &gt; 0); return sb.reverse().toString();} 这样，十进制的 id 总是能生成一个唯一的 key，同样地，我们也可以通过 key 还原出 id。 在分库分表的时候，我们可以选择使用 id 来做分表键，也可以使用 key 来做分表键。如果是使用 id 的话，因为前端过来都是 key，所以需要先将 key 转换为 id。这里我们将使用 key 做分表键。 本文不会用到 62 进制转 10 进制，不过也贴出来让大家参考下吧： 123456789101112public static long toBase10(String input) { int srcBase = BASE.length(); long id = 0; String r = new StringBuilder(input).reverse().toString(); for (int i = 0; i &lt; r.length(); i++) { int charIndex = BASE.indexOf(r.charAt(i)); id += charIndex * (long) Math.pow(srcBase, i); } return id;} 短链转长链这一步非常简单，用户点击我们发给他们的短信中的短链，请求发送到我们的解析系统中，我们根据 key 到数据库中找原来的长链接，然后做个 302 跳转就可以了。 这里贴下 Spring MVC 的代码： 123456789@GetMapping(&quot;/{key}&quot;)public String lookup(@PathVariable String key) { String originalUrl = shortenerService.lookup(key); if (StringUtils.isBlank(originalUrl)) { // 如果没有找到长链接，跳转到我们的 m 站，这里其实定制一个 404 页面比较好 return &quot;redirect:https://m.zhongan.com&quot;; } return &quot;redirect:&quot; + originalUrl;} 细节优化加入随机码62 进制用更短的字符串能表示更大的数，使得我们可以使用更少的字符，同时不会让用户直接知道我们的 id 大小，但是稍微懂一点技术的，很容易就能将 62 进制转换为 10 进制，在行家眼里，和直接使用 id 没什么区别。 下面，我们就来优化这部分。 首先，上面的代码中，我们可以打乱这个 BASE 字符串，因为如果不打乱的话，那么 62 进制中就会有 XXb = XXa + 1，如 10 进制的 999998 和 999999 转换为 62进制以后，分别为 4C90 和 4C91，大家是不是发现有点不妥。 接下来，我们可以考虑加随机字符串，如固定在开头或结尾加 2 位随机字符串，不过这样的话，就会使得我们的短链活生生地加了 2 位。 这里简单介绍下我的做法，使得生成的 key 不那么有规律，不那么容易被遍历出来。 我们得到 id 以后，先在其二进制表示的固定位置插入随机位。如上图所示，从低位开始，每 5 位后面插入一个随机位，直到高位都是 0 就不再插入。 一定要对每个 id 进行一样的处理，一开始就确定下来固定的位置，如可以每 4 位插一个随机位，也可以在固定第 10 位、第 17 位、第 xx 位等，这样才能保证算法的安全性：两个不一样的数，在固定位置都插入随机位，结果一定不一样。 由于我们会浪费掉一些位，所以最大可以表示的数会受影响，不过 64 位的 long 值是一个很大的数，是允许我们奢侈浪费一些的。 还有，前面提到高位为 0 就不再插入，那是为了不至于一开始就往高位插入了 1 导致我们刚开始的值就特别大，转换出来需要更长的字符串。 这里我贴下我的插入随机位实现： 1234567891011121314private static long insertRandomBitPer5Bits(long val) { long result = val; long high = val; for (int i = 0; i &lt; 10; i++) { if (high == 0) { break; } int pos = 5 + 5 * i + i; high = result &gt;&gt; pos; result = ((high &lt;&lt; 1 | RandomUtils.nextInt(0, 2)) &lt;&lt; pos) | (result &amp; (-1L &gt;&gt;&gt; (64 - pos))); } return result;} 这样，我们 10 进制的 999998 和 999999 就可能被转换为 16U06 和 XpJX。因为有随机位的存在，所以会有好几种可能。到这里，是不是觉得生成出来的字符串就好多了，相邻的两个数出来的两个字符串没什么规律了。 另外，建议 id 从一个中等模式的大小开始，如 100w，而不是从 1 开始，这个应该很好理解。 加入缓存为了提高效率，我们应该使用适当的缓存，在系统中，我分别使用了一个读缓存和一个写缓存。 通常，我们使用读缓存 (key =&gt; originalUrl) 可以获得很多好处，大家想想，如果我们往一批用户的手机发送同一个短链，可能大家都是在收到短信的几分钟内打开链接的，这个时候读缓存就能大大提高读性能。 至于写请求，接口来了一个 originalUrl，我们不能去数据库中查询是否已经有这条记录，所以两条一模一样的链接我们会生成两个不一样的短链接，当然，通常我们也是允许这种情况的。 这里我指的是在分库分表的场景中，我们只能使用 key 来查找，已经不支持使用 original_url 进行数据库查找了。 由于存在短时间内使用两条一模一样的长链接拿过来转短链的情况，所以我们可以维护一个写缓存 (originalUrl =&gt; key)，这里使用 originalUrl 做键，如设置最大允许缓存最近 10000 条，过期时间 1 小时，根据自己实际情况来设置即可。这里写缓存能不能提高效率，取决于我们的业务。 由于生成短链的接口一般是提供给其他各个业务系统使用的，所以其实可以由调用方来决定是否要使用写缓存，这样能得到最好的效果。如果调用方知道自己接下来需要批量转换的长链是不会重复的，那么调用方可以设置不使用缓存，而对于一般性的场景，默认开启写缓存。 数据库大小写这里再提最后一点，也是我自己踩的坑，有点低级失误了。一定要检查下自己的数据表是不是大小写敏感的。 在大小写不敏感的情况下，3rtX 和 3Rtx 被认为是相同的。 解决办法如下，设置列为 utf8_bin： 1ALTER TABLE `xxx` MODIFY `short_key` CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin; 性能分析这个系统非常简单，性能瓶颈其实都集中在数据库中，前面我们也说了可以通过缓存来适当提高性能。 这里，我们不考虑缓存，来看下应该怎么设计数据库和表。 首先，我们应该预估一个适当的量，如按照自己的业务规模，预估接下来 2 年或更长时间，大概会增长到什么量级的数据。 如预估未来可能需要存放 50-100 亿条记录，然后我们大概按照单表 1000w 数据来设计，那么就需要 500-1000 张表，那么我们可以定 512 张表，512 张表我们可以考虑放 2 个或 4 个库。 我们使用 key 来做分表键，同时在 key 上加唯一索引，对于单表 1000w 这种级别，查询性能一般都差不了。 我没有在生产环境做过压测，测试环境中使用单库 2 张表，在不使用缓存的情况下，写操作可以比较轻松地达到 3000 TPS，基本上也就满足我们的需求了。本来测试环境各种硬件资源就和生产环境没法比，更何况我们生产环境会设置多库多表来分散压力。","link":"/2018/10/31/zh/programing/design_ideas/short_link_service_system/"},{"title":"Web 项目性能优化","text":"前言Web性能优化分为后端和前端两个方面。 前端1、压缩源码和图片JavaScript文件源代码可以采用混淆压缩的方式，CSS文件源代码进行普通压缩，JPG图片可以根据具体质量来压缩为50%到70%，PNG可以使用一些开源压缩软件来压缩，比如24色变成8色、去掉一些PNG格式信息等。 2、选择合适的图片格式如果图片颜色数较多就使用JPG格式，如果图片颜色数较少就使用PNG格式，如果能够通过服务器端判断浏览器支持WebP，那么就使用WebP格式和SVG格式。 3、合并静态资源包括CSS、JavaScript和小图片，减少HTTP请求。有很大一部分用户访问会因为这一条而取得最大受益 4、开启服务器端的Gzip压缩这对文本资源非常有效，对图片资源则没那么大的压缩比率。 5、使用CDN或者一些公开库使用第三方提供的静态资源地址（比如jQuery、normalize.css）。一方面增加并发下载量，另一方面能够和其他网站共享缓存。 6、延长静态资源缓存时间这样，频繁访问网站的访客就能够更快地访问。不过，这里要通过修改文件名的方式，确保在资源更新的时候，用户会拉取到最新的内容。 7、把CSS放在页面头部，把JavaScript放在页面底部这样就不会阻塞页面渲染，让页面出现长时间的空白。 如何提高网页的效率（上篇）如何提高网页的效率（下篇） 后端","link":"/2018/03/19/zh/programing/design_ideas/web_project_optimization/"},{"title":"GitLab 搭建","text":"前言有时候公司需要搭建私有仓库，这时 GitHub 就不能用了。 这里的私有仓库使用 GitLab，而且使用 Docker 方式运行，方便快速。 GitLab 有 CE 和 EE 版本，本文使用 CE 版本。 参考文章：GitLab 官方文档 docker 使用运行镜像docker 会自动拉取镜像并配置运行： 123456789sudo docker run --detach \\ --hostname local.gitlab.com \\ --publish 2200:22 --publish 8000:80 --publish 4330:433 \\ --name gitlab \\ --restart always \\ --volume /docker/gitlab/config:/etc/gitlab \\ --volume /docker/gitlab/log:/var/log/gitlab \\ --volume /docker/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 映射的端口：SSH, HTTP 和 HTTPS。 目录含义： /etc/gitlab：包含 gitlab 的配置文件 /var/log/gitlab：gitlab 的日志目录 /var/opt/gitlab：gitlab 使用的仓库保存所有版本库 因为部署在本地，又指定了 local.gitlab.com 作为域名，所以在 /etc/hosts 配置下，这样可以通过域名访问 gitlab。 1127.0.0.1 local.gitlab.com 配置进到容器的 shell 环境： 1sudo docker exec -it gitlab /bin/bash 所有的配置都在 /etc/gitlab/gitlab.rb，需要注意其中的 external_url 是指向有效的 url 地址，比如：http://localhost。 更改 GitLab 的用户密码： 1234gitlab-rails consoleuser = User.where(username: 'root').firstuser.password = 'root1234'user.save! 重启 GitLab 服务： 1gitlab-ctl restart SSH生成公私钥： 1ssh-keygen -t ed25519 -C 'root@gitlab.com' 这里只是测试，所以内容都按默认的填。 将公钥内容复制到 http://local.gitlab.com:8000/profile/keys： 由于不是默认的 22 端口，无法直接域名操作 Git，在 .ssh/config 文件中添加： 123host gitlabhostname local.gitlab.comport 2200 测试： 1ssh -T git@gitlab 测试项目测试步骤： 在 GitLab 添加仓库 拉取到本地做修改 上传回仓库 在 GitLab 添加仓库： 拉取到本地做修改： 12345git clone git@gitlab:root/demo.gitcd demogit config user.email 'root@gitlab.com'git config user.name 'root'touch README.md 上传回仓库： 123git add .git commit -m 'init'git push 到这里基本工作就结束了，其他关于 GitLab 的使用请看官方文档，说得非常清楚。","link":"/2019/01/29/zh/programing/docker/gitlab_deploy/"},{"title":"Jenkins 自动化部署","text":"前言流程： Jenkins 拉取 GitLab 仓库源码 Jenkins 本地构建打包应用 把应用按 Dockerfile 打包进 Docker 镜像 使用 shell 或 Docker 相关的 Jenkins 插件把镜像上传到 Docker 私有仓库 执行 shell 脚本删除旧 Docker 容器，运行新 Docker 容器 参考文章： Jenkins集成Docker镜像实现自动发布 docker+jenkins+git搭建java自动化部署 实战docker+jenkins+git+registry构建持续集成环境 基于Docker+Jenkins+Gitlab搭建持续集成环境 Git docker参考《GitLab 搭建》 GitLab 上传了 tale 项目： 私有仓库 docker参考《Registry 搭建》 Jenkins dockerJenkins 有很多使用方式，这里使用 Docker 部署： 123456789101112sudo docker run --detach \\ --publish 50000:50000 --publish 16000:8080 \\ --link gitlab:local.gitlab.com \\ --user root \\ --name jenkins \\ --restart always \\ --volume /var/run/docker.sock:/var/run/docker.sock \\ --volume /usr/bin/docker:/usr/bin/docker \\ --volume /docker/jenkins:/var/jenkins_home \\ --volume /usr/local/maven:/usr/local/maven \\ --volume /usr/lib/jvm/jdk-8u201:/usr/local/jdk \\ jenkins/jenkins:lts –volume /var/run/docker.sock:/var/run/docker.sock–volume /usr/bin/docker:/usr/bin/dockerdocker in docker 的方式，可以让 jenkins 构建 docker 容器，这里需要进容器里安装一个库，不然容器无法使用 docker： 1apt-get update &amp;&amp; apt-get install -y libltdl7 注意：映射本地的 maven 和 jdk 目录，这样容器内就不用再进行安装。 由于 Jenkins 容器的用户默认不是 root，所以在启动时需要指定 root 用户。否则映射目录就需要更改拥有者，不然会因为映射权限不足而无法启动（相关文章：Docker Volume 之权限管理）： 1sudo chown -R 1000 /docker/jenkins 配置启动后看日志，里面有安装时需要用到的密码： 123456789101112sudo docker logs -f jenkins*************************************************************Jenkins initial setup is required. An admin user has been created and a password generated.Please use the following password to proceed to installation:b0ef7a9de503459395b4db8433f5f291This may also be found at: /var/jenkins_home/secrets/initialAdminPassword************************************************************* 访问 localhost:16000，插件这里就选择推荐的安装了，图略。 之后继续安装一些插件，进入系统管理 -&gt; 插件管理 -&gt; available，搜索安装以下插件： 123456Docker plugindocker-build-stepGitlab Hook PluginGitLab PluginMaven Integration pluginPublish Over SSH 对环境变量进行配置，进入系统管理 -&gt; 全局工具配置： 编辑本地 /usr/lib/systemd/system/docker.service，修改其中的 ExecStart 属性： 123456[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerd --tls=false -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 进入 Jenkins 界面的系统管理 -&gt; 系统配置，修改 Docker Builder 下的 Docker URL 为：tcp://x.x.x.x:2375，注意这里的 x.x.x.x 是本地的网卡 IP 地址，之后点击测试，确认是否可以连接。 本地打包构建测试这里先测试下 Jenkins 拉取 GitLab 项目并进行打包是否可行，新建一个 Jenkins 的 Maven 项目，配置如下： 在项目里的 Console Output 看是否打包成功： 可以从日志中看到，打好的包放在 /var/jenkins_home/workspace/test/target/dist，对应的映射本地目录：/docker/jenkins/workspace/test/target/dist","link":"/2019/01/31/zh/programing/docker/jenkins_auto_deploy/"},{"title":"Oracle 搭建","text":"前记项目需要用到 Oracle 数据库，但以前没有用过。本来想直接安装在主机上的，但是看了 ArchWiki 后觉得好麻烦，然后就想起了 Docker。 Spring 项目里用到了 Oracle JDBC 的驱动，但是 Maven 怎么都下载不到本地，搜索了一番才发现 Oracle 没有授权是不能直接下载的，所以这里只能手动下载添加。 这里就记录一下 Docker 安装使用 Oracle 的过程，以及在项目里导入从官网下的 JDBC 驱动。 安装 Oracle查找 Oracle 相关的镜像：sudo docker search oracle 国内用户在拉取镜像前，可以把 docker 的源换成阿里的，这样快很多（来自 CSDN docker使用阿里云Docker镜像库加速(修订版)）： 12sudo echo '{ &quot;registry-mirrors&quot;: [ &quot;https://pee6w651.mirror.aliyuncs.com&quot;] }' &gt; /etc/docker/daemon.jsonsudo systemctl restart docker 这里使用 oracle-12c： 1sudo docker pull sath89/oracle-12c 创建容器： 12345sudo docker run --detach \\ --publish 8080:8080 --publish 1521:1521 \\ --name oracle \\ --restart always \\ sath89/oracle-12c 容器 8080 和 1521 端口分别映射本地的 8080 和 1521，并且命名为 oracle。 冒号前为本地，冒号后为容器 查看容器日志： 1sudo docker logs -f oracle 进入容器的 shell 环境： 1sudo docker exec -it oracle /bin/bash 进入 Oracle 的 HOME 目录，然后运行 sqlplus： 12cd $ORACLE_HOMEbin/sqlplus 默认账户密码：system/oracle 我还发现了更优雅的安装方法。（这种方式我还没试过，有待验证） 安装好 docker-compose：官方文档 执行 docker-compose up -d，它会读取当前路径下的 docker-compose.yml 配置来 pull/run 容器。 123456789101112131415# http://wiki.jikexueyuan.com/project/docker-technology-and-combat/yaml_file.htmlversion: '3'services: oracle: # sid: XE # username: system # password: oracle # 指定为镜像名称或镜像 ID image: sath89/oracle-12c # 卷挂载路径设置（HOST:CONTAINER） #volumes: #- /home/xx/data:/u01/app/oracle # 暴露端口（HOST:CONTAINER） ports: - 1521:1521 JDBCOracle 官网的链接：http://www.oracle.com/technetwork/database/application-development/jdbc/downloads/index.html 这里使用 Oracle 12.2.0.1 JDBC，只下载 ojdbc8.jar 就好了。（还要登录和确认协议） 本地安装：12cd 下载目录mvn install:install-file -Dfile=ojdbc8.jar -DgroupId=com.oracle -DartifactId=ojdbc8 -Dversion=12.2.0.1 -Dpackaging=jar 然后就可以在 Maven 项目里导入了： 123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;12.2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 如果上面的本地安装后 Idea 还找不到 ojdbc8，就参照下面的步骤手动将 ojdbc8 添加到本地仓库。 手动添加一般仓库位置在 /home/（用户名）/.m2/repository/ 以上面的 JDBC 版本为例，进到 com/oracle/ojdbc8/12.2.0.1（没有的话就创建这些目录），把下载的 ojdbc8.jar 放到这里，并且重命名为 ojdbc8-12.2.0.1.jar。 参考其他仓库模式，添加 pom 文件 ojdbc8-12.2.0.1.pom： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot; xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;12.2.0.1&lt;/version&gt; &lt;description&gt;POM was created from install:install-file&lt;/description&gt;&lt;/project&gt; 到此就完成了 ojdbc8 的手动添加。 这时的 Idea 还没刷新仓库内容，你可以稍微改下你的 pom.xml 文件，让其自动更新。","link":"/2018/05/21/zh/programing/docker/oracle_deploy/"},{"title":"Registry 搭建","text":"前言Docker Hub 是 Docker 公司提供的公共镜像存储空间，类似 GitHub、Maven。 和它们一样，公司为了节省网络带宽，防止一些安全问题，一般会搭建私有仓库。 本文使用的私有仓库是 Registry。 参考文章： Docker容器学习梳理–私有仓库Registry使用 Registry私有仓库搭建及认证 启动docker 会自动拉取镜像并配置运行： 123456sudo docker run --detach \\ --name registry \\ --restart always \\ --publish 5000:5000 \\ --volume /docker/registry:/tmp/registry \\ registry 默认情况下，Registry 把私有仓库存放在容器内的 /tmp/registry，一关机 /tmp 目录就删除了，所以这里就把它映射到本地的 /docker/registry。 测试这里使用官方的测试镜像测试： 1sudo docker pull hello-world 更改镜像（做过某些修改镜像）的 tag 标识： 1sudo docker tag hello-world localhost:5000/hello-world 上传到私有仓库： 1sudo docker push localhost:5000/hello-world 删除本地的镜像： 1sudo docker image remove localhost:5000/hello-world 测试拉取私有仓库的镜像： 1sudo docker pull localhost:5000/hello-world 这里因为是本地测试所以一切顺利，涉及到远程服务器的私有仓库，还需要签名认证，这里暂时不做……","link":"/2019/01/29/zh/programing/docker/registry_deploy/"},{"title":"Java 基础概念","text":"J2SE、J2EE、J2MEJ2SE（Java 2 Platform Standard Edition）标准版J2SE 主要用于开发客户端（桌面应用软件），如：常用的文本编辑器、下载软件、即时通讯工具等。 J2SE 包含了 Java 的核心类库，如数据库连接、接口定义、输入/输出、网络编程等。 J2EE（Java 2 Platform Enterprise Edition）企业版J2EE 是功能最丰富的一个版本，主要用于开发高访问量、大数据量、高并发量的网站，如：美团、去哪儿网的后台。通常所说的 JSP 开发就是 J2EE 的一部分。 J2EE 包含 J2SE 中的类，还包含用于开发企业级应用的类，如：EJB、servlet、JSP、XML、事务控制等。 J2EE 也可以用来开发技术比较庞杂的管理软件，如：ERP 系统（Enterprise Resource Planning，企业资源计划系统）。 J2ME（Java 2 Platform Micro Edition）微型版J2ME 只包含 J2SE 中的一部分类，受平台影响比较大，主要用于嵌入式系统和移动平台的开发，如：呼机、智能卡、手机、机顶盒等。 在智能手机还没有进入公众视野时，摩托罗拉、诺基亚等手机上很多 Java 小游戏就是用 J2ME 开发的。 Java 的初衷就是做这一块的开发。 注：Android 手机有自己的开发组件，不使用 J2ME 进行开发。 Java 5.0 后，J2SE、J2EE、J2ME 分别更名为 Java SE、Java EE、Java ME，由于习惯，我们依然称之为 J2SE、J2EE、J2ME。 JRE、JDKJRE（Java Runtime Environment）运行时环境包含了 Java 虚拟机，Java 基础类库。是使用 Java 语言编写的程序运行所需要的软件环境，是提供给想运行 Java 程序的用户使用的。如果需要运行 Java 程序，只需安装 JRE 即可。 根据不同操作系统（如：Windows、Linux等）和不同提供商（IBM、ORACLE等），JRE 有很多版本，最常用的是 Oracle 公司收购 SUN 公司的 JRE 版本。 JDK（Java Development Kit）开发工具包是程序员使用 Java 语言编写 Java 程序所需的开发工具包，是提供给程序员使用的。JDK 包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具：Jconsole，Jvisualvm 等工具软件，Java 程序编写所需的文档和 Demo 例子程序。如果需要编写 Java 程序，即需要安装 JDK。 语法基础Java 是一种强类型的语言，声明变量时必须指明数据类型。变量（variable）的值占据一定的内存空间。不同类型的变量占据不同的大小。 语法比较简单，重点说下：StringBuffer 与 StringBuider。 String 的值是不可变的，每次对 String 的操作都会生成新的 String 对象，不仅效率低，而且耗费大量内存空间。 StringBufferStringBuffer 类和 String 类一样，也用来表示字符串，但是 StringBuffer 的内部实现方式和 String 不同，在进行字符串处理时，不生成新的对象，在内存使用上要优于 String。 StringBuffer 默认分配 16 字节长度的缓冲区，当字符串超过该大小时，会自动增加缓冲区长度，而不是生成新的对象。 StringBuffer 只能通过 new 来创建。 12345678// 分配默认的16个字节长度的缓冲区StringBuffer str1 = new StringBuffer();// 分配512个字节长度的缓冲区StringBuffer str2 = new StringBuffer(512);// 在缓冲区中存放了字符串，并在后面预留了16个字节长度的空缓冲区StringBuffer str3 = new StringBuffer(&quot;www.xx.com&quot;); 主要方法StringBuffer 类中的方法主要偏重于对于字符串的操作，例如追加、插入和删除等，这个也是 StringBuffer 类和 String 类的主要区别。实际开发中，如果需要对一个字符串进行频繁的修改，建议使用 StringBuffer。 append()：向当前字符串的末尾追加内容，类似于字符串的连接。调用该方法以后，StringBuffer 对象的内容也发生改变。 12StringBuffer str = new StringBuffer(&quot;biancheng100&quot;);str.append(true); 对象 str 的值将变成 “biancheng100true”注意是 str 指向的内容变了，不是 str 的指向变了 字符串的 “+” 操作实际上也是先创建一个 StringBuffer 对象，然后调用 append() 方法将字符串片段拼接起来，最后调用 toString() 方法转换为字符串 这样看来，String 的连接操作就比 StringBuffer 多出了一些附加操作，效率上必然会打折扣 但是，对于长度较小的字符串，”+” 操作更加直观，更具可读性，有些时候可以稍微牺牲一下效率 deleteCharAt()：删除指定位置的字符，并将剩余的字符形成新的字符串。 123StringBuffer str = new StringBuffer(&quot;abcdef&quot;);// 删除索引值为3的字符，即”d“字符str.deleteCharAt(3); delete()：方法一次性删除多个字符。 123StringBuffer str = new StringBuffer(&quot;abcdef&quot;);// 删除索引值为 1~4 之间的字符，包括索引值 1，但不包括 4str.delete(1, 4); insert()：在指定位置插入字符串，可以认为是 append() 的升级版。 123StringBuffer str = new StringBuffer(&quot;abcdef&quot;);// 最后 str 所指向的字符串为 abcdxyzefstr.insert(3, &quot;xyz&quot;); setCharAt()：修改指定位置的字符。 123StringBuffer str = new StringBuffer(&quot;abcdef&quot;);// 把索引值为3的字符修改为 z，最后 str 所指向的字符串为 abczefstr.setCharAt(3, 'z'); StringBuilderStringBuffer 线程安全；StringBuilder 线程不安全。 StringBuffer、StringBuilder、String 中都实现了 CharSequence 接口。 CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个API。 StringBuffer、StringBuilder、String 对 CharSequence 接口的实现过程不一样： String 直接实现了 CharSequence 接口；StringBuilder 和 StringBuffer 都是可变的字符序列，它们都继承于 AbstractStringBuilder，实现了 CharSequence 接口。 面向对象编程（OOP）Java 中的类可以看做 C 语言中结构体的升级版。 结构体是一种构造数据类型，可以包含不同的成员（变量），每个成员的数据类型可以不一样；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。 结构体1234567891011121314151617181920#include &lt;stdio.h&gt;int main() { struct Student { // 结构体包含的变量 char *name; int age; float score; }; // 通过结构体来定义变量 struct Student stu1; // 操作结构体的成员 stu1.name = &quot;小明&quot;; stu1.age = 15; stu1.score = 92.5; // 小明的年龄是 15，成绩是 92.500000 printf(&quot;%s的年龄是 %d，成绩是 %f\\n&quot;, stu1.name, stu1.age, stu1.score); return 0;} Java 中的类也是一种构造数据类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象”。 类123456789101112131415161718192021222324public class Demo { public static void main(String[] args) { // 通过class关键字类定义类 class Student { // 类包含的变量 String name; int age; float score; // 类包含的函数 void say() { System.out.println( name + &quot;的年龄是 &quot; + age + &quot;，成绩是 &quot; + score ); } } // 通过类来定义变量 // 必须使用new关键字创建对象 Student stu1 = new Student(); // 操作类的成员 stu1.name = &quot;小明&quot;; stu1.age = 15; stu1.score = 92.5f; // 小明的年龄是 15，成绩是 92.5 stu1.say(); }} 在 C 语言中，通过结构体名称就可以完成结构体变量的定义，并分配内存空间；但在 Java 中，仅仅通过类来定义变量不会分配内存空间，必须使用 new 关键字来完成内存空间的分配。 类的变量：属性（通常也称成员变量），函数：方法。它们统称为类的成员。 类可以比喻成图纸，对象比喻成产品，图纸说明了产品的参数及其承担的任务；一张图纸可以生产出具有相同性质的产品，不同图纸可以生产不同类型的产品。 使用 new 关键字，就可以通过类来创建对象，即将图纸生产成产品，这个过程叫做类的实例化，因此也称对象是类的一个实例。 注：类只是一张图纸，起到说明的作用，不占用内存空间；对象才是具体的产品，要有地方来存放，才会占用内存空间。 在 C 语言中，可以将完成某个功能的重复使用的代码块定义为函数，将具有一类功能的函数声明在一个头文件中，不同类型的函数声明在不同的头文件，以便对函数进行更好的管理，方便编写和调用。 在 Java 中，可以将完成某个功能的代码块定义为方法，将具有相似功能的方法定义在一个类中，也就是定义在一个源文件中（因为一个源文件只能包含一个公共的类），多个源文件可以位于一个文件夹，这个文件夹有特定的称呼，叫做包。 面向对象编程在软件执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。 访问修饰符/访问控制符 修饰符 说明 public 共有的，对所有类可见。 protected 受保护的，对同一包内的类和所有子类可见。 private 私有的，在同一类内可见。 默认 在同一包内可见。默认不使用任何修饰符。 public：类、方法、构造方法和接口能够被任何其他类访问。类的继承性，类所有的公有方法和变量都能被其子类继承。 protected：方法和成员变量能够声明为 protected，不能修饰接口。子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。 private：方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。声明为私有访问类型的变量只能通过类中公共的 Getter/Setter 方法被外部类访问。主要用来隐藏类的实现细节和保护类的数据。 默认：接口里的变量都隐式声明为 public static final，而接口里的方法默认情况下访问权限为 public。 方法继承规则： 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。不能声明为 private（即不能越来越隐秘，只能越来越公开）。 父类中默认修饰符声明的方法，能够在子类中声明为 private。 父类中声明为 private 的方法，不能够被继承（实际是继承了，但是无法访问）。 变量的作用域类级变量/全局级变量/静态变量：使用 static 关键字修饰。类级变量在类定义后就已经存在，占用内存空间，可以通过类名来访问，不需要实例化。 对象实例级变量：成员变量，实例化后才会分配内存空间，才能访问。 方法级变量：在方法内部定义的变量，就是局部变量。 块级变量：定义在一个块内部的变量（指由大括号包围的代码），变量的生存周期就是这个块，出了这个块就消失了，比如 if、for 语句的块。 作用域1234567891011121314151617181920212223242526272829public class Demo { // 类级变量 public static String name = &quot;demo&quot;; // 对象实例级变量 public int i; // 属性块，在类初始化属性时候运行 { // 块级变量 int j = 2; } public void test1() { // 方法级变量 int j = 3; if(j == 3) { // 块级变量 int k = 5; } // 不能访问块级变量k，块级变量只能在块内部访问 System.out.println(&quot;name=&quot; + name + &quot;, i=&quot; + i + &quot;, j=&quot; + j); } public static void main(String[] args) { // 不创建对象，直接通过类名访问类级变量 System.out.println(Demo.name); // 创建对象并访问它的方法 Demo t = new Demo(); t.test1(); }} 运行：demoname=demo, i=0, j=3 方法重载方法重载（method overloading）：同一个类中的多个方法有相同的名称，但它们的参数列表不同。 不同包括：个数、类型和顺序。 仅仅参数变量名称不同是不可以的。 跟成员方法一样，构造方法也可以重载。 声明为 final 的方法不能被重载。 声明为 static 的方法不能被重载，但是能够被再次声明。 重载的规则： 方法名称必须相同。 参数列表必须不同。 方法的返回类型可以相同也可以不相同。 仅仅返回类型不同不足以成为方法的重载。 重载是面向对象的一个基本特性。 方法签名：方法名称 + 参数列表（顺序和类型）。 注：方法签名不包括：方法的返回类型，返回值和访问修饰符。 常见应用：重载和重写。 方法重载1234567891011121314151617181920public class Demo { // 一个普通的方法，不带参数 void test() { System.out.println(&quot;No parameters&quot;); } // 重载上面的方法，并且带了一个整型参数，且有整型返回值 int test(int a) { System.out.println(&quot;a: &quot; + a); return a; } public static void main(String args[]) { Demo obj= new Demo(); obj.test(); obj.test(2); }}运行：No parametersa: 2 重载的实现：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法；如果匹配失败，编译器会报错，这叫做重载分辨。 程序的基本运行顺序运行顺序123456789101112public class Demo { private String name; private int age; public Demo() { name = &quot;demo&quot;; age = 3; } public static void main(String[] args) { Demo obj = new Demo(); System.out.println(obj.name + &quot;的年龄是&quot; + obj.age); }} 顺序： 先运行到第 8 行，这是程序的入口。 然后运行到第 9 行，这里要 new 一个Demo，就要调用 Demo 的构造方法。 就运行到第 4 行，注意：初始化一个类，必须先初始化它的属性。 因此运行到第 2 行，然后是第 3 行。 属性初始化完过后，才回到构造方法，执行里面的代码，也就是第 5 行、第 6 行。 然后是第 9 行，表示 new 一个Demo实例完成。 然后回到 main 方法中执行第 10 行。 然后是第 11 行，main方法执行完毕。 总结：程序入口 -&gt; 类属性 -&gt; 构造方法 复杂情况下的初始化： 父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； 父类的普通成员变量和代码块，再执行父类的构造方法； 子类的普通成员变量和代码块，再执行子类的构造方法； 包装类、拆箱和装箱 基本数据类型 对应的包装类 boolean Boolean byte Byte short Short int Integer long Long char Character float Float double Double 基本数据类型 占用的字节数 取值范围 默认值 boolean 1 ture / flase flase byte 1 -128 ~ 127 0 short 2 -2^15 ~ 2^15-1 0 int 4 -2^31 ~ 2^31-1 0 long 8 -2^63 ~ 2^63-1 0 char 2 0 ~ 2^16-1 \\u0000 float 4 0x0.000002P-126f ~ 0x1.fffffeP+127f 0.0f double 8 0x0.0000000000001P-1022 ~ 0x1.fffffffffffffP+1023 0.0d 基本类型和对应的包装类相互装换： 装箱：由基本类型向对应的包装类转换，如把 int 包装成 Integer 类的对象。 拆箱：包装类向对应的基本类型转换，如把 Integer 类的对象重新简化为 int。 Java 1.5 前必须手动拆箱装箱： 123456789101112131415public class Demo { public static void main(String[] args) { int m = 500; // 手动装箱 Integer obj = new Integer(m); // 手动拆箱 int n = obj.intValue(); // n = 500 System.out.println(&quot;n = &quot; + n); Integer obj1 = new Integer(500); // obj 等价于 obj1？true System.out.println(&quot;obj 等价于 obj1？&quot; + obj.equals(obj1)); }} Java 1.5 后系统自动拆箱装箱： 123456789101112131415public class Demo { public static void main(String[] args) { int m = 500; // 自动装箱 Integer obj = m; // 自动拆箱 int n = obj; // n = 500 System.out.println(&quot;n = &quot; + n); Integer obj1 = 500; // obj 等价于 obj1？true System.out.println(&quot;obj 等价于 obj1？&quot; + obj.equals(obj1)); }} 继承继承（extends）是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。 继承可以理解为一个类从另一个类获取方法和属性的过程。如果类 B 继承于类 A，那么 B 就拥有 A 的方法和属性。 1234567891011121314151617181920212223242526class People { String name; int age; int height; void say() { System.out.println(&quot;我的名字是 &quot; + name + &quot;，年龄是 &quot; + age + &quot;，身高是 &quot; + height); }}// 教师属于人类，可以继承最基本的属性class Teacher extends People { String school; // 所在学校 String subject; // 学科 int seniority; // 教龄 // 覆盖 People 类中的 say() 方法 @Override void say() { System.out.println(&quot;我叫&quot; + name + &quot;，在&quot; + school + &quot;教&quot; + subject + &quot;，有&quot; + seniority + &quot;年教龄&quot;); } void lecturing() { System.out.println(&quot;我已经&quot; + age + &quot;岁了，依然站在讲台上讲课&quot;); }} 注：构造方法不能被继承。一个类能得到构造方法，只有两个办法：编写构造方法，或者根本没有构造方法，类有一个默认的构造方法。 super功能： 调用父类中声明为 private 的变量。 获取已经覆盖了的方法。 作为方法名表示父类构造方法。 super1234567891011121314151617181920212223242526272829public class Demo { public static void main(String[] args) { new Dog().move(); }}class Animal { private String desc = &quot;动物是人类的好朋友&quot;; // 必须要声明一个 getter 方法 public String getDesc() { return desc; } public void move() { System.out.println(&quot;动物可以动&quot;); }}class Dog extends Animal { public void move() { // 调用父类的方法 super.move(); System.out.println(&quot;狗狗可以走可以跑&quot;); // 通过 getter 方法调用父类隐藏变量 System.out.println(&quot;请记住：&quot; + super.getDesc()); }}运行：动物可以动狗狗可以走可以跑请记住：动物是人类的好朋友 move() 方法也可以定义在某些祖先类中，比如父类的父类，Java 具有追溯性，会一直向上找，直到找到该方法为止。 通过 super 调用父类的隐藏变量，必须要在父类中声明 getter 方法，因为声明为 private 的数据成员对子类是不可见的。 不可见1234567891011121314151617181920212223242526public class Demo { public static void main(String[] args) { new Dog(&quot;花花&quot;, 3).say(); }}class Animal { String name; public Animal(String name) { this.name = name; }}class Dog extends Animal { int age; public Dog(String name, int age) { super(name); this.age = age; } public void say() { System.out.println(&quot;我是一只可爱的小狗，我的名字叫&quot; + name + &quot;，我&quot; + age + &quot;岁了&quot;); }}运行：我是一只可爱的小狗，我的名字叫花花，我3岁了 注： 在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。 不能在构造方法以外的任何方法内调用构造方法。 在一个构造方法内只能调用一个构造方法。 如果编写一个构造方法，既没有调用 super() 也没有调用 this()，编译器会自动插入一个调用到父类构造方法中，而且不带参数。 继承中方法的覆盖和重载覆盖和重载12345678910111213141516171819202122232425262728293031323334353637public class Demo { public static void main(String[] args) { Dog myDog = new Dog(&quot;花花&quot;); // 子类的实例调用子类中的方法 myDog.say(); Animal myAnmial = new Animal(&quot;贝贝&quot;); // 父类的实例调用父类中的方法 myAnmial.say(); }}class Animal { String name; public Animal(String name) { this.name = name; } public void say() { System.out.println(&quot;我是一只小动物，我的名字叫&quot; + name + &quot;，我会发出叫声&quot;); }}class Dog extends Animal { // 构造方法不能被继承，只能通过super()调用 public Dog(String name) { super(name); } // 覆盖say() 方法 @Override public void say() { System.out.println(&quot;我是一只小狗，我的名字叫&quot; + name + &quot;，我会发出汪汪的叫声&quot;); }}运行：我是一只小狗，我的名字叫花花，我会发出汪汪的叫声我是一只小动物，我的名字叫贝贝，我会发出叫声 覆盖原则： 覆盖方法的返回类型、方法名称、参数列表必须与原方法的相同。 覆盖方法不能比原方法访问性差（即访问权限不允许缩小）。 覆盖方法不能比原方法抛出更多的异常。 被覆盖的方法不能是 final 类型，因为 final 修饰的方法是无法覆盖的。 被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 被覆盖的方法不能为 static。（覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用） 覆盖和重载的不同： 方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致。 方法覆盖要求返回类型必须一致，方法重载对此没有要求。 方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法（包括从父类中继承而来的方法）。 方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。 父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中可以被重载多次。 多态父类的变量可以引用父类的实例，也可以引用子类的实例。 123456789101112131415161718192021222324252627282930313233343536373839public class Demo { public static void main(String[] args) { Animal obj = new Animal(); obj.cry(); obj = new Cat(); obj.cry(); obj = new Dog(); obj.cry(); }}class Animal { // 动物的叫声 public void cry() { System.out.println(&quot;不知道怎么叫&quot;); }}class Cat extends Animal { // 猫的叫声 @Override public void cry() { System.out.println(&quot;喵喵~&quot;); }}class Dog extends Animal { // 狗的叫声 @Override public void cry() { System.out.println(&quot;汪汪~&quot;); }}运行：不知道怎么叫喵喵~汪汪~ obj 变量的类型为 Animal，它既可以指向 Animal 类的实例，也可以指向 Cat 和 Dog 类的实例。也就是说，父类的变量可以引用父类的实例，也可以引用子类的实例。注意反过来是错误的，因为所有的猫都是动物，但不是所有的动物都是猫。 obj 既可以是人类，也可以是猫、狗，它有不同的表现形式，这就被称为多态。多态是指一个事物有不同的表现形式或形态。 多态存在的三个必要条件：要有继承、要有重写、父类变量引用子类对象。 当使用多态方式调用方法时： 首先检查父类中是否有该方法，如果没有，则编译错误；如果有，则检查子类是否覆盖了该方法。 如果子类覆盖了该方法，就调用子类的方法，否则调用父类方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Demo { public static void main(String[] args) { // 借助多态，主人可以给很多动物喂食 Master master = new Master(); master.feed(new Animal(), new Food()); master.feed(new Cat(), new Fish()); master.feed(new Dog(), new Bone()); }}class Animal { public void eat(Food food) { System.out.println(&quot;我是一个小动物，正在吃&quot; + f.getFood()); }}class Cat extends Animal { public void eat(Food food) { System.out.println(&quot;我是一只小猫咪，正在吃&quot; + f.getFood()); }}class Dog extends Animal { public void eat(Food food) { System.out.println(&quot;我是一只狗狗，正在吃&quot; + f.getFood()); }}class Food { public String getFood() { return &quot;事物&quot;; }}class Fish extends Food { public String getFood() { return &quot;鱼&quot;; }}class Bone extends Food { public String getFood() { return &quot;骨头&quot;; }}class Master { public void feed(Animal animal, Food food) { animal.eat(food); }}运行：我是一个小动物，正在吃事物我是一只小猫咪，正在吃鱼我是一只狗狗，正在吃骨头 Master 类的 feed 方法有两个参数，分别是 Animal 类型和 Food 类型，因为是父类，所以可以将子类的实例传递给它，这样 Master 类就不需要多个方法来给不同的动物喂食。 instanceof判断对象类型： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class Demo { public static void main(String[] args) { // 引用 People 类的实例 People obj = new People(); if(obj instanceof Object) { System.out.println(&quot;我是一个对象&quot;); } if(obj instanceof People) { System.out.println(&quot;我是人类&quot;); } if(obj instanceof Teacher) { System.out.println(&quot;我是一名教师&quot;); } if(obj instanceof President) { System.out.println(&quot;我是校长&quot;); } // 引用 Teacher 类的实例 obj = new Teacher(); if(obj instanceof Object) { System.out.println(&quot;我是一个对象&quot;); } if(obj instanceof People) { System.out.println(&quot;我是人类&quot;); } if(obj instanceof Teacher) { System.out.println(&quot;我是一名教师&quot;); } if(obj instanceof President) { System.out.println(&quot;我是校长&quot;); } }}class People { }class Teacher extends People { }class President extends Teacher { }运行：我是一个对象我是人类我是一个对象我是人类我是一名教师 staticstatic 修饰符能够与变量、方法一起使用，表示静态。 静态变量和静态方法能够通过类名来访问，不需要创建一个类的对象来访问该类的静态成员，所以 static 修饰的成员又称作类变量和类方法。 静态变量与实例变量不同，实例变量总是通过对象来访问，因为它们的值在对象和对象之间有所不同。 static 的内存分配 静态变量属于类，不属于任何独立的对象，所以无需创建类的实例就可以访问静态变量。 编译器只为整个类创建了一个静态变量的副本，也就是只分配一个内存空间，虽然有多个实例，但这些实例共享该内存（类变量）。 实例变量则不同，每创建一个对象，都会分配一次内存空间，不同变量的内存相互独立，互不影响。 共享和相互独立123456789101112131415161718public class Demo { static int i; int j; public static void main(String[] args) { Demo a = new Demo(); a.i = 10; a.j = 20; Demo b = new Demo(); System.out.println(&quot;a.i=&quot; + a.i + &quot;, a.j=&quot; + a.j); System.out.println(&quot;b.i=&quot; + b.i + &quot;, b.j=&quot; + b.j); }}运行：a.i=10, a.j=20b.i=10, b.j=0 注： 静态变量也可以通过对象来访问，但不提倡，编译器也会产生警告。 静态变量在类装载的时候就会被初始化。也就是说，只要类被装载，不管你是否使用了这个 static 变量，它都会被初始化，并占用内存。 以下情形可以使用静态方法： 方法不需要访问对象状态，其所需参数都是通过显式参数提供，比如 Math.pow()。 方法只需要访问类的静态变量。 总结： 静态方法只能访问静态变量； 静态方法不能够直接调用非静态方法； 如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但不被推荐； 静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super； 静态方法不能被非静态方法覆盖； 构造方法不允许声明为 static； 局部变量不能使用 static 修饰。 静态初始器/静态块(Static Initializer) 静态初始器是一个存在于类中、方法外面的静态块。静态初始器仅仅在类装载的时候执行一次，往往用来初始化静态变量。 12345678910111213141516171819202122public class Demo { public static int i; static { i = 10; System.out.println(&quot;运行到了静态块&quot;); } public void test() { System.out.println(&quot;i=&quot; + i); } public static void main(String[] args) { System.out.println(&quot;Demo.i=&quot; + Demo.i); new Demo().test(); }}运行：运行到了静态块Demo.i=10i=10 静态导入：对于使用频繁的静态变量和静态方法，可以将其静态导入，简化一些操作，例如输出语句 System.out.println(); 中的 out 就是 System 类的静态变量。 12import static packageName.className.methonName; // 导入某个特定的静态方法import static packageName.className.*; // 导入类中的所有静态成员 System静态导入12345678import static java.lang.System.*;import static java.lang.Math.random;public class Demo { public static void main(String[] args) { out.println(&quot;产生的一个随机数：&quot; + random()); }} 问：是否可以在 static 环境中访问非 static 变量？答：static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 finalfinal 所修饰的数据具有“终态”的特征，表示“最终”。规定如下： 修饰的类不能被继承。 修饰的方法不能被子类重写。 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。 1234567891011121314151617181920public final class Demo { public static final int TOTAL_NUMBER = 5; public int id; public Demo() { // 非法，对 final 变量 TOTAL_NUMBER 进行了二次赋值 // 因为 ++TOTAL_NUMBER 相当于 TOTAL_NUMBER = TOTAL_NUMBER + 1 id = ++TOTAL_NUMBER; } public static void main(String[] args) { final Demo t = new Demo(); final int i = 10; final int j; // 一次性的赋值 j = 20; // 非法，对 final 变量 j 进行二次赋值 j = 30; }} 注： 一旦将一个类声明为 final，那么该类包含的方法也将被隐式地声明为 final，但是变量不是。 被 final 修饰的方法为静态绑定，不会产生多态（动态绑定），程序在运行时不需要再检索方法表，能够提高代码的执行效率。 被 static 或 private 修饰的方法会被隐式的声明为 final。 内部类内部类（Inner Class）/嵌套类（Nested Class）：在一个类（或方法、语句块）的内部定义另一个类。 内部类和外层封装它的类之间存在逻辑上的所属关系，一般只用在定义它的类或语句块之内，实现一些没有通用意义的功能逻辑，在外部引用它时必须给出完整的名称。 使用内部类的原因： 内部类可以访问外部类中的数据，包括私有的数据。 内部类可以对同一个包中的其他类隐藏起来。 当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷。 减少类的命名冲突。 1234567891011121314151617181920public class Outer { private int size; public class Inner { private int counter = 10; public void doStuff() { size++; } } public static void main(String args[]) { Outer outer = new Outer(); Inner inner = outer.new Inner(); inner.doStuff(); System.out.println(outer.size); System.out.println(inner.counter); // 编译错误，外部类不能访问内部类的变量 System.out.println(counter); }} 注：必须先有外部类的对象才能生成内部类的对象，因为内部类需要访问外部类中的成员变量，成员变量必须实例化才有意义。 静态内部类、匿名内部类、成员式内部类和局部内部类http://www.weixueyuan.net/view/6007.html abstract在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。 从某种角度看，祖先类更加通用，它只包含一些最基本的成员，人们只将它作为派生其他类的基类，而不会用来创建对象。甚至，你可以只给出方法的定义而不实现，由子类根据具体需求来具体实现。 这种只给出定义而不具体实现的方法被称为抽象方法，抽象方法是没有方法体的，在代码的表达上就是没有“{}”。包含一个或多个抽象方法的类也必须被声明为抽象类。 使用 abstract 修饰符来表示抽象方法和抽象类。 抽象类除了包含抽象方法外，还可以包含具体的变量和具体的方法。类即使不包含抽象方法，也可以被声明为抽象类，防止被实例化。 抽象类不能被实例化，抽象方法必须在子类中被实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Demo { public static void main(String[] args) { Teacher teacher = new Teacher(); teacher.setName(&quot;王明&quot;); // 我的名字叫王明，我正在讲课，请大家不要东张西望... teacher.work(); Driver driver = new Driver(); driver.setName(&quot;小陈&quot;); // 我的名字叫小陈，我正在开车，不能接听电话... driver.work(); }}// 定义一个抽象类abstract class People { // 实例变量 private String name; // 共有的 setter 和 getter 方法 public void setName(String name) { this.name = name; } public String getName() { return this.name; } // 抽象方法 public abstract void work();}class Teacher extends People { // 必须实现该方法 @Override public void work() { System.out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在讲课，请大家不要东张西望...&quot;); }}class Driver extends People { // 必须实现该方法 @Override public void work() { System.out.println(&quot;我的名字叫&quot; + this.getName() + &quot;，我正在开车，不能接听电话...&quot;); }} 关于抽象类的几点说明： 抽象类不能直接使用，必须用子类去实现抽象类，然后使用其子类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例，也就是可以使用抽象类来充当形参，实际实现类作为实参，也就是多态的应用。 不能有抽象构造方法或抽象静态方法。 在下列情况下，一个类将成为抽象类： 当一个类的一个或多个方法是抽象方法时； 当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法主体时； 当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法主体时。 注：这里说的是这些情况下一个类将成为抽象类，没有说抽象类一定会有这些情况。 一个典型的错误：抽象类一定包含抽象方法。但是反过来说：“包含抽象方法的类一定是抽象类”就是正确的。 事实上，抽象类可以是一个完全正常实现的类。 interface在抽象类中，可以包含一个或多个抽象方法；但在接口（interface）中，所有的方法必须都是抽象的，不能有方法体，它比抽象类更加“抽象”。 接口使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。 现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。 希捷、日立、三星等生产厂家会按照规范生产符合接口的硬盘，这些硬盘就可以实现通用化，如果正在用一块160G日立的串口硬盘，现在要升级了，可以购买一块320G的希捷串口硬盘，安装上去就可以继续使用了。 模拟 Serial ATA 委员会定义以下串口硬盘接口： 123456789// 串行硬盘接口public interface SataHdd { // 连接线的数量 int CONNECT_LINE=4; // 写数据 void writeData(String data); // 读数据 String readData();} 注：接口中声明的成员变量默认都是 public static final，因而在常量声明时可以省略这些修饰符。 接口是若干常量和抽象方法的集合，目前看来和抽象类差不多。确实如此，接口本就是从抽象类中演化而来的，因而除特别规定，接口享有和类同样的“待遇”。比如，源程序中可以定义多个类或接口，但最多只能有一个 public 的类或接口，如果有则源文件必须取和 public 的类和接口相同的名字。和类的继承格式一样，接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法并添加新的抽象方法等。 但接口有其自身的一些特性，归纳如下： 接口中只能定义抽象方法，试图在接口中定义实例变量、非抽象的实例方法及静态方法，都是非法的。例如： 12345678910111213141516public interface SataHdd { // 连接线的数量 public int connectLine; // 编译出错：connectLine 被看做静态常量，必须显式初始化即 connectLine = 4 // 写数据 protected void writeData(String data); // 编译出错：必须是 public 类型 // 读数据 public static String readData() { // 编译出错：接口中不能包含静态方法 return &quot;数据&quot;; } // 编译出错：接口中只能包含抽象方法，即没有“{具体实现代码}”} 接口中没有构造方法，不能被实例化。 一个接口不实现另一个接口，但可以继承多个其他接口。 接口的多继承特点弥补了类的单继承： 1234567891011121314151617// 串行硬盘接口public interface SataHdd extends A, B { // 连接线的数量 int CONNECT_LINE = 4; // 写数据 void writeData(String data); // 读数据 String readData();}interface A { public void a();}interface B { public void b();} 为什么使用接口大型项目开发中，可能需要从继承链的中间插入一个类，让它的子类具备某些功能而不影响它们的父类。 比如继承链：A -&gt; B -&gt; C -&gt; D -&gt; E。A 是祖先类，如果需要为 C、D、E 类添加某些通用的功能，最简单的方法是让 C 类再继承另外一个类。 但问题来了，Java 是一种单继承的语言，不能再让 C 继承另外一个父类了，只能让继承链的最顶端 A 再继承一个父类。这样一来，对 C、D、E 类的修改，影响到了整个继承链，不具备可插入性的设计。 接口是可插入性的保证。在一个继承链中的任何一个类都可以实现一个接口，这个接口会影响到此类的所有子类，但不会影响到此类的任何父类。此类将不得不实现这个接口所规定的方法，而子类可以从此类自动继承这些方法，这时候，这些子类具有了可插入性。 我们关心的不是哪一个具体的类，而是这个类是否实现了我们需要的接口。 接口提供了关联以及方法调用上的可插入性，软件系统的规模越大，生命周期越长，接口使得软件系统的灵活性和可扩展性，可插入性方面得到保证。 接口在面向对象的 Java 程序设计中占有举足轻重的地位。事实上在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。 接口的使用接口的使用与类的使用有些不同。在需要使用类的地方，会直接使用 new 关键字来构建一个类的实例，但接口不可以这样使用，因为接口不能直接使用 new 关键字来构建实例。 注： 接口必须通过类来实现（implements）它的抽象方法，然后再实例化类。 如果一个类不能实现该接口的所有抽象方法，那么这个类必须被定义为抽象方法。 不允许创建接口的实例，但允许定义接口类型的引用变量，该变量指向了实现接口的类的实例。 一个类只能继承一个父类，但却可以实现多个接口。 实现接口的格式： 123修饰符 class 类名 extends 父类 implements 多个接口（A, B...） { 实现方法} 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Demo { public static void main(String[] args) { // 初始化希捷硬盘 SataHdd sh1 = new SeagateHdd(); // 初始化三星硬盘 SataHdd sh2 = new SamsungHdd(); }}// 串行硬盘接口interface SataHdd { // 连接线的数量 int CONNECT_LINE = 4; // 写数据 void writeData(String data); // 读数据 String readData();}// 维修硬盘接口interface fixHdd { // 维修地址 String address = &quot;北京市海淀区&quot;; // 开始维修 boolean doFix();}// 希捷硬盘class SeagateHdd implements SataHdd, fixHdd { // 希捷硬盘读取数据 public String readData() { return &quot;数据&quot;; } // 希捷硬盘写入数据 public void writeData(String data) { System.out.println(&quot;写入成功&quot;); } // 维修希捷硬盘 public boolean doFix() { return true; }}// 三星硬盘class SamsungHdd implements SataHdd { // 三星硬盘读取数据 public String readData() { return &quot;数据&quot;; } // 三星硬盘写入数据 public void writeData(String data) { System.out.println(&quot;写入成功&quot;); }}// 某劣质硬盘，不能写数据abstract class XXHdd implements SataHdd { // 硬盘读取数据 public String readData() { return &quot;数据&quot;; }} 接口作为类型使用接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，通过这些变量可以访问类中所实现的接口中的方法，Java 运行时系统会动态地确定应该使用哪个类中的方法，实际上是调用相应的实现类的方法。 接口可以作为一个类型来使用，如作为方法的参数和返回类型： 123456789101112131415161718192021222324public class Demo { // 变量a使用A接口类型 public static void test1(A a) { // 调用相应的实现类B的方法 a.doSth(); } public static void main(String[] args) { A a = new B(); // now in B test1(a); }}interface A { int doSth();}class B implements A { public int doSth() { System.out.println(&quot;now in B&quot;); return 123; }} 接口和抽象类的区别类是对象的模板，抽象类和接口可以看做是具体的类的模板。 由于从某种角度讲，接口是一种特殊的抽象类，它们的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。 相同点： 都代表类树形结构的抽象层。在使用引用变量时，尽量使用类结构的抽象层，使方法的定义和实现分离，这样做对于代码有松散耦合的好处。 都不能被实例化。 都能包含抽象方法。抽象方法用来描述系统提供哪些功能，而不必关心具体的实现。 区别： 抽象类可以为部分方法提供实现，避免了在子类中重复实现这些方法，提高了代码的可重用性，这是抽象类的优势；而接口中只能包含抽象方法，不能包含任何实现。 12345678910111213141516171819202122public abstract class A { // A 没有定义 method1 的实现 // 也就是说 B、C 可以根据自己的特点实现该方法，体现了松散耦合的特性 public abstract void method1(); public void method2() { // A 实现 method2 方法，避免 B、C 子类重复实现 // A 为子类提供了公共的功能，或说 A 约束了子类的行为 }}public class B extends A { public void method1() { // B method1 }}public class C extends A { public void method1() { // C method1 }} 再换成接口看看： 123456789101112131415161718192021222324public interface A { // 接口 A 无法为实现类 B、C 提供公共的功能，也就是说 A 无法约束 B、C 的行为 // B、C 可以自由地发挥自己的特点现实 method1 和 method2 方法，而接口 A 毫无掌控能力 public void method1(); public void method2();}public class B implements A { public void method1() { // B method1 } public void method2() { // B method2 }}public class C implements A { public void method1() { // C method1 } public void method2() { // C method2 }} 一个类只能继承一个直接的父类（可能是抽象类），但一个类可以实现多个接口，这个就是接口的优势。 123456789101112131415161718192021222324252627282930313233343536373839// 接口类interface A { public void method1();}interface B { public void method2();}class C implements A, B { public void method1() { // C method1 } public void method2() { // C method2 }}// 可以灵活的使用 C// 并且 C 还有机会进行扩展，实现其他接口A a = new C();B b = new C();// 抽象类abstract class A { public abstract void method1();}abstract class B extends A { public abstract void method2();}// 对于 C 类，将没有机会继承其他父类了class C extends B { public void method1() { // C method1 } public void method2() { // C method2 }} 综上所述，接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守：行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。 泛型使用变量之前要定义，定义一个变量时必须要指明它的数据类型，什么样的数据类型赋给什么样的值。 假如我们现在要定义一个类来表示坐标，要求坐标的数据类型可以是整数、小数和字符串，例如： 123x = 10、y = 10x = 12.88、y = 129.65x = &quot;东京180度&quot;、y = &quot;北纬210度&quot; 针对不同的数据类型，除了借助方法重载，还可以借助自动装箱和向上转型。我们知道，基本数据类型可以自动装箱，被转换成对应的包装类；Object 是所有类的祖先类，任何一个类的实例都可以向上转型为 Object 类型： 123int --&gt; Integer --&gt; Objectdouble --&gt; Double --&gt; ObjectString --&gt; Object 这样，只需要定义一个方法，就可以接收所有类型的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Demo { public static void main(String[] args) { Point p = new Point(); // int -&gt; Integer -&gt; Object p.setX(10); p.setY(20); // 必须向下转型 int x = (Integer) p.getX(); int y = (Integer) p.getY(); System.out.println(&quot;This point is：&quot; + x + &quot;, &quot; + y); // double -&gt; Integer -&gt; Object p.setX(25.4); // String --&gt; Object p.setY(&quot;东京180度&quot;); // 必须向下转型 double m = (Double) p.getX(); // 运行期间抛出异常，因为 String 不能被转换成 Double double n = (Double) p.getY(); System.out.println(&quot;This point is：&quot; + m + &quot;, &quot; + n); }}class Point { Object x = 0; Object y = 0; public Object getX() { return x; } public void setX(Object x) { this.x = x; } public Object getY() { return y; } public void setY(Object y) { this.y = y; }} 上面的代码中，生成坐标时不会有任何问题，但是取出坐标时，要向下转型，在 Java 多态对象的类型转换中我们讲到，向下转型存在风险，而且编译期间不容易发现，只有在运行期间才会抛出异常，所以要尽量避免使用向下转型。运行上面的代码，第12行会抛出 java.lang.ClassCastException 异常。 如何既可以不使用重载（有重复代码），又能把风险降到最低呢？使用泛型类(Java Class)，它可以接受任意类型的数据。所谓“泛型”，就是“宽泛的数据类型”，任意的数据类型。 更改上面的代码，使用泛型类： 12345678910111213141516171819202122232425262728293031323334353637383940public class Demo { public static void main(String[] args) { // 实例化泛型类 Point&lt;Integer, Integer&gt; p1 = new Point&lt;&gt;(); p1.setX(10); p1.setY(20); int x = p1.getX(); int y = p1.getY(); System.out.println(&quot;This point is：&quot; + x + &quot;, &quot; + y); Point&lt;Double, String&gt; p2 = new Point&lt;&gt;(); p2.setX(25.4); p2.setY(&quot;东京180度&quot;); double m = p2.getX(); String n = p2.getY(); System.out.println(&quot;This point is：&quot; + m + &quot;, &quot; + n); }}// 定义泛型类class Point&lt;T1, T2&gt; { T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; }} 与普通类的定义相比，上面的代码在类名后面多出了 &lt;T1, T2&gt;，T1, T2 是自定义的标识符，也是参数，用来传递数据的类型，而不是数据的值，我们称之为类型参数。在泛型中，不但数据的值可以通过参数传递，数据的类型也可以通过参数传递。T1, T2 只是数据类型的占位符，运行时会被替换为真正的数据类型。 传值参数（我们通常所说的参数）由小括号包围，如 (int x, double y)，类型参数（泛型参数）由尖括号包围，多个参数由逗号分隔，如 或 &lt;T, E&gt;。 类型参数需要在类名后面给出。一旦给出了类型参数，就可以在类中使用了。类型参数必须是一个合法的标识符，习惯上使用单个大写字母，通常情况下：K 表示键、V 表示值、E 表示异常或错误、T 表示一般意义上的数据类型。 泛型类在实例化时必须指出具体的类型，也就是向类型参数传值： 1className variable&lt;dataType1, dataType2&gt; = new className&lt;&gt;(); 注： 泛型是 Java 1.5 的新增特性，它以 C++ 模板为参照，本质是参数化类型（Parameterized Type）的应用。 类型参数只能用来表示引用类型，不能用来表示基本类型，如 int、double、char 等。但是传递基本类型不会报错，因为它们会自动装箱成对应的包装类。 泛型方法除了定义泛型类，还可以定义泛型方法，例如，定义一个打印坐标的泛型方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Demo { public static void main(String[] args) { // 实例化泛型类 Point&lt;Integer, Integer&gt; p1 = new Point&lt;Integer, Integer&gt;(); p1.setX(10); p1.setY(20); p1.printPoint(p1.getX(), p1.getY()); Point&lt;Double, String&gt; p2 = new Point&lt;Double, String&gt;(); p2.setX(25.4); p2.setY(&quot;东京180度&quot;); p2.printPoint(p2.getX(), p2.getY()); }}// 定义泛型类class Point&lt;T1, T2&gt; { T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; } // 定义泛型方法 public &lt;T1, T2&gt; void printPoint(T1 x, T2 y) { T1 m = x; T2 n = y; System.out.println(&quot;This point is：&quot; + m + &quot;, &quot; + n); }} 上面的代码中定义了一个泛型方法 printPoint()，既有普通参数，也有类型参数，类型参数需要放在修饰符后面、返回值类型前面。一旦定义了类型参数，就可以在参数列表、方法体和返回值类型中使用了。 与使用泛型类不同，使用泛型方法时不必指明参数类型，编译器会根据传递的参数自动查找出具体的类型。泛型方法除了定义不同，调用就像普通方法一样。 注：泛型方法与泛型类没有必然的联系，泛型方法有自己的类型参数，在普通类中也可以定义泛型方法。泛型方法 printPoint() 中的类型参数 T1, T2 与泛型类 Point 中的 T1, T2 没有必然的联系，也可以使用其他的标识符代替： 12345public static &lt;V1, V2&gt; void printPoint(V1 x, V2 y) { V1 m = x; V2 n = y; System.out.println(&quot;This point is：&quot; + m + &quot;, &quot; + n);} 泛型接口在 Java 中也可以定义泛型接口，这里不再赘述，仅仅给出示例代码： 1234567891011121314151617181920212223242526272829public class Demo { public static void main(String arsg[]) { Info&lt;String&gt; obj = new InfoImp&lt;&gt;(&quot;www.xx.com&quot;); System.out.println(&quot;Length Of String: &quot; + obj.getVar().length()); }}// 定义泛型接口interface Info&lt;T&gt; { public T getVar();}// 实现接口class InfoImp&lt;T&gt; implements Info&lt;T&gt; { private T var; // 定义泛型构造方法 public InfoImp(T var) { this.setVar(var); } public void setVar(T var) { this.var = var; } public T getVar() { return this.var; }} 类型擦除如果在使用泛型时没有指明数据类型，那么就会擦除泛型类型： 123456789101112131415161718192021222324252627282930313233public class Demo { public static void main(String[] args) { // 类型擦除 Point p = new Point(); p.setX(10); p.setY(20.8); // 向下转型 int x = (Integer) p.getX(); double y = (Double) p.getY(); System.out.println(&quot;This point is：&quot; + x + &quot;, &quot; + y); }}class Point&lt;T1, T2&gt; { T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; }} 因为在使用泛型时没有指明数据类型，为了不出现错误，编译器会将所有数据向上转型为 Object，所以在取出坐标使用时要向下转型，这与本文一开始不使用泛型没什么两样。 限制泛型的可用类型在上面的代码中，类型参数可以接受任意的数据类型，只要它是被定义过的。但是，很多时候我们只需要一部分数据类型就够了，用户传递其他数据类型可能会引起错误。 例如，编写一个泛型函数用于返回不同类型数组（Integer 数组、Double 数组、Character 数组等）中的最大值： 1234567public &lt;T&gt; T getMax(T array[]) { T max = null; for(T element : array) { max = element.doubleValue() &gt; max.doubleValue() ? element : max; } return max;} 上面的代码会报错，doubleValue() 是 Number 类的方法，不是所有的类都有该方法，所以我们要限制类型参数 T，让它只能接受 Number 及其子类（Integer、Double、Character 等）。 通过 extends 关键字可以限制泛型的类型： 12345678// &lt;T extends Number&gt; 表示 T 只接受 Number 及其子类，传入其他类型的数据会报错public &lt;T extends Number&gt; T getMax(T array[]) { T max = null; for(T element : array) { max = element.doubleValue() &gt; max.doubleValue() ? element : max; } return max;} 注： extends 后可以是类也可以是接口。如果是类，只能有一个；如果是接口，可以有多个，并以“&amp;”分隔，如 &lt;T extends Interface1 &amp; Interface2&gt;。 extends 不是继承的含义，应该理解为 T 是继承自 Number 类的类型，或者 T 是实现了 XX 接口的类型。 ? 泛型通配符在类型擦除中我们定义了泛型类 Point&lt;T1, T2&gt; 来表示坐标，坐标可以是整数、小数或字符串： 12345678910111213141516class Point&lt;T1, T2&gt; { T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; }} 现在要求在其他类，比如 APoint 类定义一个 printPoint() 方法用于输出坐标，怎么办？可以这样定义方法： 123public void printPoint(Point p) { System.out.println(&quot;This point is: &quot; + p.getX() + &quot;, &quot; + p.getY());} 但如果在使用泛型时没有指名具体的数据类型，就会擦除泛型类型，并向上转型为 Object，这与不使用泛型没什么两样。上面的代码没有指明数据类型，相当于： 123public void printPoint(Point&lt;Object, Object&gt; p) { System.out.println(&quot;This point is: &quot; + p.getX() + &quot;, &quot; + p.getY());} 为了避免类型擦除，可以使用通配符 ?（可以表示任意的数据类型）： 123public void printPoint(Point&lt;?, ?&gt; p) { System.out.println(&quot;This point is: &quot; + p.getX() + &quot;, &quot; + p.getY());} 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839public class Demo { public static void main(String[] args) { Point&lt;Integer, Integer&gt; p1 = new Point&lt;&gt;(); p1.setX(10); p1.setY(20); printPoint(p1); Point&lt;String, String&gt; p2 = new Point&lt;&gt;(); p2.setX(&quot;东京180度&quot;); p2.setY(&quot;北纬210度&quot;); printPoint(p2); } // 使用通配符 public static void printPoint(Point&lt;?, ?&gt; p) { System.out.println(&quot;This point is: &quot; + p.getX() + &quot;, &quot; + p.getY()); }}class Point&lt;T1, T2&gt; { T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; }} 但是，数字坐标与字符串坐标又有区别：数字可以表示 x 轴或 y 轴的坐标，字符串可以表示地球经纬度。 现在又要求定义两个方法分别处理不同的坐标，一个方法只能接受数字类型的坐标，另一个方法只能接受字符串类型的坐标，怎么办？ 这个问题的关键是要限制类型参数的范围： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Demo { public static void main(String[] args) { Point&lt;Integer, Integer&gt; p1 = new Point&lt;&gt;(); p1.setX(10); p1.setY(20); printNumPoint(p1); Point&lt;String, String&gt; p2 = new Point&lt;&gt;(); p2.setX(&quot;东京180度&quot;); p2.setY(&quot;北纬210度&quot;); printStrPoint(p2); } // 借助通配符限制泛型的范围 // ? extends Number 表示泛型的类型参数只能是 Number 及其子类，&lt;? extends String&gt; 也一样，这与定义泛型类或泛型方法时限制类型参数的范围类似。 // 不过，使用通配符 `?` 不但可以限制类型的上限，还可以限制下限。限制下限使用 super 关键字，例如 &lt;? super Number&gt; 表示只能接受 Number 及其父类。 public static void printNumPoint(Point&lt;? extends Number, ? extends Number&gt; p) { System.out.println(&quot;x: &quot; + p.getX() + &quot;, y: &quot; + p.getY()); } public static void printStrPoint(Point&lt;? extends String, ? extends String&gt; p) { System.out.println(&quot;GPS: &quot; + p.getX() + &quot;，&quot; + p.getY()); }}class Point&lt;T1, T2&gt; { T1 x; T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; }} 异常处理Java 异常是一个描述在代码段中发生的异常（也就是出错）情况的对象。当异常情况发生，一个代表该异常的对象被创建并且在导致该错误的方法中被抛出（throw）。该方法可以选择自己处理异常或传递该异常。两种情况下，该异常被捕获（caught）并处理。异常可能是由 Java 运行时系统产生，或者是由你的手工代码产生。被 Java 抛出的异常与违反语言规范或超出 Java 执行环境限制的基本错误有关。手工编码产生的异常基本上用于报告方法调用程序的出错状况。 Java 异常处理通过5个关键字控制：try、catch、throw、throws、finally。 声明你想要的异常监控包含在一个 try 块中。如果在 try 块中发生异常，它被抛出。你的代码可以捕捉这个异常（catch）并且用某种合理的方法处理该异常。系统产生的异常被 Java 运行时系统自动抛出。手动抛出一个异常，用关键字 throw。任何被抛出方法的异常都必须通过 throws 子句定义。任何在方法返回前绝对被执行的代码被放置在 finally 块中。 下面是一个异常处理块的通常形式： 1234567891011try { // 监控可能发生异常的代码} catch (ExceptionType1 e) { // 处理 ExceptionType1 类型异常} catch (ExceptionType2 e) { // 处理 ExceptionType2 类型异常} catch (... e) { // 处理 ... 类型异常} finally { // 在 try 块结束前被执行} 所有异常类型都是内置类 Throwable 的子类。因此 Throwable 在异常类层次结构的顶层。紧接着 Throwable 下面的是两个把异常分成两个不同分支的子类：Exception、Error。 Exception：用于用户程序可能捕捉的异常情况。它也是你可以用来创建你自己用户异常类型子类的类。在 Exception 分支中有一个重要子类 RuntimeException 运行时异常。业务中可能出现的自定义异常可以通过继承该类实现。 Error：定义了在通常环境下不希望被程序捕获的异常。用于 Java 运行时系统来显示与运行时系统本身有关的错误，比如：堆栈溢出。这里不讨论关于 Error 类型的异常处理，因为它们通常是灾难性的致命错误，不是你的程序可以控制的。 异常处理这块不是特别难：http://www.weixueyuan.net/java/rumen_7/ 多线程操作系统课有讲大致原理，这里主要讲在 Java 原理和应用，最好看懂课本理解好多线程内容。 线程模型线程优先级Java 给每个线程安排优先级以决定与其他线程比较时该如何对待该线程。 线程优先级是详细说明线程间优先关系的整数。作为绝对值，优先级是毫无意义的；当只有一个线程时，优先级高的线程并不比优先权低的线程运行的快。相反，线程的优先级是用来决定何时从一个运行的线程切换到另一个。这叫“上下文转换”(context switch)。决定上下文转换发生的规则（最高优先级优先算法）： 线程可以自动放弃控制。在I/O未决定的情况下，睡眠或阻塞由明确的让步来完成。在这种假定下，所有其他的线程被检测，准备运行的最高优先级线程被授予CPU。 线程可以被高优先级的线程抢占。在这种情况下，低优先级线程不主动放弃，处理器只是被先占——无论它正在干什么——处理器被高优先级的线程占据。基本上，一旦高优先级线程要运行，它就执行。这叫做有优先权的多任务处理。 注：不同的操作系统下相同优先级线程的上下文转换可能会产生错误。 同步性因为多线程在你的程序中引入了一个异步行为，所以在你需要的时候必须有加强同步性的方法。 比如，你希望两个线程相互通信并共享一个复杂的数据结构，例如链表序列，你需要某些方法来确保它们没有相互冲突。也就是说，你必须防止一个线程写入数据而另一个线程正在读取链表中的数据。为此目的，Java 在进程间同步性的老模式基础上实行了另一种方法：管程（monitor）。管程是一种由 C.A.R.Hoare 首先定义的控制机制。 你可以把管程想象成一个仅控制一个线程的小盒子。一旦线程进入管程，所有线程必须等待直到该线程退出了管程。用这种方法，管程可以用来防止共享的资源被多个线程操纵。 很多多线程系统把管程作为程序必须明确的引用和操作的对象。Java 提供一个清晰的解决方案。没有“Monitor”类；相反，每个对象都拥有自己的隐式管程，当对象的同步方法被调用时管程自动载入。一旦一个线程包含在一个同步方法中，没有其他线程可以调用相同对象的同步方法。这就使你可以编写非常清晰和简洁的多线程代码，因为同步支持是语言内置的。 消息传递在你把程序分成若干线程后，你就要定义各线程之间的联系。用大多数其他语言规划时，你必须依赖于操作系统来确立线程间通信。这样当然增加花费。然而，Java 提供了多线程间谈话清洁的、低成本的途径——通过调用所有对象都有的预先确定的方法。Java 的消息传递系统允许一个线程进入一个对象的一个同步方法，然后在那里等待，直到其他线程明确通知它出来。 主线程当 Java 程序启动时，一个线程立刻运行，该线程通常叫做程序的主线程（main thread），因为它是程序开始时就执行的。 主线程的重要性体现在两方面： 它是产生其他子线程的线程； 通常它必须最后完成执行，因为它执行各种关闭动作。 尽管主线程在程序启动时自动创建，但它可以由一个 Thread 对象控制。可以通过 currentThread() 获得它的一个引用。 currentThread() 是 Thread 类的公有的静态成员，该方法返回一个调用它的线程的引用： 1static Thread currentThread( ) 一旦你获得主线程的引用，你就可以像控制其他线程那样控制主线程： 123456789class CurrentThreadDemo { public static void main(String args[]) { Thread t = Thread.currentThread(); System.out.println(&quot;当前线程名称：&quot; + t); // 更改线程的名称 t.setName(&quot;My Thread&quot;); System.out.println(&quot;改名后：&quot; + t); }} 线程优先级线程优先级被线程调度用来判定何时每个线程允许运行。理论上，优先级高的线程比优先级低的线程获得更多的 CPU 时间。实际上，线程获得的CPU时间通常由包括优先级在内的多个因素决定（例如，一个实行多任务处理的操作系统如何更有效的利用 CPU 时间）。 一个优先级高的线程自然比优先级低的线程优先。举例来说，当低优先级线程正在运行，而一个高优先级的线程被恢复（例如从沉睡中或等待 I/O 中），它将抢占低优先级线程所使用的 CPU。 理论上，等优先级线程有同等的权利使用 CPU。但你必须小心了。记住，Java 是被设计成能在很多环境下工作的。一些环境下实现多任务处理从本质上与其他环境不同。为安全起见，等优先级线程偶尔也受控制。这保证了所有线程在无优先级的操作系统下都有机会运行。实际上，在无优先级的环境下，多数线程仍然有机会运行，因为很多线程不可避免的会遭遇阻塞，例如等待输入输出。遇到这种情形，阻塞的线程挂起，其他线程运行。 但是如果你希望多线程执行的顺利的话，最好不要采用这种方法。同样，有些类型的任务是占 CPU 的。对于这些支配 CPU 类型的线程，有时你希望能够支配它们，以便使其他线程可以运行。 设置线程的优先级： 1234567/*level 指定了对所调用的线程的新的优先权的设置level 的值必须在 MIN_PRIORITY 到 MAX_PRIORITY 范围内。通常，它们的值分别是 1 和 10要返回一个线程为默认的优先级，指定 NORM_PRIORITY，通常值为 5这些优先级在 Thread 中都被定义为 final 型变量*/final void setPriority(int level) 当涉及调度时，Java 的执行可以有本质上不同的行为。最安全的办法是获得可预先性的优先权，Java 获得跨平台的线程行为的方法是自动放弃对 CPU 的控制。 多线程实现的几种方式及各自的特点主要有4种实现多线程方式： 继承 Thread 类（无返回值） 实现 Runnable 接口（无返回值） 实现 Callable 接口（有返回值） 使用 ExecutorService、Callable、Future（有返回值） 继承 Thread 类Thread 类实现了 Runnable 接口： 123public class Thread implements Runnable { ...} 所以可以通过继承 Thread 实现多线程： 123456class MyThread extends Thread { @Override public void run() { System.out.println(&quot;MyThread.run()&quot;); }} 启动线程： 12MyThread myThread = new MyThread();myThread.start(); 实现 Runnable 接口Runnable 接口： 123public interface Runnable { public abstract void run();} 实现 Runnable 接口： 123456class MyThread implements Runnable { @Override public void run() { System.out.println(&quot;MyThread.run()&quot;); }} 启动线程： 123MyThread myThread = new MyThread();Thread thread = new Thread(myThread);thread.start(); Thread 的 run() 方法实际上调用的就是 target.run()： 12345public void run() { if (target != null) { target.run(); }} 实现 Callable 接口Callable 接口： 123public interface Callable&lt;V&gt; { V call() throws Exception;} 实现 Callable 接口： 123456class MyCallable&lt;V&gt; implements Callable&lt;V&gt; { @Override public V call() throws Exception { return null; }} 通过 FutureTask 包装器来创建任务，启动线程： 1234Callable&lt;V&gt; oneCallable = new MyCallable();FutureTask&lt;V&gt; oneTask = new FutureTask(oneCallable);Thread oneThread = new Thread(oneTask);oneThread.start(); 使用 ExecutorService、Callable、FutureExecutorService、Callable、Future 三个接口都属于 Executor 框架。 Executors 提供了一系列工厂方法用于创建线程池： newFixedThreadPool(int nThreads)：创建固定数目线程的线程池。 newCachedThreadPool()：创建一个可缓存的线程池，调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。 newSingleThreadExecutor()：创建一个单线程 Executor。 newScheduledThreadPool(int corePoolSize)：创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代 Timer。 ExecutoreService 提供了 submit() 方法，传递一个 Callable 或 Runnable，即返回 Future 对象。 有返回值的任务必须实现 Callable 接口；无返回值的任务必须实现 Runnable 接口。 执行 Callable 任务后，可以获得 Future 对象，在该对象上调用 get() 可以获得 Callable 任务返回的 Object。如果 Executor 后台线程池还没有完成 Callable 的计算，那么调用返回 Future 对象的 get() 方法时，会阻塞直到计算完成。 有返回结果的多线程例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.*;public class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { System.out.println(&quot;程序开始运行&quot;); long startTime = System.currentTimeMillis(); // 线程池大小 int taskSize = 5; // 创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(taskSize); // 创建多个有返回值的任务 List&lt;Future&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; taskSize; i++) { Callable c = new MyCallable(i); // 执行任务并获取 Future 对象 Future f = pool.submit(c); list.add(f); } // 关闭线程池 pool.shutdown(); // 获取所有并发任务的运行结果 for (Future f : list) { // 从 Future 对象上获取任务的返回值 System.out.println(f.get().toString()); } long totalTime = System.currentTimeMillis() - startTime; System.out.println(&quot;程序结束运行，总运行时间&quot; + totalTime + &quot;ms&quot;); }}class MyCallable implements Callable&lt;Object&gt; { private int taskNum; MyCallable(int taskNum) { this.taskNum = taskNum; } @Override public Object call() throws Exception { System.out.println(taskNum + &quot;启动&quot;); long startTime = System.currentTimeMillis(); Thread.sleep(1000); long totalTime = System.currentTimeMillis() - startTime; System.out.println(taskNum + &quot;结束&quot;); return taskNum + &quot;返回运行结果，运行时间&quot; + totalTime + &quot;ms&quot;; }} 线程的状态及相互转换线程的生命周期分为5种状态： 新建（New）：新创建一个线程对象。 可运行（Runnable）：线程对象创建后，其他线程（比如 main 线程）调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权。 运行（Running）：Running 的线程获得了 CPU 时间片（timeslice），执行程序代码。 阻塞（Blocked）：线程因为某种原因放弃了 CPU 使用权，也即让出了 CPU 时间片，暂时停止运行。直到线程进入可运行状态，才有机会再次获得 CPU 时间片转到运行状态。阻塞的情况分3种： 等待阻塞：Running 的线程执行 o.wait() 方法，JVM 会把该线程放入等待队列（Waitting Queue）。 同步阻塞：Running 的线程在获取对象的同步锁时，该同步锁被别的线程占用，JVM 会把该线程放入锁池（lock pool）。 其他阻塞：Running 的线程执行 Thread.sleep(long ms) 或 join() 方法 或 发出了 I/O 请求，JVM 会把该线程置为阻塞状态。当 sleep() 状态超时 或 join() 等待线程终止或者超时 或 I/O 处理完毕时，线程重新转入 Runnable 状态。 死亡（Dead）：线程 run() 或 main() 方法执行结束 或 因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。 线程同步方式临界区 临界区对应着一个 CriticalSection 对象，当线程需要访问保护数据时，调用 EnterCriticalSection 函数；当对保护数据的操作完成之后，调用 LeaveCriticalSection 函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。 关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave） 互斥量 互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。 由于也有线程所有权的概念，故互斥量也只能进行线程间的资源互斥访问，而不能用于线程同步； 由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了”遗弃”问题。 信号量 信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作。 事件可以完美解决线程间的同步问题，同时信号量也属于内核对象，可用于进程间的通信。 事件 事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。 事件是内核对象,可以解决线程间同步问题，因此也能解决互斥问题 线程间通信多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。即多个线程在操作同一份数据时，避免对同一共享变量的争夺，于是我们引出了等待唤醒机制：wait()、notify()。一个线程进行了规定操作后，就进入等待状态（wait）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify）。 wait()：线程调用 wait() 方法，释放了它对锁的拥有权，然后等待其他的线程来通知它，通知的方式是 notify() 或 notifyAll()，这样它才能重新获得锁的拥有权和恢复执行。要确保调用 wait() 方法的时候拥有锁，即 wait() 方法的调用必须放在 synchronized 方法或 synchronized 块中。 notify()：唤醒一个等待当前对象的锁的线程。唤醒在此对象监视器上等待的单个线程。 notifyAll()：唤醒在此对象监视器上等待的所有线程。 notify() 或 notifyAll() 方法应该是被拥有对象的锁的线程所调用。如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。 volatilevolatile：易变的、不稳定的。 作用：告诉编译器，只要是被该关键字修饰的变量都是易变的、不稳定的。 为什么是易变的呢？因为 volatile 所修饰的变量是直接存在主存中的，线程对变量的操作也是直接反映在主存中，所以说其是易变的。 JMM 中的内存分为主内存和工作内存，其中主内存是所有线程共享的，而工作内存是每个线程独立分配的，各个线程的工作内存之间相互独立、互不可见。在线程启动的时候，虚拟机为每个内存分配了一块工作内存，不仅包含了线程内部定义的局部变量，也包含了线程所需要的共享变量的副本，当然这是为了提高执行效率，读副本的比直接读主内存更快。 那么对于 volatile 修饰的变量（共享变量）来说，在工作内存发生了变化后，必须要马上写到主内存中，而线程读取到是 volatile 修饰的变量时，必须去主内存中去获取最新的值，而不是读工作内存中主内存的副本，这就有效的保证了线程之间变量的可见性。 volatile 特点： 内存可见性。即线程 A 对 volatile 变量的修改，其他线程获取的 volatile 变量都是最新的，但不能保证对变量的操作具有原子性。 禁止指令重排序。 什么是指令重排序？为了避免内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱，如果变量没有 volatile 修饰，程序执行的顺序可能会进行重排序。 举个栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SimpleHappenBefore { /** * 这里有两个共享变量 result 和 flag，初始值分别为 0 和 false */ // 验证结果的变量 private static int result = 0; // 标志位 private static boolean flag = false; public static void main(String[] args) throws InterruptedException { // 多线程情况下的重排序现象需要多次试验才能出现 for (int i = 0; i &lt; 1000; i++) { ThreadA threadA = new ThreadA(); ThreadB threadB = new ThreadB(); // 如果按调用线程的顺序 // 在 ThreadA 中先给 result = 1，然后 flag = true // ThreadB 中的 if(flag) 被执行，result = 1，下方的 if( result == 0) 应该永远不会为真，永远不会打印 // 但实际情况是，在试验100次的情况下会出现0次或几次的打印结果，而试验1000次结果更明显，有十几次打印 // 以上这种现象就是由于指令重排序造成的 threadA.start(); threadB.start(); // 这里等待线程结束后,重置共享变量,以使验证结果的工作变得简单些 threadA.join(); threadB.join(); result = 0; flag = false; } } static class ThreadA extends Thread { @Override public void run() { result = 1; flag = true; } } static class ThreadB extends Thread { @Override public void run() { if (flag) { result = result * 1; } if (result == 0) { System.out.println(&quot;result == 0&quot;); } } }} T1、T2、T3 三个线程，怎样保证它们按顺序执行？比如下面这样的代码，虽然是按顺序 start() 的，但因为并行和指令重排等原因，结果并不是按顺序的，有可能出现 1 2 0 或者 0 2 1 等各种情况。 12345678910public static void main(String[] args) { Thread[] t = new Thread[3]; for (Integer i = 0; i &lt; 3; i++) { String tmp = i.toString(); t[i] = new Thread(() -&gt; System.out.println(tmp)); } for (int i = 0; i &lt; 3; i++) { t[i].start(); }} 如何按顺序？在 start() 后面加上 join() 就行了： 1234for (int i = 0; i &lt; 3; i++) { t[i].start(); t[i].join();} join() 可以让子线程执行完才回到 main 主线程中，让线程变成串行执行，而不是并行。 join(ms) 只等待该线程 ms 毫秒 Lock 接口比 synchronized 块的优势？如果需要你实现一个高效的缓存，让其允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？ 1234567891011class SynchronizedMap&lt;K, V&gt; { private final Map&lt;K, V&gt; map = new HashMap&lt;&gt;(); public synchronized void put(K k, V v) { map.put(k, v); } public synchronized V get(K k) { return map.get(k); }} 1234567891011121314151617181920212223242526272829class LockMap&lt;K, V&gt; { private final Map&lt;K, V&gt; map = new HashMap&lt;&gt;(); private final ReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock r = lock.readLock(); private final Lock w = lock.writeLock(); public void put(K key, V value) { w.lock(); try { map.put(key, value); } catch (Exception e) { e.printStackTrace(); } finally { w.unlock(); } } public V get(K key) { r.lock(); try { return map.get(key); } catch (Exception e) { e.printStackTrace(); } finally { r.unlock(); } return null; }} wait 和 sleep 方法的不同？在等待时 wait 会释放锁，通常被用于线程间交互，线程会让出系统资源，进入等待池等待，其他线程可以占用 cpu。 在等待时 sleep 一直持有锁，通常被用于暂停执行，其他线程不能占用 cpu，因为 os 认为该线程正在工作，不会让出系统资源。 实现阻塞队列几种主要的阻塞队列自 Java 1.5 后，在 java.util.concurrent 包下提供了若干个阻塞队列，主要有以下几个： ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建 ArrayBlockingQueue 对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。 LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建 LinkedBlockingQueue 对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。 PriorityBlockingQueue：以上2种队列都是先进先出队列，而 PriorityBlockingQueue 却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。 DelayQueue：基于 PriorityQueue，一种延时阻塞队列，DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 阻塞队列中的方法 VS 非阻塞队列中的方法非阻塞队列中的几个主要方法 add(E e)：将元素e插入到队列末尾，如果插入成功，则返回 true；如果插入失败（即队列已满），则会抛出异常。 remove()：移除队首元素，若移除成功，则返回 true；如果移除失败（队列为空），则会抛出异常。 offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回 true；如果插入失败（即队列已满），则返回 false。 poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回 null。 peek()：获取队首元素，若成功，则返回队首元素；否则返回 null。 对于非阻塞队列，一般情况下建议使用 offer、poll、peek，不建议使用 add、remove。因为使用 offer、poll、peek 可以通过返回值判断操作成功与否，而使用 add、remove 却不能达到这样的效果。 注：非阻塞队列中的方法都没有进行同步措施。 阻塞队列中的几个主要方法 阻塞队列包括了非阻塞队列中的大部分方法（包括上面列举的5个方法），但要注意这5个方法在阻塞队列中都进行了同步措施。除此之外，阻塞队列提供了另外4个非常有用的方法： put(E e)：向队尾存入元素，如果队列满，则等待。 take()：从队首取元素，如果队列为空，则等待。 offer(E e,long timeout, TimeUnit unit)：向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回 false；否则返回 true。 poll(long timeout, TimeUnit unit)：从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回 null；否则返回取得的元素； 解决生产者——消费者问题与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。 用Java编程一个会导致死锁的程序，你将怎么解决？ 这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。 什么是原子操作，Java中的原子操作是什么？ 非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。 Java中的Volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？ 自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性、顺序性和一致性。 什么是竞争条件？你怎样发现和解决竞争？ 这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。 你将如何使用thread dump？你将如何分析Thread dump？ 在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？ 这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。 Java中你怎样唤醒一个阻塞的线程？ 这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。 在Java中CycliBarriar和CountdownLatch有什么区别？ 这个线程问题主要用来检测你是否熟悉JDK5中的并发包。这两个的区别是CyclicBarrier可以重复使用已经通过的障碍，而CountdownLatch不能重复使用。 什么是不可变对象，它对写并发应用有什么帮助？ 另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个java面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么String是不可变的。 你在多线程环境中遇到的共同的问题是什么？你是怎么解决它的？ 多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的Java线程问题。 同步工具类 CyclicBarrierCyclicBarrier 是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与 CountDownLatch 不同的是该 barrier 在释放等待线程后可以重用，所以称它为循环（Cyclic）的屏障（Barrier）。 CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。 提供的方法123456789101112131415161718192021222324252627// parties表示屏障拦截的线程数量，当屏障撤销时，先执行barrierAction，然后在释放所有线程public CyclicBarrier(int parties, Runnable barrierAction)// barrierAction默认为nullpublic CyclicBarrier(int parties)/** 当前线程等待直到所有线程都调用了该屏障的await()方法* 如果当前线程不是将到达的最后一个线程，将会被阻塞。解除阻塞的情况有以下几种* 1）最后一个线程调用await()* 2）当前线程被中断* 3）其他正在该CyclicBarrier上等待的线程被中断* 4）其他正在该CyclicBarrier上等待的线程超时* 5）其他某个线程调用该CyclicBarrier的reset()方法* 如果当前线程在进入此方法时已经设置了该线程的中断状态或者在等待时被中断，将抛出InterruptedException，并且清除当前线程的已中断状态。* 如果在线程处于等待状态时barrier被reset()或者在调用await()时 barrier 被损坏，将抛出 BrokenBarrierException 异常。* 如果任何线程在等待时被中断，则其他所有等待线程都将抛出 BrokenBarrierException 异常，并将 barrier 置于损坏状态。 *如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作（barrierAction），那么在允许其他线程继续运行之前，当前线程将运行该操作。如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，并将 barrier 置于损坏状态。** 返回值为当前线程的索引，0表示当前线程是最后一个到达的线程*/public int await() throws InterruptedException, BrokenBarrierException// 在await()的基础上增加超时机制，如果超出指定的等待时间，则抛出 TimeoutException 异常。如果该时间小于等于零，则此方法根本不会等待。public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException// 将屏障重置为其初始状态。如果所有参与者目前都在屏障处等待，则它们将返回，同时抛出一个BrokenBarrierException。public void reset() 对于失败的同步尝试，CyclicBarrier 使用了一种要么全部，要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 InterruptedException）以反常的方式离开。 使用示例1新建5个线程，这5个线程达到一定的条件时，它们才继续往后运行。 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest { private static int SIZE = 5; private static CyclicBarrier barrier; public static void main(String[] args) { barrier = new CyclicBarrier(SIZE); // 新建5个任务 for (int i = 0; i &lt; SIZE; i++) new InnerThread().start(); } static class InnerThread extends Thread { public void run() { try { System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;); // 将 barrier 的参与者数量加1 barrier.await(); // barrier 的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;); } catch (BrokenBarrierException | InterruptedException e) { e.printStackTrace(); } } }} 结果： 12345678910Thread-1 wait for CyclicBarrier.Thread-2 wait for CyclicBarrier.Thread-3 wait for CyclicBarrier.Thread-4 wait for CyclicBarrier.Thread-0 wait for CyclicBarrier.Thread-0 continued.Thread-4 continued.Thread-2 continued.Thread-3 continued.Thread-1 continued. 使用示例2新建5个线程，当这5个线程达到一定的条件时，执行某项任务。 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest { private static int SIZE = 5; private static CyclicBarrier barrier; public static void main(String[] args) { barrier = new CyclicBarrier(SIZE, () -&gt; System.out.println(&quot;CyclicBarrier's parties is: &quot; + barrier.getParties())); // 新建5个任务 for (int i = 0; i &lt; SIZE; i++) new InnerThread().start(); } static class InnerThread extends Thread { public void run() { try { System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;); // 将 barrier 的参与者数量加1 barrier.await(); // barrier的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;); } catch (BrokenBarrierException | InterruptedException e) { e.printStackTrace(); } } }} 实现原理基于 ReentrantLock 和 Condition 机制实现。除了 getParties() 方法，CyclicBarrier 的其他方法都需要获取锁。 属性： 123456789101112131415161718192021// 可重入锁private final ReentrantLock lock = new ReentrantLock();/** Condition to wait on until tripped */private final Condition trip = lock.newCondition();// 拦截的线程数量private final int parties; //// 当屏障撤销时，需要执行的屏障操作private final Runnable barrierCommand;// 当前的 Generation，每当屏障失效或者开闸之后都会自动替换掉，从而实现重置的功能。private Generation generation = new Generation();/*** Number of parties still waiting. Counts down from parties to 0* on each generation. It is reset to parties on each new generation or when broken.*/private int count; //还能阻塞的线程数（即parties-当前阻塞的线程数），当新建generation或generation被破坏时，count会被重置。因为对Count的操作都是在获取锁之后，所以不需要其他同步措施。// 静态内联类private static class Generation { // 当前的屏障是否破坏 boolean broken = false;} await()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen; }}private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 保存此时的generation final Generation g = generation; // 判断屏障是否被破坏 if (g.broken) throw new BrokenBarrierException(); // 判断线程是否被中断 // 如果被中断，调用breakBarrier()进行屏障破坏处理，并抛出InterruptedException if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } // 剩余count递减，并赋值给线程索引，作为方法的返回值 int index = --count; // 如果线程索引降为0，说明当前线程是最后一个到达的线程 // 执行可能存在的屏障操作 barrierCommand，设置下一个Generation。相当于每次开闸之后都进行了一次reset。 if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) // 同步执行barrierCommand command.run(); ranAction = true; // 执行成功设置下一个nextGeneration nextGeneration(); return 0; } finally { // 如果barrierCommand执行失败，进行屏障破坏处理 if (!ranAction) breakBarrier(); } } // 如果当前线程不是最后一个到达的线程 // loop until tripped, broken, interrupted, or timed out for (; ; ) { try { if (!timed) // 调用Condition的await()方法阻塞 trip.await(); else if (nanos &gt; 0L) // 调用Condition的awaitNanos()方法阻塞 nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { // 如果当前线程被中断，则判断是否有其他线程已经使屏障破坏 // 若没有则进行屏障破坏处理，并抛出异常；否则再次中断当前线程 if (g == generation &amp;&amp; !g.broken) { breakBarrier(); throw ie; } else { // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // &quot;belong&quot; to subsequent execution. Thread.currentThread().interrupt(); // 这种捕获了InterruptException之后调用Thread.currentThread().interrupt()是一种通用的方式。其实就是为了保存中断状态，从而让其他更高层次的代码注意到这个中断。 } } // 如果屏障被破坏，当前线程抛BrokenBarrierException if (g.broken) throw new BrokenBarrierException(); // 如果已经换代，直接返回index（last thread已经执行的nextGeneration，但当前线程还没有执行到该语句） if (g != generation) return index; // 超时，进行屏障破坏处理，并抛TimeoutException if (timed &amp;&amp; nanos &lt;= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { // 释放锁 lock.unlock(); }}// 将当前屏障置为破坏状态、重置count、并唤醒所有被阻塞的线程。// 必须先获取锁，才能调用此方法private void breakBarrier() { generation.broken = true; count = parties; trip.signalAll();}// 唤醒trip上等待的所有线程，设置下一个Generationprivate void nextGeneration() { // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation();} reset()： 1234567891011// 重置屏障，先进行屏障破坏处理，再设置下一代generationpublic void reset() { final ReentrantLock lock = this.lock; lock.lock(); try { breakBarrier(); // break the current generation nextGeneration(); // start a new generation } finally { lock.unlock(); }} CyclicBarrier与CountDownLatch比较 CountDownLatch：一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行；CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。 CountDownLatch：一次性的；CyclicBarrier：可以重复使用。 CountDownLatch 基于AQS；CyclicBarrier 基于锁和 Condition。本质上都是依赖于 volatile 和 CAS 实现的。 反射暂时先用简单例子帮助理解。 现在有两个业务类： 12345678package reflection;class Service1 { public void doService1(int a, int b) { System.out.println(&quot;业务方法1，加法&quot;); System.out.printf(&quot;a x b = %d&quot;, a x b); }} 12345678package reflection;class Service2 { public void doService2(int a, int b) { System.out.println(&quot;业务方法2，乘法&quot;); System.out.printf(&quot;a x b = %d&quot;, a x b); }} 如何从第1个业务方法切换到第2个业务方法呢？ 不使用反射，只能修改代码，重新编译运行： 12345678910package reflection;public class Test { public static void main(String[] args) { int a = 1, b = 2; // 不用业务1了，注释掉1，然后重新编译运行 //new Service1().doService1(a, b); new Service2().doService2(a, b); }} 使用反射，首先准备一个配置文件 A.properties，放在 src 目录下： A.properties12class=reflection.Service1method=doService1 在测试类 Test 中，首先取出类名称和方法名，然后通过反射去调用这个方法： 123456789101112131415161718192021222324252627282930package reflection;import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties;public class Test { public static void main(String[] args) throws Exception { // 从 A.properties 中获取类名称和方法名称 File springConfigFile = new File(&quot;src/A.properties&quot;); Properties springConfig= new Properties(); springConfig.load(new FileInputStream(springConfigFile)); String className = (String) springConfig.get(&quot;class&quot;); String methodName = (String) springConfig.get(&quot;method&quot;); // 根据类名称获取类对象 Class clazz = Class.forName(className); // 根据方法名称，获取方法对象 Method method = clazz.getMethod(methodName, int.class, int.class); // 获取构造器 Constructor constructor = clazz.getConstructor(); // 根据构造器，实例化出对象 Object service = constructor.newInstance(); int a = 1, b = 2; // 调用对象的指定方法 method.invoke(service, a, b); }} 当需要从调用第1个业务方法，切换到调用第2个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件 A.properties，重新运行即可。 IO流的分类 按流的流向分：输入流、输出流 按操作单元划分：字节流、字符流 按流的角色划分：节点流、处理流 IO流的40多个类都是从如下4个抽象类基类中派生出来的： 输入流的基类： Reader：字符输入流 InputStream：字节输入流 输出流的基类： Writer：字符输出流 OutputStream：字节输出流 字符流和字节流字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别： 读写单位不同：字节流以字节（8bit）为单位;字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、视频等）;字符流只能处理字符类型的数据。 字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。 结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。 J.U.C包的JDK源码（CAS、AQS、ConcurrentHashMap、ThreadLocal、CyclicBarrier、CountDownLatch、Atom、阻塞队列等等）IO（writer、reader、InputStream、OutputStream）、NIO等对象序列化与反序列化序列化：把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程。 反序列化：把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 为什么要做序列化？ 在分布式系统中，此时需要把对象在网络上传输，就得把对象数据转换为二进制形式，需要共享的数据的 Java 对象，都得做序列化。 服务器钝化：如果服务器发现某些对象好久没活动了，那么服务器就会把这些内存中的对象持久化在本地磁盘文件中（Java 对象转换为二进制文件）；如果服务器发现某些对象需要活动时，先去内存中寻找，找不到再去磁盘文件中反序列化我们的对象数据，恢复成 Java 对象。这样能节省服务器内存。 锁优化全局唯一有序 IDsnowflake ，timestamp 加前面，然后后面加上机器 id 等 红黑树因为HashMap在JDK1.8中数据结构加入了红黑树) AOP、实现动态代理的方式Dom4J以及SAX的区别，什么时候用，怎么用Maven，为什么要用NIO，怎么使用动态代理GCGC 机制对 JVM 中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息的保证 JVM 中的内存空间，防止内存泄露和溢出问题的出现。","link":"/2017/12/26/zh/programing/java/basis/"},{"title":"常用数据结构","text":"名称 底层结构 线程安全 有序 值唯一 LinkedList 双向链表 x √ 不唯一 ArrayList 数组 x √ 不唯一 Vector 数组 √ √ 不唯一 HashTable 数组+链表 √ x 不为空 HashSet 数组+链表 x x 唯一 TreeSet 红黑树 x √ 唯一 HashMap 数组+链表/红黑树 x x 不唯一 TreeMap 红黑树 x √ 不唯一 ConcurrentHashMap 数组+链表/红黑树 √ x 不唯一","link":"/2018/07/29/zh/programing/java/common_data_structures/"},{"title":"框架","text":"Servlet123456789101112public interface Servlet { // 初始化方法，仅仅执行一次 void init(ServletConfig var1) throws ServletException; // 处理请求和生成响应 void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException; // 容器销毁时执行，只执行一次 void destroy(); ServletConfig getServletConfig(); String getServletInfo();} Servlet 接口定义了一套处理网络请求的规范，所有实现 Servlet 的类或所有想要处理网络请求的类，都需要实现那5个方法，其中最主要的是两个生命周期方法 init() 和 destroy()，还有一个处理请求的 service()。 Servlet 不会直接和客户端打交道，而是由 Servlet 容器负责（比如Tomcat）。 当容器启动的时候，Servlet 类就会被初始化，容器监听端口，请求过来后，根据 URL 等信息，确定要将请求交给哪个 Servlet 处理，然后调用 Servlet 的具体 service 方法，service 方法返回一个 response 对象，容器再把这个 response 返回给客户端。 比如：Spring 的 DispatcherServlet（前端控制器） 就实现了 Servlet 这个接口。 Springhttps://blog.csdn.net/u013821825/article/details/51385633 介绍 Spring 框架它是一个一站式（full-stack 全栈式）框架，SpringMVC 提供了从表现层到业务层再到持久层的一套完整的解决方案。我们在项目中可以只使用 Spring 一个框架，它就可以提供表现层的 MVC 框架，持久层的 Dao 框架。它的两大核心 IoC 和 AOP 更是为我们程序解耦和代码简洁易维护提供了支持。 Spring 优点 降低了组件之间的耦合性，实现了软件各层之间的解耦。 可以使用 Spring 提供的众多服务，如事务管理，消息服务等。 容器提供单例模式支持。 容器提供了 AOP 技术，利用它很容易实现如权限拦截，运行期监控等功能。 Spring 对于主流的应用框架提供了集成支持，如 Hibernate，JPA 等。 Spring 属于低侵入式设计，代码的污染极低。 独立于各种应用服务器。 Spring 的 DI 机制降低了业务对象替换的复杂性。 Spring 的高度开放性，并不强制应用完全依赖于 Spring，开发者可以自由选择 Spring 的部分或全部。 Spring Bean 的作用域Spring 容器中的 Bean 可以分为5个范围： Singleton：这种 Bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 Bean 的实例，单例的模式由 Bean factory 自身来维护。 Prototype：原形范围与单例范围相反，为每一个 Bean 请求提供一个实例。 Request：在请求 Bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，Bean 会失效并被垃圾回收器回收。 Session：与请求范围类似，确保每个 Session 中有一个 Bean 的实例，在 Session 过期后，Bean 会随之失效。 Global-session：Global-session 和 Portlet 应用相关。当应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 Global-session 中。 全局作用域与 Servlet 中的 Session 作用域效果相同。 Spring 自动装配的方式 No：不启用自动装配。 byName：通过属性的名字查找 Bean 依赖的对象并为其注入。比如说类 Computer 有个属性 printer，指定其 autowire 属性为 byName 后，IoC 容器会查找 id/name 属性为 printer 的 Bean，然后使用 Setter 方法注入。 byType：通过属性的类型查找 Bean 依赖的对象并为其注入。比如类 Computer 有个属性 printer，类型为 Printer，指定其autowire 属性为 byType 后，IoC 容器会查找 Class 属性为 Printer 的 Bean，使用 Setter 方法注入。 constructor：和 byType 一样，也是通过类型查找依赖对象，区别在于它不是使用 Setter 方法注入，而是使用构造进行注入。 autodetect：在 byType 和 constructor 之间自动选择注入方式。 default：由上级标签 的 default-autowire 属性确定。 Spring 的核心类有哪些，各自作用BeanFactory：产生一个新的实例，可以实现单例模式。 BeanWrapper：提供统一的 get 及 set 方法。 ApplicationContext：提供框架的实现，包括 BeanFactory 的所有功能。 Spring 处理请求过程简短： 用户请求到达 DispatcherServlet，DispatcherServlet 根据请求信息（如URL）来决定选择 Handler（页面控制器）进行处理并把请求委托给它。 Handler 接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个 ModelAndView（模型数据和逻辑视图名）。 DispatcherServlet 收回控制权，根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染。 DispatcherServlet 再次收回控制权，将响应返回给用户。 https://blog.csdn.net/mishifangxiangdefeng/article/details/52763546 详细： DispatcherServlet 接收发过来的请求，然后请求 HandlerMapping（处理器映射器），让其根据 xml 配置、注解等查找 Handler（处理器）。 HandlerMapping 向 DispatcherServlet 返回 HandlerExecutionChain（执行链），其包含一个 Handler 和多个 HandlerInterceptor（拦截器）。 DispatcherServlet 获取 Handler 对应的 HandlerAdapter（处理器适配器），然后让 HandlerAdapter 去执行 Handler。 Handler 执行完成后，向 HandlerAdapter 返回 ModelAndView（包括模型数据、逻辑视图名），HandlerAdapter 再向 DispatcherServlet 返回 ModelAndView。 DispatcherServlet 请求 ViewResolver（视图解析器）进行视图解析。 ViewResolver 向 DispatcherServlet 返回 View。 DispatcherServlet 渲染视图，填充 Model 模型数据（在 ModelAndView 中）。 最后 DispatcherServlet 向用户响应结果。 详细过程：https://blog.csdn.net/uhgagnu/article/details/59157840 IoC 和 DI 区别IoC = Inversion of Control 控制反转，传统过程中，通常由调用者来创建被调用者的实例对象。但在 Spring 中创建的工作由 Spring 容器完成。 DI 依赖注入，指 Spring 创建对象的过程中，将对象依赖属性通过配置进行注入。 Spring 用到的设计模式 代理模式：在 AOP 和 remoting 中被用的比较多。 单例模式：在 Spring 配置文件中定义的 Bean 默认为单例模式。 模板方法：用来解决代码重复的问题。比如 RestTemplate、JmsTemplate、JpaTemplate。 前端控制器：Srping 提供了 DispatcherServlet 来对请求进行分发。 视图帮助（View Helper）：Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。 依赖注入：贯穿于 BeanFactory / ApplicationContext 接口的核心理念。 工厂模式：BeanFactory 用来创建对象的实例。 BeanFactory 接口和 ApplicationContext 接口区别ApplicationContext 接口继承 BeanFactory 接口，Spring 核心工厂是 BeanFactory ,BeanFactory 采取延迟加载，第一次 getBean 时才会初始化 Bean, ApplicationContext 是会在加载配置文件时初始化 Bean。 ApplicationContext 接口扩展 BeanFactory，它可以进行国际化处理、事件传递和 Bean 自动装配以及各种不同应用层的 Context 实现 开发中基本都在使用 ApplicationContext, web 项目使用 WebApplicationContext ，很少用到 BeanFactory。 Spring AOP 的应用场景、原理、优点AOP = Aspect Oriented Programming 面向切面编程 用来封装横切关注点，可以在下面的场景中使用：Authentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理、Lazy loading 懒加载、Debugging 调试、logging, tracing, profiling and monitoring 记录跟踪优化 校准、Performance optimization 性能优化、Persistence 持久化、Resource pooling 资源池、Synchronization 同步、Transactions 事务。 原理：AOP是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。 优点： 各个步骤之间的良好隔离性耦合性大大降低。 源代码无关性，再扩展功能的同时不对源码进行修改操作。 Spring AOP 里面的几个名词切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现。 连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 在Spring AOP中，一个连接点 总是 代表一个方法的执行。 通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。 通知（Advice）：在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。 通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。 切入点（Pointcut）：匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。 切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。 引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。 Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。 目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。 AOP代理（AOP Proxy）： AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。 织入（Weaving）：把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 Spring和其他纯Java AOP框架一样，在运行时完成织入。 通知有哪些类型前置通知（Before advice） 在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。 返回后通知（After returning advice） 在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 抛出异常后通知（After throwing advice） 在方法抛出异常退出时执行的通知。 后通知（After (finally) advice） 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 环绕通知（Around Advice） 包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。 切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。 Spring 5个标准事件 上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh() 方法时被触发。 上下文开始事件（ContextStartedEvent）：当容器调用 ConfigurableApplicationContext 的 Start() 方法开始/重新开始容器时触发该事件。 上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的 Stop() 方法停止容器时触发该事件。 上下文关闭事件（ContextClosedEvent）：当 ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。 请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。 除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件： 123456public class CustomApplicationEvent extends ApplicationEvent { public CustomApplicationEvent (Object source, final String msg) { super(source); System.out.println(&quot;Created a Custom event&quot;); }} Mybatis#{} 和 ${} 的区别${} Properties 配置文件中的变量占位符，它可以用于标签属性值和 SQL 内部，属于静态文本替换，比如 ${driver} 会被静态替换为 com.mysql.jdbc.Driver。 #{} SQL 的参数占位符，Mybatis 会将 SQL 中的 #{} 替换为 ? 号，在 SQL 执行前会使用 PreparedStatement 预编译的参数设置方法，按序给 SQL 的 ? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，#{item.name} 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 param.getItem().getName()。 Xml 映射中有哪些标签除了常见的 select | insert | updae | delete 标签外，还有： 、、、、 动态 SQL 的9个标签，trim | where | set | foreach | sql | if | choose | when | otherwise | bind 等，其中 为SQL 片段标签，通过 标签引入 SQL 片段， 为不支持自增的主键生成策略标签。 1234567&lt;sql id=&quot;select&quot;&gt; SELECT * FROM `a_table`&lt;/sql&gt;&lt;select id=&quot;find&quot; resultType=&quot;*&quot; resultMap=&quot;*&quot;&gt; &lt;include refid=&quot;select&quot;/&gt;&lt;/select&gt; Xml 映射和 Dao 接口通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？ 在 Mybatis 中，每一个 、、、 标签，都会被解析为一个 MappedStatement 对象。 Dao 接口就是通常所说的 Mapper 接口，Xml 映射文件中的 namespace 的值就是接口的全限名（Java 包下具体的接口路径，比如 com.mapper.UserMapper），接口的方法名就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 SQL 的参数。 Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement，比如 com.mybatis3.mappers.UserMapper.findUserById，可以唯一找到 XML 中 namespace 为 com.mybatis3.mappers.UserMapper 下面 id = findUserById 的 MappedStatement。 Dao 接口里的方法不能重载，因为是全限名 + 方法名的保存和寻找策略。 Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用动态代理为 Dao 接口生成代理 proxy 对象，代理对象会拦截接口方法，转而执行 MappedStatement 所代表的 SQL，然后将 SQL 执行结果返回。 Mybatis 如何分页，分页插件的原理Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据dialect 方言，添加对应的物理分页语句和物理分页参数。 比如 select * from student，拦截 SQL 后重写为 select t.* from （select * from student）s limit 0，10。 Mybatis 的插件运行原理，以及如何编写一个插件Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke() 方法，当然，只会拦截那些你指定需要拦截的方法。 编写一个插件：只能编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这4种接口的插件。实现 Mybatis 的 Interceptor 接口并复写 intercept() 方法，然后再给插件编写注解，指定要拦截哪一个接口的哪些方法即可，别忘了在配置文件中配置你编写的插件。 Mybatis 动态 SQL 是做什么的？都有哪些？简述一下执行原理？Mybatis 动态 SQL 可以让我们在 Xml 映射文件内，以标签的形式编写动态 SQL，完成逻辑判断和动态拼接 SQL 的功能，Mybatis 提供了9种动态 SQL 标签 trim | where | set | foreach | if | choose | when | otherwise | bind。 其执行原理为，使用 OGNL（Object Graphic Navigation Language，对象图导航语言）从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL，以此来完成动态 SQL 的功能。 Mybatis 是如何将 SQL 执行结果封装为目标对象并返回的？都有哪些映射形式？两种方式映射： 使用 标签，逐一定义列名和对象属性名之间的映射关系。 使用 SQL 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写。但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。 有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。 Mybatis 能执行一对一、一对多的关联查询吗？有哪些实现方式？它们之间的区别？Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询。多对多查询，其实就是一对多查询，只需要把 selectOne() 修改为 selectList() 即可。 关联对象查询有两种实现方式： 单独发送一个 SQL 去查询关联对象，赋给主对象，然后返回主对象。 使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 SQL 查询，就可以把主对象和其关联对象查出来。 那么问题来了，join 查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是 标签内的 子标签，指定了唯一确定一条记录的id列，Mybatis 根据 列值来完成100条记录的去重复功能， 可以有多个，代表了联合主键的语意。 同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。 比如：下面 join 查询出来6条记录：一、二列是 Teacher 对象列，第三列为 Student 对象列，Mybatis 去重处理后，结果为1个老师6个学生，而不是6个老师6个学生。 teacher_id teacher_name student_id 1 teacher 38 1 teacher 39 1 teacher 40 1 teacher 41 1 teacher 42 1 teacher 43 Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。association 指一对一查询，collection 指一对多查询。 在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled = true | false。 原理：使用 CGLIB（Code Generation Library，代码生成包）创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke() 方法发现 a.getB() 是null值，那么就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用。这就是延迟加载的基本原理。 当然，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。 Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复。 原因：namespace + id 是作为 Map&lt;String, MappedStatement&gt; 的 key 使用的，如果没有 namespace，就剩下 id，那么 id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace + id自然也就不同。 Mybatis 中如何执行批处理？使用 BatchExecutor 完成批处理。 Mybatis 都有哪些 Executor 执行器？它们之间的区别？有三种基本的 Executor 执行器：SimpleExecutor、ReuseExecutor、BatchExecutor。 SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。 ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放在 Map&lt;String, Statement&gt; 内，供下一次使用。简言之，就是重复使用 Statement 对象。 BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），addBatch() 将所有 SQL 都添加到批处理中，等待统一执行 executeBatch()，它缓存了多个 Statement 对象，每个 Statement 对象都 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理。与 JDBC 批处理相同。 作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。 Mybatis 中如何指定使用哪一种 Executor 执行器？在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 创建 SqlSession 的方法传递 ExecutorType 类型参数。 Mybatis 是否可以映射 Enum 枚举类？Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。 映射方式：自定义一个 TypeHandler，实现 TypeHandler 的 setParameter() 和 getResult() 接口方法。 TypeHandler 有两个作用： 完成从 javaType 到 jdbcType 的转换； 完成从 jdbcType 到 javaType 的转换。体现为 setParameter() 和 getResult() 两个方法，分别代表设置 SQL ? 问号占位符参数和获取列查询结果。 Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问 B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。 原理：Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。 简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。 在 Xml 映射文件中： 标签会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象； 标签会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象； 、、、 标签均会被解析为 MappedStatement 对象，标签内的 SQL 会被解析为 BoundSql 对象。 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别？Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的；而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以称之为半自动 ORM 映射工具。","link":"/2018/04/09/zh/programing/java/framework/"},{"title":"hashcode","text":"前言在 Java 的 Object 类中有一个方法: 1public native int hashCode(); 根据这个方法的声明可知，该方法返回一个 int 类型的数值，并且是本地方法，因此在 Object 类中并没有给出具体的实现。 hashCode 方法的作用对于包含容器类型的程序设计语言来说，基本上都会涉及到 hashCode。在 Java 中也一样，hashCode 方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括 HashSet、HashMap 以及 HashTable。 当向集合中插入对象时，如何判断在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在） 也许大多数人都会想到调用 equals 方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用 equals 方法去逐一比较，效率必然是一个问题。 此时 hashCode 方法的作用就体现出来了：当集合要添加新的对象时，先调用这个对象的 hashCode 方法，得到对应的 hashcode 值，如果 table 中没有该 hashcode 值，它就可以直接存进去，不用再进行任何比较了；如果存在该 hashcode 值，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。（实际上就是 HashMap 的具体实现） 所以这里存在一个冲突解决和效率的问题，说通俗一点：Java 中的 hashCode 方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。 下面这段代码是 java.util.HashMap 的中 put 方法的具体实现： 12345678910111213141516171819public V put(K key, V value) { if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null;} put 方法是用来向 HashMap 中添加新的元素，从 put 方法的具体实现可知，会先调用 hashCode 方法得到该元素的 hashCode 值，然后查看 table 中是否存在该 hashCode 值，如果存在则调用 equals 方法重新确定是否存在该元素，如果存在，则更新 value 值，否则将新的元素添加到 HashMap 中。从这里可以看出，hashCode 方法的存在是为了减少 equals 方法的调用次数，从而提高程序效率。 对 hash 表不清楚的，可以参考这几篇博文：http://www.cnblogs.com/jiewei915/archive/2010/08/09/1796042.htmlhttp://www.cnblogs.com/dolphin0520/archive/2012/09/28/2700000.htmlhttp://www.java3z.com/cwbwebhome/article/article8/83560.html?id=4649 有些朋友误以为默认情况下，hashCode 返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些 JVM 在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。下面是 HotSpot JVM 中生成 hash 散列值的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// hotspot/src/share/vm/runtime/synchronizer.cppstatic inline intptr_t get_next_hash(Thread * Self, oop obj) { intptr_t value = 0 ; if (hashCode == 0) { // This form uses an unguarded global Park-Miller RNG, // so it's possible for two threads to race and generate the same RNG. // On MP system we'll have lots of RW access to a global, so the // mechanism induces lots of coherency traffic. value = os::random() ; } else if (hashCode == 1) { // This variation has the property of being stable (idempotent) // between STW operations. This can be useful in some of the 1-0 // synchronization schemes. intptr_t addrBits = intptr_t(obj) &gt;&gt; 3 ; value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom ; } else if (hashCode == 2) { value = 1 ; // for sensitivity testing } else if (hashCode == 3) { value = ++GVars.hcSequence ; } else if (hashCode == 4) { value = intptr_t(obj) ; } else { // Marsaglia's xor-shift scheme with thread-specific state // This is probably the best overall implementation -- we'll // likely make this the default in future releases. unsigned t = Self-&gt;_hashStateX ; t ^= (t &lt;&lt; 11) ; Self-&gt;_hashStateX = Self-&gt;_hashStateY ; Self-&gt;_hashStateY = Self-&gt;_hashStateZ ; Self-&gt;_hashStateZ = Self-&gt;_hashStateW ; unsigned v = Self-&gt;_hashStateW ; v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)) ; Self-&gt;_hashStateW = v ; value = v ; } value &amp;= markOopDesc::hash_mask; if (value == 0) value = 0xBAD ; assert (value != markOopDesc::no_hash, &quot;invariant&quot;) ; TEVENT (hashCode: GENERATE) ; return value;} 因此有人会说，可以直接根据 hashcode 值判断两个对象是否相等吗？肯定是不可以的，因为存在以下逻辑： 1234567891011if obj1 equals obj2 then obj1.hashcode == obj2.hashcodeif obj1 不 equals obj2 then obj1.hashcode 不一定 == obj2.hashcodeif obj1.hashcode 不 == obj2.hashcode then obj1 不 equals obj2if obj1.hashcode == obj2.hashcode then obj1 不一定 equals obj2 equals 和 hashCode在有些情况下，程序员在设计一个类的时候需要重写 equals 方法，比如 String 类，但是千万要注意，在重写 equals 方法的同时，必须重写 hashCode 方法。为什么这么说呢？ 下面看一个例子： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.HashMap;import java.util.HashSet;import java.util.Set;class People { private String name; private int age; public People(String name, int age) { this.name = name; this.age = age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object obj) { // 重写 equals 方法 // 如果两个 People 对象的姓名和年龄相等，则认为是同一个人 return this.name.equals(((People) obj).name) &amp;&amp; this.age == ((People) obj).age; }}public class Main { public static void main(String[] args) { People p1 = new People(&quot;Jack&quot;, 12); System.out.println(p1.hashCode()); HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;(); hashMap.put(p1, 1); // null System.out.println(hashMap.get(new People(&quot;Jack&quot;, 12))); }} 这段代码本来的意愿是想这段代码输出结果为 1，但事实上它输出的是 null，为什么？因为没有重写 hashCode 方法。 虽然通过重写 equals 方法使得逻辑上姓名和年龄相同的两个对象被判定为相等的对象（跟 String 类类似），但在默认情况下，hashCode 方法是将对象的存储地址进行映射，p1 指向的对象和 System.out.println(hashMap.get(new People(&quot;Jack&quot;, 12))); 这句中的 new People(“Jack”, 12) 生成的是两个对象，它们的存储地址不同，所以就输出 null。 下面是 HashMap 的 get 方法的具体实现： 12345678910111213public V get(Object key) { if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; } return null;} 所以在 hashmap 进行 get 操作时，因为得到的 hashcdoe 值不同（注意，上述代码也许在某些情况下会得到相同的 hashcode 值，不过这种概率比较小），所以导致在 get 方法中 for 循环不会执行，直接返回 null。 因此如果想上述代码输出为 1，很简单，只需要重写 hashCode 方法，让 equals 方法和 hashCode 方法始终在逻辑上保持一致性： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.HashSet;import java.util.Set;class People { private String name; private int age; public People(String name, int age) { this.name = name; this.age = age; } public void setAge(int age) { this.age = age; } @Override public int hashCode() { return name.hashCode() * 37 + age; } @Override public boolean equals(Object obj) { return this.name.equals(((People) obj).name) &amp;&amp; this.age == ((People) obj).age; }}public class Main { public static void main(String[] args) { People p1 = new People(&quot;Jack&quot;, 12); System.out.println(p1.hashCode()); HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;(); hashMap.put(p1, 1); System.out.println(hashMap.get(new People(&quot;Jack&quot;, 12))); }} 这样一来的话，输出结果就为 1 了。 下面这段话摘自《Effective Java》： 在程序执行期间，只要 equals 方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode 方法必须始终如一地返回同一个整数。 如果两个对象根据 equals 方法比较是相等的，那么调用两个对象的 hashCode 方法必须返回相同的整数结果。 如果两个对象根据 equals 方法比较是不等的，则 hashCode 方法不一定得返回不同的整数。 第一条在很多时候会被忽略。在《Java编程思想》一书中的P495页也有类似的一段话：设计 hashCode() 时最重要的因素就是：无论何时，对同一个对象调用 hashCode() 都应该产生同样的值。如果在讲一个对象用 put() 添加进 HashMap 时产生一个 hashCdoe 值，而用 get() 取出时却产生了另一个 hashCode 值，那么就无法获取该对象了。所以如果你的 hashCode 方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode() 方法就会生成一个不同的散列码。 下面举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.HashMap; import java.util.HashSet; import java.util.Set;class People { private String name; private int age; public People(String name, int age) { this.name = name; this.age = age; } public void setAge(int age) { this.age = age; } @Override public int hashCode() { // TODO Auto-generated method stub return name.hashCode() * 37 + age; } @Override public boolean equals(Object obj) { // TODO Auto-generated method stub return this.name.equals(((People) obj).name) &amp;&amp; this.age == ((People) obj).age; }}public class Main { public static void main(String[] args) { People p1 = new People(&quot;Jack&quot;, 12); System.out.println(p1.hashCode()); HashMap&lt;People, Integer&gt; hashMap = new HashMap&lt;People, Integer&gt;(); hashMap.put(p1, 1); p1.setAge(13); // null System.out.println(hashMap.get(p1)); }} 这段代码输出的结果为 null，想必其中的原因大家应该都清楚了。 因此，在设计 hashCode 方法和 equals 方法的时候，如果对象中的数据易变，则最好在 equals 方法和 hashCode 方法中不要依赖于该字段。","link":"/2018/10/31/zh/programing/java/hashcode/"},{"title":"DO、DTO、BO、AO、VO、POJO","text":"前记最近写项目，凡是不属于数据表对应对象的字段的，但又是连表查询出来的，我都加在了 DO 里（贪方便），然后字段越来越多，实在不妥，然后就去了解标题的那些模型。网上大部分都是只讲概念，虽然也能看懂，但是没有例子实在不好，所以这里会写概念 + 栗子。 参考文章： 细思极恐-你真的会写java吗 DO、DTO、BO、AO、VO、POJO分层领域模型规约： DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。BO（Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。AO（Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。Query：数据查询对象，各层接收上层的查询请求。（注意超过2个参数的查询封装，禁止使用 Map 类来传输）。POJO（Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。 领域模型命名规约： 数据对象：xxxDO，xxx 即为数据表名。数据传输对象：xxxDTO，xxx 为业务领域相关的名称。展示对象：xxxVO，xxx 一般为网页名称。POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 为什么不能只用 DO假如我们的项目中有一个 UserDO 实体，对应数据表 user： 1234567891011121314151617public class UserDO { private Integer id; // 唯一主键 private Date createdTime; // 创建时间 private Date updatedTime; // 最后更新时间 private String name; // 姓名 private Integer age; // 年龄 private String gender; // 性别 private String address; // 住址 private String password; // 密码 private String nickName; // 昵称 private Date birthday; // 生日 private String politicalStatus; // 政治面貌,1表示群众,2表示团员,3表示党员,4表示其他,100表示未知 private Integer companyId; // 公司的ID private Integer status; // 数据状态,1表示可用,0表示不可用 // setter and getter} 然后从 DAO 一直到前端展示，我们都通过这个 UserDO 类的对象来进行数据传输。这样做会有什么问题？ 不需要的字段也会传递到前端页面如 password、createdTime、updatedTime 和 status 这几个字段我们可能在前端根本不需要展示，但是这些字段有可能也会被传递到前端（除非我们在 SQL 查询的时候没有查询出对应的字段）。这不仅使数据的传输量增大，还可能有安全性问题。 某些字段需要转换，但是无法支持对于上面例子中的政治面貌字段，我们在数据库中存储的是数字，但是在前端页面我要展示的是中文描述。这种情况只能让前端通过 if/else 的方式来分情况展示。 某些字段要展示，但是并不希望出现在数据库中在 user 表中我们只保存了用户的 companyId，如果我们想让前端展示公司名等不属于 user 表的字段，怎么办？如果只用 UserDo 的话，我们只能在 UserDO 中加多一个 Company 类型的 company 属性，通过这个属性来传递。很明显这样的 DO 已经被污染了。 还有很多问题，这这里就不详细介绍了。 可见，从头用到尾只使用 DO 是不好的。 属性赋值工具模型之间的转换只需要将对应的值拷贝就行了，比如一个个 set： 123456789101112131415@RestController@RequestMapping(&quot;user&quot;)public class UserApi { @Resource private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); return userService.addUser(user); }} 当然以上方法不太好，属性一多，set 起来也多，所以可以用一些工具帮我们拷贝（基本上是浅拷贝，需要注意使用）： 123org.springframework.beans.BeanUtils#copyPropertiesorg.apache.commons.beanutils.PropertyUtils#copyPropertiesorg.apache.commons.beanutils.BeanUtils#copyProperties org.springframework.beans.BeanUtils 和 org.apache.commons.beanutils.BeanUtils 的区别可以参考这篇文章：https://www.cnblogs.com/dongfangshenhua/p/7099970.html","link":"/2018/07/14/zh/programing/java/hierarchical_domain_model/"},{"title":"JVM","text":"Java 虚拟机（JVM） Java 源码，经过编译器编译后生成 .class 字节码文件： Java 源码编译由以下三个过程组成： 分析和输入到符号表 注解处理 语义分析和生成class文件 JVM 将字节码文件翻译成特定平台下的机器码然后运行： 注：编译生成的是字节码，字节码不能直接运行，必须通过 JVM 翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码却不一样。 注：跨平台的是 Java 程序，不是 JVM。JVM 是用 C/C++ 开发的，不能跨平台，不同平台下需要安装不同版本的 JVM。 内存区域根据《Java 虚拟机规范》，运行时数据区通常包括这几个部分：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。 规范中虽然规定了程序在执行期间运行时数据区应该包括这几部分，但是至于具体如何实现并没有做出规定，不同的虚拟机厂商可以有不同的实现方式。 程序计数器（Program Counter Register）程序计数器是一个比较小的内存区域，作用：指示当前线程所执行的字节码执行到了第几行。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。 在 JVM 中，多线程是通过线程轮流切换来获得CPU执行时间的，所以在任一具体时刻，一个CPU的内核只会执行一条线程中的指令。为了使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，程序计数器是每个线程所私有的。 如果程序执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令地址； 如果正在执行的是一个本地（native，由 C 语言编写完成）方法，则计数器的值为 Undefined。 由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此程序计数器也是所有 JVM 内存区域中唯一一个没有定义 OutOfMemoryError 的区域。 虚拟机栈（JVM Stack） 虚拟机栈是 Java 方法执行的内存模型 当线程执行一个方法时，就会创建一个相应的栈帧（Statck Frame），并将建立的栈帧压栈，当方法执行完后，便会将栈帧出栈。 栈帧中存储了局部变量表（Local Variables）、操作数栈（Operand Stack）、动态链接、方法返回地址（Return Address）等。 局部变量表中存储着方法的相关局部变量（包括在方法中声明的非静态变量以及函数形参）。基本类型中只有 long 和 double 类型会占用2个局部变量空间（Slot，对于32位机器，1 Slot = 32 bit），其它都是1个局部变量空间。 注：局部变量表在编译时就已确定，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。 虚拟机栈中定义了两种异常： 栈溢出（StatckOverFlowError）：如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出； 内存溢出（OutOfMemoryError）：多数 JVM 允许动态扩展虚拟机栈的大小，如果线程一直申请栈，直到内存不足，则抛出。 每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。 本地方法栈（Native Method Statck）本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同。 唯一区别：虚拟机栈用于执行 Java 方法；本地方法栈用于执行本地方法（Native Method）。 在规范中并没有对本地方法栈的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。比如 Sun 的 JDK 默认的 HotSpot 虚拟机就直接把本地方法栈与虚拟机栈放在一起使用。 本地方法栈也是线程私有的。 堆区（Heap）堆区是理解 GC 机制最重要的区域。在 JVM 所管理的内存中，堆区最大，是 GC 机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象以及数组都在堆区上分配内存（当然也有栈上直接分配的）。 根据 JVM 规范，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍然没有足够的内存可分配，也不能进行扩展，将会抛出 OutOfMemoryError:Java heap space 异常。 堆是被所有线程共享的，在 JVM 中只有一个堆。 方法区（Method Area）方法区在 JVM 中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。 在 JVM 规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为 HotSpot 虚拟机将分代收集的思想扩展到了方法区，并将方法区设计成了永久代，从而 JVM 的垃圾收集器可以像管理堆区一样管理这部分区域。但实际上，方法区并不是堆（Non-Heap），从而不需要专门为这部分设计垃圾回收机制。而自从 JDK7 之后，Hotspot 虚拟机便将运行时常量池从永久代移除了。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 在 Class 文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。 在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到 JVM 后，对应的运行时常量池就被创建出来。 运行时常量池（Runtime Constant Pool）： 方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）； 运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如 String 类的 intern() 方法，作用是 String 维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。 方法区在物理上不需要连续，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。 在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。 方法区定义了 OutOfMemoryError:PermGen space 异常，在内存不足时抛出。 直接内存（Direct Memory）直接内存并不是 JVM 管理的内存，是 JVM 以外的机器内存（比如机器有4G内存，JVM 占用了1G，则其余的3G就是直接内存）。 JDK 中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由 C 语言实现的 native 函数库分配在直接内存中，用存储在 JVM 堆中的 DirectByteBuffer 来引用。由于直接内存受本机器内存的限制，所以可能出现 OutOfMemoryError。 对象的访问方式引用访问涉及到 JVM 的三个内存区域：栈，堆，方法区。 举个栗子： 1Object obj = new Object(); obj 表示一个本地引用，存储在 JVM 栈的本地变量表中； new 出来的 Object 作为实例对象数据存储在堆中； 堆中还记录了 Object 类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中。 在 JVM 规范中，对于通过引用类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种： 通过句柄访问 通过句柄访问的实现方式中，JVM 堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。 通过直接指针访问 通过直接指针访问的方式中，引用中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在 HotSpot 虚拟机中用的就是这种方式。 内存溢出常见的错误提示： tomcat:java.lang.OutOfMemoryError:PermGen space tomcat:java.lang.OutOfMemoryError:Java heap space java:java.lang.OutOfMemoryError 导致 OutOfMemoryError 异常的常见原因： 内存中加载的数据量过于庞大，如一次从数据库取出过多数据 集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收 代码中存在死循环或循环产生过多重复的对象实体 使用的第三方软件中的BUG 启动参数内存值设定过小 java.lang.OutOfMemoryError 增加 JVM 内存大小： 在执行某个 Class 文件时，设置 -Xmx256M 所允许占用的最大内存为256M。 对 Tomcat 容器，可以在启动时设置内存限度。在 catalina.bat 中添加：set CATALINA_OPTS=-Xms128M -Xmx256Mset JAVA_OPTS=-Xms128M -Xmx256M 其中 -Xms128M 为最小内存，-Xmx256M 为最大内存。 优化程序： 检查代码中是否有死循环或递归调用。 检查是否有大循环重复产生新对象实体。 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。 检查 List、Map 等集合对象是否有使用完后，未清除的问题。List、Map 等集合对象会始终存有对对象的引用，使得这些对象不能被 GC 回收。 主要包括避免死循环，应该及时释放种资源：内存, 数据库的各种连接，防止一次载入太多的数据。导致的根本原因是程序不健壮。因此，从根本上解决Java内存溢出的唯一方法就是修改程序，及时地释放没用的对象，释放内存空间。 遇到该错误的时候要仔细检查程序，嘿嘿，遇多一次这种问题之后，以后写程序就会小心多了。 tomcat:java.lang.OutOfMemoryError:PermGen space PermGen space：内存的永久保存区域（Permanent Generation space），这块内存主要是被 JVM 存放 Class 和 Meta 信息,Class 在被 Loader 时就会被放到 PermGen space 中, 它和存放类实例（Instance）的 Heap 堆区不同，GC 不会在主程序运行期对 PermGen space 进行清理，所以如果应用中有很多 Class 的话,就很可能出现 PermGen space 错误, 这种错误常见在 Web 服务器对 JSP 进行 pre compile 的时候。如果 Web APP 下都用了大量的第三方jar, 其大小超过了 JVM 默认的大小（4M）那么就会产生此错误信息了。 解决：修改 TOMCAT_HOME/bin/catalina.sh 的 MaxPermSize 大小： echo “Using CATALINA_BASE: $CATALINA_BASE” 在上面加入：JAVA_OPTS=&quot;-server -XX:PermSize=64M -XX:MaxPermSize=128m 建议：将相同的第三方 jar 文件移置到 tomcat/shared/lib 目录，减少 jar 文档重复占用内存。 内存泄漏排查内存分配这里所说的内存分配，主要指在堆上的分配。一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或 String 等），然后在栈上分配，在栈上分配的很少见，这里不考虑。 Java 的内存分配和回收机制概括起来就是：分代分配，分代回收。 根据存活时间，对象被分为：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。 新生代 对象被创建时，内存的分配首先发生在新生代（大对象可以直接被创建在老年代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被新生代的 GC 机制清理掉，这个 GC 机制被称为 Minor GC 或叫 Young GC。 注：Minor GC 并不代表新生代内存不足，它只是表示在 Eden 区上的 GC。 新生代分为3个区域： 较大 Eden 区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过） 较小 两个大小相等的存活区（Survivor0、Survivor1）。 新生代内存分配过程： 绝大多数刚创建的对象会被分配在 Eden 区，其中的大多数对象很快就会消亡。Eden 区是连续的内存空间，因此在其上分配内存极快； 当 Eden 区满的时候，将执行 Minor GC 清掉消亡的对象，并将剩余的对象复制到存活区 Survivor0（此时，Survivor1 空，因为两个 Survivor 总有一个为空）； 下次 Eden 区满了，再执行一次 Minor GC 清掉消亡的对象，将存活的对象复制到 Survivor1 中，然后清空 Eden 区； 将 Survivor0 中消亡的对象清理掉，将其中可以晋级的对象晋级到 Old 区，将存活的对象也复制到 Survivor1 区，然后清空 Survivor0 区； 当两个存活区切换了几次之后（HotSpot 虚拟机默认15次，用 -XX:MaxTenuringThreshold 控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值），仍然存活的对象（其实只有一小部分，比如我们自己定义的对象），将被复制到老年代。 从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将 Eden 区和一个 Survivor 中仍然存活的对象复制到另一个 Survivor 中）。不过，它也只在新生代下高效，如果在老年代仍然采用这种方式，则不再高效。 在 Eden 区，HotSpot 虚拟机使用了两种技术来加快内存分配： bump-the-pointer：由于 Eden 区是连续的，因此改技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度。 TLAB（Thread-Local Allocation Buffers）：该技术是对于多线程而言的，将 Eden 区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB 结合 bump-the-pointer 技术，将保证每个线程都使用 Eden 区的一段，并快速地分配内存。 老年代（Old Generation） 对象如果在新生代存活了足够长的时间而没有被清理掉（即在几次 Minor GC 后存活了下来），则会被复制到老年代，老年代的空间一般比新生代大，能存放更多的对象，在老年代上发生的 GC 次数也比新生代少。当老年代内存不足时，将执行 Major GC 或叫 Full GC。 -XX:+UseAdaptiveSizePolicy：是否采用动态控制策略。如果动态控制，则动态调整堆中各个区域的大小以及进入老年代的年龄。 如果对象比较大（比如长字符串或大数组），新生代空间不足，则大对象会直接分配到老年代上（大对象可能触发提前 GC，应少用，更应避免使用短命的大对象）。 -XX:PretenureSizeThreshold：控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。 可能存在老年代对象引用新生代对象的情况，如果需要执行 Minor GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决方法：老年代中维护一个 512 byte 的块 —— card table，所有老年代对象引用新生代对象的记录都记录在这里。Minor GC 时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。 回收机制新生代 新生代使用“停止-复制”算法进行清理，每次进行清理时，将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中，然后清理掉 Eden 和刚才的 Survivor。 停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的 Eden 区和2个小的 Survivor 区来避免这个问题） 由于绝大部分的对象都是短命的，甚至存活不到 Survivor 中，所以 Eden 区比 Survivor 大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor + Eden 中存活下来的内存超过了10%，则需要将一部分对象分配到老年代。用 -XX:SurvivorRatio 参数来配置 Eden 区域 Survivor 区的容量比值，默认是8，代表 Eden：Survivor1：Survivor2 = 8:1:1。 老年代 老年代存储的对象比新生代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。 在发生 Minor GC 时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小： 大于：直接触发一次 Full GC。 小于：查看是否设置了 -XX:+HandlePromotionFailure（允许担保失败）：如果允许，则只会进行 Minor GC，此时可以容忍内存分配失败；如果不允许，则仍然进行 Full GC。这表示如果设置了不允许担保失败，则触发 Minor GC 就会同时触发 Full GC，哪怕老年代还有很多内存，所以最好不要这样做。 方法区（永久代） 永久代的回收有两种： 常量池的常量：没有引用了就可以被回收。 无用的类信息，需满足3点：类的所有实例都已经被回收、加载类的 ClassLoader 已经被回收、类对象的 Class 对象没有被引用（即没有通过反射引用该类的地方）。 垃圾收集器在 GC 机制中，起重要作用的是垃圾收集器，垃圾收集器是 GC 的具体实现，JVM 规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾收集器各不相同，HotSpot 1.6 版使用的垃圾收集器如下图（两个收集器之间有连线，说明它们可以配合使用）： 注：在新生代采用的停止复制算法中，“停止（stop-the-world）”表示在回收内存时，需要暂停其他所有线程的执行。这很低效，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。 注意并发（Concurrent）和并行（Parallel）的区别： 并发是指用户线程与 GC 线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在 CMS 中用户线程还是需要停顿的，只是非常短，GC 线程在另一个 CPU上 执行）； 并行收集是指多个 GC 线程并行工作，但此时用户线程是暂停的。 Serial 串行，Parallel 并行，CMS 并发，G1 既可以并行也可以并发。 Serial 收集器 新生代收集器 停止复制算法 单线程串行 GC，暂停其它工作线程 -XX:+UseSerialGC：开启 Serial + Serial Old 进行内存回收 Serial 收集器是虚拟机在 Client 模式下默认的新生代收集器，其收集效率大约是100M左右的内存需要几十到100多毫秒。收集桌面应用的内存垃圾，基本上不影响用户体验。所以一般的 Java 桌面应用中，使用默认的 Serial 收集器即可。 ParNew 收集器Serial 收集器的多线程版本，默认开通的线程数与CPU数量相同。 新生代收集器 停止复制算法 多个线程并行 GC，暂停其它工作线程，Serial 收集器的多线程版，缩短垃圾收集时间 -XX:+UseParNewGC：开启 ParNew + Serial Old 进行内存回收 -XX:ParallelGCThreads：设置执行内存回收的线程数 -XX:SurvivorRatio： -XX:PretenureSizeThreshold： -XX:+HandlePromotionFailure： -XX:MaxTenuringThreshold： Parallel Scavenge 收集器 新生代收集器 停止复制算法 关注 CPU 吞吐量，即运行用户代码的时间/总时间，比如：JVM 运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，能最高效率地利用CPU，适合后台数据运算 -XX:+UseParallelGC：开启 Parallel Scavenge + Serial Old 进行内存回收（Server 模式下的默认设置） -XX:GCTimeRatio：设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收 -XX:MaxGCPauseMillis：设置 GC 的最大停顿时间（该参数只对 Parallel Scavenge 有效） -XX:+UseAdaptiveSizePolicy：设置自适应调节策略，如自动调整 Eden/Survivor 比例，老年代对象年龄，新生代大小等 Serial Old 收集器一般用在 Client 模式。 老年代收集器 标记整理算法：Sweep（清理）和 Compact（压缩）。Sweep 是将废弃的对象清掉，只留幸存的对象；Compact 是移动对象将空间填满保证内存分为2块：一块全是对象、一块空闲 单线程串行 GC，暂停其它工作线程 JDK 1.5 前，Serial Old + ParallelScavenge 进行内存回收 Parallel Old 收集器 老年代收集器 标记整理算法：Summary（汇总）和 Compact（压缩）。Summary 是将幸存的对象复制到预先准备好的区域，而不是像 Sweep 那样清理废弃的对象 多线程并行 GC，暂停其它工作线程 有利于多核计算 -XX:+UseParallelOldGC 开启 Parallel Scavenge + Parallel Old 进行内存回收 在 JDK 1.6 后，Parallel Old + Parallel Scavenge 配合有很好的效果，能充分体现 Parallel Scavenge 收集器吞吐量优先的效果。 CMS（Concurrent Mark Sweep）收集器 老年代收集器 关注最短回收停顿时间（即缩短垃圾回收的时间），强调用户交互体验 标记清除算法 并发收集（用户线程可以和 GC 线程同时工作），停顿小 标记清除算法执行过程：（2次标记，1次预清理，1次重新标记，再1次清除） 初始标记（CMS-initial-mark） 并发标记（CMS-concurrent-mark） 预清理（CMS-concurrent-preclean） 可控预清理（CMS-concurrent-abortable-preclean） 重新标记（CMS-remark） 并发清除（CMS-concurrent-sweep） 并发重设状态等待下次 CMS 的触发（CMS-concurrent-reset） -XX:+UseConcMarkSweepGC：开启 ParNew + CMS + Serial Old 进行内存回收。Server 模式下优先使用 ParNew + CMS，当用户线程内存不足发生 Concurrent Mode Failure 时，由备用方案 ParNew + Serial Old 收集 -XX:CMSInitiatingOccupancyFraction： -XX:+UseCMSCompactAtFullCollection： -XX:CMSFullGCsBeforeCompaction： CMSIncrementalMode： CMS 收集器变种，属增量式垃圾收集器，在并发标记和并发清理时交替运行垃圾收集器和用户线程。 G1（Garbage First）收集器 堆被划分成许多个连续的区域（region） G1 算法 支持很大的堆，高吞吐量 支持多 CPU 和垃圾回收线程 在主线程暂停的情况下，使用并行收集 在主线程运行的情况下，使用并发收集 实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收 –XX:+UseG1GC：开启 G1 进行内存回收 JVM 调优参数http://kenwublog.com/docs/java6-jvm-options-chinese-edition.htm 性能参数:往往用来定义内存分配的大小和比例。 参数及其默认值 描述 -XX:NewSize=2.125m 新生代对象生成时占用内存的默认值 -XX:MaxNewSize=size 新生成对象能占用内存的最大值 -XX:MaxPermSize=64m 方法区所能占用的最大内存（非堆内存） -XX:PermSize=64m 方法区分配的初始内存 -XX:MaxTenuringThreshold=15 对象在新生代存活区切换的次数（坚持过 Minor GC 的次数，每坚持过一次，该值就增加1），大于该值会进入老年代 -XX:MaxHeapFreeRatio=70 GC 后 Java 堆中空闲量占的最大比例，大于该值，则堆内存会减少 -XX:MinHeapFreeRatio=40 GC 后 Java 堆中空闲量占的最小比例，小于该值，则堆内存会增加 -XX:NewRatio=2 新生代内存容量与老生代内存容量的比例 -XX:ReservedCodeCacheSize=32m 保留代码占用的内存容量 -XX:ThreadStackSize=512 设置线程栈大小，若为0则使用系统默认值 -XX:LargePageSizeInBytes=4m 设置用于 Java 堆的大页面尺寸 -XX:PretenureSizeThreshold=size 大于该值的对象直接晋升入老年代（这种对象少用为好） -XX:SurvivorRatio=8 Eden 区域 Survivor 区的容量比值，如默认值为8，表示 Eden：Survivor0：Survivor1 = 8:1:1 常用的行为参数：用来选择使用什么样的垃圾收集器组合，以及控制运行过程中的 GC 策略等。 参数及其默认值 描述 -XX:-UseSerialGC 启用串行 GC，即采用 Serial + Serial Old 模式 -XX:-UseParallelGC 启用并行 GC，即采用 Parallel Scavenge + Serial Old 收集器组合（Server 模式默认） -XX:GCTimeRatio=99 设置用户执行时间占总时间的比例（默认值99，即1%的时间用于 GC） -XX:MaxGCPauseMillis=time 设置 GC 的最大停顿时间（这个参数只对 Parallel Scavenge 有效） -XX:+UseParNewGC 使用 ParNew + Serial Old 收集器组合 -XX:ParallelGCThreads 设置执行内存回收的线程数，在 +UseParNewGC 的情况下使用 -XX:+UseParallelOldGC 使用 Parallel Scavenge + Parallel Old 组合收集器 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 组合并发收集 -XX:-DisableExplicitGC 禁止调用 System.gc() 但 JVM 的 gc 仍有效 -XX:+ScavengeBeforeFullGC 新生代 GC 优先于 Full GC 执行 常用的调试参数：用于监控和打印 GC 的信息。 参数及其默认值 描述 -XX:-CITime 打印消耗在 JIT 编译的时间 -XX:ErrorFile=./hs_err_pid.log 保存错误日志或者数据到文件中 -XX:-ExtendedDTraceProbes 开启 solaris 特有的 dtrace 探针 -XX:HeapDumpPath=./java_pid.hprof 指定导出堆信息时的路径或文件名 -XX:-HeapDumpOnOutOfMemoryError 当首次遭遇 OOM 时导出此时堆中相关信息 -XX:OnError=”;“ 出现致命 ERROR 之后运行自定义命令 -XX:OnOutOfMemoryError=”;“ 当首次遭遇 OOM 时执行自定义命令 -XX:-PrintClassHistogram 遇到 Ctrl-Break 后打印类实例的柱状信息，与 jmap -histo 功能相同 -XX:-PrintConcurrentLocks 遇到 Ctrl-Break 后打印并发锁的相关信息，与 jstack -l 功能相同 -XX:-PrintCommandLineFlags 打印在命令行中出现过的标记 -XX:-PrintCompilation 当一个方法被编译时打印相关信息 -XX:-PrintGC 每次 GC 时打印相关信息 -XX:-PrintGC Details 每次 GC 时打印详细信息 -XX:-PrintGCTimeStamps 打印每次 GC 的时间戳 -XX:-TraceClassLoading 跟踪类的加载信息 -XX:-TraceClassLoadingPreorder 跟踪被引用到的所有类的加载信息 -XX:-TraceClassResolution 跟踪常量池 -XX:-TraceClassUnloading 跟踪类的卸载信息 -XX:-TraceLoaderConstraints 跟踪类加载器约束的相关信息 启动内存分配具体配置多少？设置小了，频繁 GC（甚至内存溢出），设置大了，内存浪费。建议： -XX:PermSize：尽量比 -XX:MaxPermSize 小，-XX:MaxPermSize &gt;= 2 x -XX:PermSize, -XX:PermSize &gt; 64m，对于4G内存的机器，-XX:MaxPermSize 一般不超过256m。 -Xms = -Xmx（线上 Server 模式）：以防止抖动，大小受操作系统和内存大小限制，如果是32位系统，则一般设置为1g~2g（假设有4g内存），在64位系统上，没有限制，一般为机器最大内存的一半左右。 -Xmn：在开发环境下，-XX:NewSize 和 -XX:MaxNewSize 设置新生代的大小；在生产环境下，建议只设置 -Xmn，并且大小是 -Xms 的1/2左右，不要过大或过小，过大导致老年代变小，频繁 Full GC，过小导致 Minor GC 频繁。如果不设置 -Xmn，可以设置 -XX:NewRatio=2，效果一样。 -Xss：默认值即可。 -XX:SurvivorRatio：8~10左右，推荐设置为10，即 Survivor 区的大小是 Eden 区的 1/10，因为对于普通程序，一次 Minor GC 后，至少98%-99%的对象，都会消亡，该设置能使 Survivor 区容纳下10-20次的 Minor GC 才满，然后再进入老年代，这个与 -XX:MaxTenuringThreshold 的默认值15次也相匹配的。如果设置过小，会导致本来能通过 Minor GC 回收掉的对象提前进入老年代，产生不必要的 Full GC；如果设置过大，会导致 Eden 区相应的被压缩。 -XX:MaxTenuringThreshold：默认15，也就是说，经过15次 Survivor 轮换（即15次 Minor GC）就进入老年代，如果设置过小，则新生代对象在 Survivor 中存活的时间减小，提前进入年老代，对于老年代比较多的应用，可以提高效率。如果设置过大，则新生代对象会在 Survivor 区进行多次复制，这样可以增加对象在新生代的存活时间，增加在新生代即被回收的概率。注意：设置了该值，并不表示对象一定会在新生代存活15次才被晋升进入老年代，它只是一个最大值，事实上，存在一个动态计算机制，计算每次晋入老年代的阈值，取阈值以 MaxTenuringThreshold 中较小的一个为准。 -XX:PretenureSizeThreshold：默认值即可。 监控工具在 JVM 运行的过程中，为保证其稳定、高效，或在出现 GC 问题时分析问题原因，我们需要对 GC 进行监控。所谓监控，其实就是分析清楚当前 GC 的情况。其目的是鉴别 JVM 是否在高效的进行垃圾回收，以及有没有必要进行调优。 通过监控GC，我们可以搞清楚很多问题，如： Minor GC 和 Full GC 的频率 执行一次 GC 所消耗的时间 新生代的对象何时被移到老生代以及花费了多少时间 每次 GC 中，其它线程暂停（Stop the world）的时间 每次 GC 的效果如何，是否不理想 jps 用于查询正在运行的 JVM 进程。 常用参数 描述 -q 只输出 LVMID，省略主类的名称 -m 输出虚拟机进程启动时传给主类 main() 函数的参数 -l 输出主类的全类名，如果进程执行的是 jar 包，输出 jar 路径 -v 输出虚拟机进程启动时 JVM 参数 命令格式：jps [option] [hostid] 栗子： 123$ jps -l19688 sun.tools.jps.Jps19610 com.zoctan.api.Application 上面的 vid 为 19610 的 api.Application 进程在提供 web 服务。 jstat 实时显示本地或远程 JVM 进程中类装载、内存、垃圾收集、JIT 编译等数据（如果要显示远程 JVM 信息，需要远程主机开启 RMI 支持）。如果在服务启动时没有指定启动参数 -verbose:gc，则可以用 jstat 实时查看 GC 情况。 常用参数 描述 -class 监视类装载、卸载数量、总空间及类装载所耗费的时间 -gc 监听堆状况，包括 Eden 区、两个 Survivor 区、老年代、永久代等的容量，已用空间、GC 时间合计等 -gccapacity 监视内容与 -gc 基本相同，但输出主要关注堆的各个区域使用到的最大和最小空间 -gcutil 监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比 -gccause 与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因 -gcnew 监视新生代 GC 状况 -gcnewcapacity 监视内同与 -gcnew 基本相同，输出主要关注使用到的最大和最小空间 -gcold 监视老年代 GC 情况 -gcoldcapacity 监视内同与 -gcold 基本相同，输出主要关注使用到的最大和最小空间 -gcpermcapacity 输出永久代使用到最大和最小空间 -compiler 输出 JIT 编译器编译过的方法、耗时等信息 -printcompilation 输出已经被 JIT 编译的方法 命令格式：jstat [option vmid [interval[s|ms] [count]]] 命令格式中 VMID 和 LVMID 说明： 如果是本地虚拟机进程，VMID 和 LVMID 一致 如果是远程虚拟机进程，VMID 格式：[protocol:][//]lvmid[@hostname[:port]/servername]，如果省略 interval 和 count，则只查询一次。 栗子：搜集 vid 为 19600 的 Java 进程的整体 GC 状态，每1000ms收集一次，共收集3次。 12345$ jstat -gc 19600 1000 3 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 7680.0 7680.0 4386.2 0.0 48640.0 17858.7 128512.0 88.0 19456.0 18871.3 2304.0 2164.6 2 0.018 0 0.000 0.0187680.0 7680.0 4386.2 0.0 48640.0 17858.7 128512.0 88.0 19456.0 18871.3 2304.0 2164.6 2 0.018 0 0.000 0.0187680.0 7680.0 4386.2 0.0 48640.0 17858.7 128512.0 88.0 19456.0 18871.3 2304.0 2164.6 2 0.018 0 0.000 0.018 XXXC：该区容量，XXXU：该区使用量 描述 S0C Survivor0区容量（Survivor1区相同，略） S0U Survivor0区已使用 EC Eden 区容量 EU Eden 区已使用 OC 老年代容量 OU 老年代已使用 PC Perm 容量 PU Perm 区已使用 YGC Young GC（Minor GC）次数 YGCT Young GC 总耗时 FGC Full GC 次数 FGCT Full GC 总耗时 GCT GC 总耗时 -gcutil 查看内存： 12345$ jstat -gcutil 19600 1000 3 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 57.11 0.00 36.72 0.07 96.99 93.95 2 0.018 0 0.000 0.01857.11 0.00 36.72 0.07 96.99 93.95 2 0.018 0 0.000 0.01857.11 0.00 36.72 0.07 96.99 93.95 2 0.018 0 0.000 0.018 各列与用 gc 参数时基本一致，不同的是这里显示的是已占用的百分比，如 S0 为 57.11，代表着 S0 区已使用了57.11%。 jinfo 查询当前运行的 JVM 属性和参数的值。 常用参数 描述 -flag 显示未被显示指定的参数的系统默认值 -flag -flag name=value: 修改部分参数 -sysprops 打印虚拟机进程的 System.getProperties() 命令格式：jinfo [option] pid jmap 显示当前堆和永久代的详细信息，如当前使用的收集器，当前的空间使用率等。 常用参数 描述 -dump 生成堆转储快照 -heap 显示堆详细信息(只在 Linux/Solaris 下有效) -F 当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成dump快照(只在 Linux/Solaris 下有效) -finalizerinfo 显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象(只在 Linux/Solaris 下有效) -histo 显示堆中对象统计信息 -permstat 以 ClassLoader 为统计口径显示永久代内存状态(只在 Linux/Solaris 下有效) 命令格式：jmap [option] vmid 其中前面3个参数最重要，如：查看对详细信息：sudo jmap -heap 309生成 dump 文件： sudo jmap -dump:file=./test.prof 309部分用户没有权限时，采用 admin 用户：sudo -u admin -H jmap -dump:format=b,file=文件名.hprof pid查看当前堆中对象统计信息：sudo jmap -histo 309 该命令显示3列，分别为对象数量，对象大小，对象名称，通过该命令可以查看是否内存中有大对象；有的用户可能没有 jmap 权限：sudo -u admin -H jmap -histo 309 | less jhat 分析使用 jmap 生成的 dump 文件。 命令格式：jhat -J -Xmx512m [file] jstack 生成当前 JVM 的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。 常用参数 描述 -F 当正常输出的请求不被响应时，强制输出线程堆栈 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用到本地方法的话，可以显示 C/C++ 的堆栈 命令格式：jstack [option] vmid 调优步骤在调优之前，需要记住下面的原则： 多数的 Java 应用不需要在服务器上进行 GC 优化 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合） 减少创建对象的数量 减少使用全局变量和大对象 GC 优化是到最后不得已才采用的手段 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多 GC 优化的目的： 将转移到老年代的对象数量降低到最小 减少 Full GC 的执行时间 为了达到上面的目的，需要： 减少使用全局变量和大对象 调整新生代的大小到最合适 设置老年代的大小为最合适 选择合适的 GC 收集器 真正熟练的使用 GC 调优，是建立在多次进行 GC 监控和调优的实战经验上的，进行监控和调优的一般步骤为： 监控 GC 状态 分析结果，判断是否需要优化 调整 GC 类型和内存分配 不断的分析和调整 全面应用参数 监控 GC 状态使用各种 JVM 工具，查看当前日志，分析当前 JVM 参数设置，并且分析当前堆内存快照和 GC 日志，根据实际的各区域内存划分和 GC 执行时间，判断是否进行优化。 分析结果，判断是否需要优化如果各项参数设置合理，系统没有超时日志出现，GC 频率不高，GC 耗时不高，那么没有必要进行 GC 优化；如果 GC 时间超过1-3秒，或者频繁 GC，则必须优化。注：如果满足下面的指标，则一般不需要优 GC： Minor GC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。 调整 GC 类型和内存分配如果内存分配过大或过小，或者采用的 GC 收集器比较慢，则应该优先调整这些参数，并且先找一台或几台机器进行测试，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。 不断的分析和调整通过不断的试验和试错，分析并找到最合适的参数。 全面应用参数如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。 调优实例实例1 原作者发现部分开发测试机器出现异常：java.lang.OutOfMemoryError: GC overhead limit exceeded。该异常表示：GC 为了释放很小的空间却耗费了太多的时间，其原因一般有两个：堆太小，死循环/大对象。 因为这个应用有在线上运行，所以首先排除第2个原因，如果应用本身有问题，线上早就挂了，所以怀疑开发测试机器中堆设置太小。 使用 ps -ef | grep java 查看发现运行的程序带有这些参数：-Xms768m -Xmx768m -XX:NewSize=320m -XX:MaxNewSize=320m 该程序较大，需要占用的内存也比较多。但堆区设置只有768m，而机器内存有2G，机器上只跑这一个 Java 应用，没有其他需要占用内存的地方。 通过上面的情况判断，只需要增大堆中各区域的大小即可，于是改成下面的参数：-Xms1280m -Xmx1280m -XX:NewSize=500m -XX:MaxNewSize=500m 跟踪运行情况发现，相关异常没有再出现。 实例2 http://www.360doc.com/content/13/0305/10/15643_269388816.shtml 一个服务系统，经常出现卡顿，分析原因，发现 Full GC 时间太长： 123$ jstat -gcutil: S0 S1 E O P YGC YGCT FGC FGCT GCT12.16 0.00 5.18 63.78 20.32 54 2.047 5 6.946 8.993 分析上面的数据，发现 Young GC 执行了54次，耗时2.047秒，每次 Young GC 耗时37ms，在正常范围，而 Full GC 执行了5次，耗时6.946秒，每次平均1.389s，表明问题是：Full GC 耗时较长。 分析该程序的参数发现：NewRatio = 9，也就是说，新生代和老生代大小之比为1:9，这就是问题的原因： 新生代太小，导致对象提前进入老年代，触发老年代发生 Full GC 老年代较大，进行 Full GC 时耗时较大 调整比例 NewRatio = 4，发现卡顿现象减少，Full GC 没有再发生，只有 Young GC 在执行。这就是把对象控制在新生代就清理掉，没有进入老年代（这种做法对一些应用是很有用的，但并不是对所有应用都要这么做）。 类加载机制JVM 类加载机制分为：加载，验证，准备，解析，初始化。 加载这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。 注：不一定从 Class 文件获取，既可以从 ZIP 包中读取（比如 jar 包和 war 包），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。 注意这里所说的初始值概念，比如一个类变量定义为： 123// 变量 v 在准备阶段过后的初始值为 0 而不是 8080// 将 v 赋值为 8080 的 putstatic 指令是程序被编译后，存在类构造器&lt;client&gt;方法中public static int v = 8080; 但如果声明为： 123// 在编译阶段会为变量 v 生成 ConstantValue 属性// 在准备阶段，虚拟机会根据 ConstantValue 属性将 v 赋值为 8080public static final int v = 8080; 解析该阶段指虚拟机将常量池中的符号引用替换为直接引用的过程。 符号引用就是 Class 文件中的 CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info 等类型的常量。 符号引用和直接引用的概念： 符号引用与虚拟机实现的布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有直接引用，那引用的目标必定已经在内存中。 初始化该阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证方法执行之前，父类的方法已经执行完毕。 注意：如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。 注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize为false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，不会触发初始化动作。 类加载器种类从 JVM 的角度，只有两种类加载器： 启动类加载器（Bootstrap ClassLoader）：该类加载器由 C++ 语言实现（HotSpot），是虚拟机自身的一部分。 其他的类加载器：这些类加载器由 Java 语言实现，独立于虚拟机外部，并且全部继承自 java.lang.ClassLoader。 从开发者的角度，类加载器可以细分为： 启动类加载器：负责将 Java_Home/lib 下面的类库加载到内存中（比如 rt.jar）。由于启动类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 标准扩展（Extension）类加载器：由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现，负责将 Java_Home/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 应用程序（Application）类加载器：由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现，负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于该类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统（System）加载器。 除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）。 双亲委派双亲委派模型过程 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的 Java 类，可以正常编译，但是永远无法被加载运行。 双亲委派模型的系统实现 在 java.lang.ClassLoader 的 loadClass() 方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的 loadClass() 方法，若父加载器为 null 则默认使用启动类加载器作为父加载器。如果父加载失败，则在抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。 12345678910111213141516171819202122protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve) throws ClassNotFoundException{ //check the class has been loaded or not Class c = findLoadedClass(name); if(c == null) { try{ if(parent != null) { c = parent.loadClass(name,false); } else { c = findBootstrapClassOrNull(name); } } catch(ClassNotFoundException e) { //if throws the exception ,the father can not complete the load } if(c == null) { c = findClass(name); } } if(resolve) { resolveClass(c); } return c;} 注：双亲委派模型是 Java 设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但也有较大规模破坏双亲模型的情况，比如线程上下文类加载器（Thread Context ClassLoader），具体可参见周志明著《深入理解Java虚拟机》。","link":"/2018/07/24/zh/programing/java/jvm/"},{"title":"MyBatis 注意点","text":"#{ } 和 ${ } 的区别#{ } 表示一个占位符号，通过 #{ } 可以在 preparedStatement 实现向占位符中设置值，自动进行 Java 类型和 Jdbc 类型转换，可以有效防止 SQL 注入。 可以让 #{ } 接收简单类型值或 POJO 属性值（通过 OGNL 读取对象中的值，属性.属性.属性..方式获取对象属性值）。如果在 parameterType 传输单个简单类型值，#{ } 括号中可以是 value 或其它名称。 比如： 12INSERT INTO user(name, years)VALUES(#{user.name, jdbcType=STRING}, #{user.sex, jdbcType=INTEGER}) 在解析时会加上” “,当成字符串来解析： 12INSERT INTO user(name, years)VALUES(&quot;myname&quot;, 20) ${ } 表示拼接 SQL 语句，通过 ${ } 可以将 parameterType 传入的内容拼接在 SQL 中。如果 parameterType 传输单个简单类型值，${ } 括号中只能是 value。 比如： 12INSERT INTO user(name, years)VALUES(${user.name, jdbcType=STRING}, ${user.sex, jdbcType=INTEGER}) 会解析成： 12INSERT INTO user(name, years)VALUES(user.name, user.sex) parameterType 和 resultType 区别parameterType：指定输入参数类型，mybatis 通过 ognl 从输入对象中获取参数值拼接在 SQL 中。 resultType：指定输出结果类型，mybatis 将 SQL 查询结果的一行记录数据映射为 resultType 指定类型的对象。 selectOne 和 selectList 区别selectOne 对查询出的一条记录进行映射，如果查询出多条记录则抛出异常： org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to bereturned by selectOne(), but found: 3 selectList 可以查询一条或多条记录来进行映射。","link":"/2018/07/01/zh/programing/java/mybatis/"},{"title":"面向对象设计原则","text":"简介对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。 在面向对象设计中，可维护性的复用是以设计原则为基础的。每个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升软件结构的设计水平。 常见的7种面向对象设计原则： 单一职责原则SRP：Single Responsibility Principle -&gt; 一个类只负责一个功能领域中的相应职责 开闭原则OCP：Open-Closed Principle -&gt; 软件实体应对扩展开放，而对修改关闭 里氏代换原则LSP：Liskov Substitution Principle -&gt; 所有引用基类对象的地方能够透明地使用其子类的对象 依赖反转原则DIP：Dependence Inversion Principle -&gt; 抽象不应该依赖于细节，细节应该依赖于抽象 接口隔离原则ISP：Interface Segregation Principle -&gt; 使用多个专门的接口，而不使用单一的总接口 合成复用原则CRP：Composite Reuse Principle -&gt; 尽量使用对象组合，而不是继承来达到复用的目的 迪米特法则LoD：Law of Demeter -&gt; 一个软件实体应当尽可能少地与其他实体发生相互作用 单一职责原则定义：一个类只负责一个功能领域中的相应职责，或定义为：就一个类而言，应该只有一个引起它变化的原因。 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。 单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 举个栗子： 某 CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块的初始设计方案： CustomerDataChart 类中的方法：getConnection() 连接数据库、findCustomers() 查询所有的客户信息、createChart() 创建图表、displayChart() 显示图表。 CustomerDataChart 类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库，或者使用 findCustomers() 方法查询客户信息，就难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。 因此需要对该类进行拆分，使其满足单一职责原则，将 CustomerDataChart 类拆分为如下三个类： DBUtil：负责数据库操作，包括数据库连接方法 getConnection()； CustomerDAO：负责操作数据库中的 Customer 表，包括对 Customer 表的增删改查等方法，如 findCustomers()； CustomerDataChart：负责图表的生成和显示，包括方法 createChart() 和 displayChart()。 重构后的结构： 开闭原则定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展，其中软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在 Java、C# 等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 举个栗子： 某 CRM 系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案： 在 ChartDisplay 类的 display() 方法中存在如下代码片段： 123456789……if (type.equals(&quot;pie&quot;)) { PieChart chart = new PieChart(); chart.display();} else if (type.equals(&quot;bar&quot;)) { BarChart chart = new BarChart(); chart.display();}…… 如果想新增一个图表类，如折线图 LineChart，那么只能修改 ChartDisplay 类的 display() 方法的源代码，增加判断逻辑。如果新增的不止一个图表呢？如果后来需求改了，又得删除呢？代码就会变得难以修改和维护，这就是违反开闭原则的表现。 现对该系统进行重构，使之符合开闭原则： 本例中，由于在 ChartDisplay 类的 display() 方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。只能通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则： 增加一个抽象图表类 AbstractChart，将各种具体图表类作为其子类； ChartDisplay 类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。 重构后的结构： 这时如果想新增一种图表，如折线图 LineChart，那么 LineChart 只需要继承 AbstractChart，客户端在使用时只要向 ChartDisplay 中注入一个 LineChart 对象即可，无须修改现有类库的源代码。 注：xml 和 properties 等格式的配置文件属于纯文本文件，无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的代码没有做任何修改，即可认为该系统是一个符合开闭原则的系统。 里氏替换原则里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士 Barbara Liskov 教授和卡内基·梅隆大学 Jeannette Wing 教授于1994年提出。严格定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。 通俗定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。 比如，有两个类，一个基类 BaseClass，一个子类 SubClass： 12345678910111213class BaseClass {}class SubClass extends BaseClass {}// 方法接受 BaseClass 类型参数void method1(BaseClass base);// 那么也必然可以接受 BaseClass 的子类对象// 即可以这样调用：SubClass sub;method1(sub);// 能够正常运行 但是，反过来不成立： 1234567// 方法接受 SubClass 类型参数void method2(SubClass sub);// 但一般不可以接受 BaseClass 基类对象// 不可以这样调用：BaseClass base;method2(base);// 除非是重载方法 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 需要注意如下几个问题： 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。（根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法） 尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 Java 语言中，在编译阶段，Java 编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但 Java 编译器的检查是有局限的。 举个栗子： 某 CRM 系统中，客户（Customer）可以分为 VIP 客户（VIPCustomer）、普通客户（CommonCustomer）两类，系统需要提供一个发送 Email 的功能，原始设计方案： 无论是普通客户还是 VIP 客户，发送邮件的过程都是相同的，也就是说两个 send() 方法中的代码重复，而且在本系统中还将增加新类型的客户。 为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构： 新增抽象客户类 Customer，将 CommonCustomer 和 VIPCustomer 类作为其子类； 将 EmailSender 中的 send() 方法的参数类型改为 Customer，如果需要增加新类型的客户，只需将其作为 Customer 类的子类即可。 重构后的结构： 本例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。 依赖反转原则定义：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 如果说开闭原则是面向对象设计的目标的话，那么依赖反转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。 需要注意如下几个问题： 代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。 为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时，需要我们针对抽象层编程，将具体类的对象通过依赖注入的方式注入到其他对象中。 依赖注入（DependencyInjection, DI）是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。 常用的注入方式有三种： 构造注入通过构造函数来传入具体类的对象。 Setter注入通过Setter方法来传入具体类的对象。 接口注入通过在接口中声明的业务方法来传入具体类的对象。 这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 举个栗子： 某 CRM 系统：该系统经常需要将存储在 TXT 或 Excel 文件中的客户信息转存到数据库中，因此需要进行数据格式转换，初始设计方案： 该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将 TXTDataConvertor 改为 ExcelDataConvertor，此时，需要修改 CustomerDAO 的源代码，而且在引入并使用新的数据转换类时也不得不修改 CustomerDAO 的源代码。 系统扩展性较差，违反了开闭原则，现需要对该方案进行重构，使之符合依赖反转原则： 引用抽象数据转换类 DataConvertor，CustomerDAO 针对抽象类 DataConvertor 编程； 将具体数据转换类名存储在配置文件中。 根据里氏代换原则，程序运行时，具体数据转换类对象将替换 DataConvertor 类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为 DataConvertor 的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。 重构后的结构： 在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖反转原则。在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖反转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 接口隔离原则定义：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义： 一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象； 一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如 Java 语言中的 interface。 对于这两种不同的含义，接口隔离原则的表达方式以及含义都有所不同： 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 如果把“接口”理解成狭义的特定语言的接口，那么是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 举个栗子： 某 CRM 系统的客户数据显示模块接口： dataRead() 从文件中读取数据transformToXML() 将数据转换成 XML 格式createChart() 创建图表displayChart() 显示图表createReport() 创建文字报表displayReport() 显示文字报表。 在实际使用过程中发现该接口很不灵活： 如果一个具体的数据显示类本身不需要进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的 transformToXML() 方法（至少需要提供一个空实现）； 如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。 CustomerDataDisplay 接口定义了太多方法，即该接口承担了太多职责： 导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量； 由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。 现使用接口隔离原则和单一职责原则对其进行重构： 将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法。 重构后的结构： 注： 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护； 接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。 迪米特法则迪米特法则又称最少知识原则(LeastKnowledge Principle, LKP)，来自1987年美国东北大学(Northeastern University)一个名为 Demeter 的研究项目。 定义：一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等。对于一个对象，其朋友包括以下几类： 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象； 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 需要注意如下几个问题： 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及； 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 举个栗子： 某 CRM 系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，比如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变。初始设计方案： 由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。 现使用迪米特对其进行重构：通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。 重构后的结构： 引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码。","link":"/2018/03/20/zh/programing/java/object_oriented_design_principles/"},{"title":"四种引用和使用场景","text":"强引用（StrongReference）如果一个对象具有强引用，那垃圾回收器（Garbage Collection，GC）绝不会回收它。当内存空间不足，JVM 宁愿抛出 OutOfMemoryError，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 1234567// 强引用Object o = new Object();// 如果不使用时，要弱化引用，帮助 GC 回收此对象// 显式地设为 null 或超出对象的生命周期范围，则 GC 认为该对象不存在引用，这时就会回收该对象// 具体什么时候回收取决于 GC 的算法o = null; 1234567// 在一个方法的内部有一个强引用// 这个引用 o 保存在栈中，而真正的引用内容（Object）保存在堆中// 当这个方法运行完成后就会退出方法栈，引用 o 将会不存在，引用内容 Object 将被回收// 但如果这个 o 是全局的变量，就需要在不用时将其设为 null，因为强引用不会被垃圾回收public void test(){ Object o = new Object();} ArrayList 源码： 1234567891011private transient Object[] elementData;public void clear() { modCount++; // 如果只是 elementData = null，那么强引用仍然存在 // 所以调用该 clear() 方法释放数组中存放的引用类型 // Let gc do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;} 软引用（SoftReference）如果一个对象只具有软引用，当内存空间足够，GC 不会回收它；但内存空间不足时，就会回收这些对象的内存。可以使用软引用实现内存敏感的高速缓存。 软引用可以和引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被 GC 回收，JVM 就会把这个软引用加入到与之关联的引用队列中。 123456789// 强引用String str = new String(&quot;abc&quot;);// 软引用SoftReference&lt;String&gt; softRef = new SoftReference&lt;String&gt;(str);if(JVM.内存不足()) { str = null; // 转换为软引用 System.gc(); // 通知 GC 进行回收} 实际场景：按浏览器的后退按钮时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？ 可能的实现策略： 如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建。 如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。 使用软引用灵活处理： 1234567891011121314// 获取页面进行浏览Browser prev = new Browser();// 浏览完毕后置为软引用SoftReference sr = new SoftReference(prev);if(sr.get() != null) { // 还没有被回收器回收，直接获取 rev = (Browser) sr.get();} else { // 由于内存吃紧，软引用的对象被回收了 // 这时重新构建前一页面 prev = new Browser(); sr = new SoftReference(prev);} 弱引用（WeakReference）弱引用与软引用的区别：只具有弱引用的对象拥有更短暂的生命周期。在 GC 线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于 GC 是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和引用队列联合使用，如果弱引用所引用的对象被垃圾回收，JVM 就会把这个弱引用加入到与之关联的引用队列中。 当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就可以用弱引用。 123456// 强引用String str = new String(&quot;abc&quot;);// 弱引用WeakReference&lt;String&gt; weakRef = new WeakReference&lt;String&gt;(str);// 再次变为强引用String abc = weakRef.get(); 虚引用（PhantomReference）“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被 GC 回收。主要用来跟踪对象被 GC 回收的活动。 虚引用与软引用和弱引用的区别：虚引用必须和引用队列联合使用。当 GC 准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 12ReferenceQueue queue = new ReferenceQueue();PhantomReference pr = new PhantomReference(object, queue); 可以通过判断引用队列中是否加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。","link":"/2018/07/25/zh/programing/java/references_and_usage_scenarios/"},{"title":"Sdkman 管理 JDK 版本","text":"前记JDK 版本越来越多，老是手动下载改环境变量很麻烦。 偶然看到 Sdkman：The Software Development Kit Manager。 它可以管理各种 kit：Ant、Java、Gradle、Maven、Springboot-cli、Groovy、Kotlin、Scala。 安装安装很简单，跟着执行下面的命令就可以了： 注：curl 需要挂 VPN。 1234$ curl -s &quot;https://get.sdkman.io&quot; | bash$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;$ sdk versionSDKMAN 5.7.3+337 使用以安装 Java 为例： 12345678910111213141516171819202122232425$ sdk list java================================================================================Available Java Versions================================================================================ 12.ea.15-open 11.0.1-zulu 11.0.1-open 10.0.2-zulu 10.0.2-open 9.0.7-zulu 9.0.4-open 8.0.191-oracle 8.0.181-zulu 7.0.191-zulu 6.0.113-zulu 1.0.0-rc8-graal 1.0.0-rc7-graal ================================================================================+ - local version* - installed&gt; - currently in use================================================================================ 因为没有安装过所以没有标记当前下载过和正在使用的 Java 版本。 安装需要的版本： 12345678910111213141516171819202122232425$ sdk install java 8.0.191-oracleOracle requires that you agree with the Oracle Binary Code License Agreementprior to installation. The license agreement can be found at: http://www.oracle.com/technetwork/java/javase/terms/license/index.htmlDo you agree to the terms of this agreement? (Y/n): yDownloading: java 8.0.191-oracleIn progress...########################################################################### 100.0%########################################################################### 100.0%Repackaging Java 8.0.191-oracle...Done repackaging...Installing: java 8.0.191-oracleDone installing!Setting java 8.0.191-oracle as default. 安装完成了，可以看下当前的 Java 版本： 123456789101112131415161718192021222324252627282930java -versionPicked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gaspjava version &quot;1.8.0_191&quot;Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)$ sdk list java================================================================================Available Java Versions================================================================================ 12.ea.15-open 11.0.1-zulu 11.0.1-open 10.0.2-zulu 10.0.2-open 9.0.7-zulu 9.0.4-open &gt; * 8.0.191-oracle 8.0.181-zulu 7.0.191-zulu 6.0.113-zulu 1.0.0-rc8-graal 1.0.0-rc7-graal ================================================================================+ - local version* - installed&gt; - currently in use================================================================================ 如何切换版本？ 1234567891011121314151617181920212223$ sdk install java 7.0.141-zulu Downloading: java 7.0.141-zuluIn progress...######################################################################## 100.0%Repackaging Java 7.0.141-zulu...Done repackaging...Installing: java 7.0.141-zuluDone installing!Do you want java 7.0.141-zulu to be set as default? (Y/n): n$ sdk default java 7.0.141-zuluDefault java version set to 7.0.141-zulu$ java -versionopenjdk version &quot;1.7.0_141&quot;OpenJDK Runtime Environment (Zulu 7.18.0.3-linux64) (build 1.7.0_141-b11)OpenJDK 64-Bit Server VM (Zulu 7.18.0.3-linux64) (build 24.141-b11, mixed mode) 注：zulu 的 JDK 是基于 OpenJDK 的一个改进版本，是另一个 JVM 的实现。 版本顺利改变。 这样 Sdkman 就完成了 JDK 的切换，类似的 Maven，Groovy 等都可以这样实现。","link":"/2018/10/31/zh/programing/java/sdkman_manage_jdk_version/"},{"title":"单例模式的八种写法","text":"简介单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。 许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 优点系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 缺点当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。 适用场合 需要频繁的进行创建和销毁的对象 创建对象时耗时过多或耗费资源过多，但又经常用到的对象 工具类对象 频繁访问数据库或文件的对象 实现思路单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用 getInstance 命名）。 单例的实现主要是通过以下两个步骤： 将该类的构造方法定义为私有方法，让调用方无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例； 在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 注意事项单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁（虽然这样会降低效率）。 饿汉式[可用]静态常量 12345678910public class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton() { } public static Singleton getInstance() { return INSTANCE; }} 优点：写法简单，在类装载的时候就完成实例化。避免了线程同步问题。 缺点：在类装载的时候就完成实例化，没有达到懒加载的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 静态代码块 1234567891011121314public class Singleton { private static Singleton instance; static { instance = new Singleton(); } private Singleton() { } public Singleton getInstance() { return instance; }} 和上面的方式类似，只不过将类实例化的过程放在了静态代码块中。优缺点也和上面一样。 懒汉式（线程不安全）[不可用]12345678910111213public class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; }} 优点：有懒加载效果。 缺点：线程不安全。在多线程下，一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 懒汉式（线程安全，同步方法）[不推荐]12345678910111213public class Singleton { private static Singleton singleton; private Singleton() { } public static synchronized Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; }} synchronized 解决上面的线程不安全问题，但同步效率低，每个线程在想获得类的实例时候，执行 getInstance() 方法都要进行同步，而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。 懒汉式(线程安全，同步代码块)[不可用]123456789101112131415public class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { singleton = new Singleton(); } } return singleton; }} 由于上面的方法同步效率低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种线程不安全的实现方式遇到的情形一致：假如一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，虽然只能让一个线程进入 singleton = new Singleton() 而另外的其他线程等待进入，但在创建对象离开后，同时间进来的另一个线程进来后也会再次创建，也就相当于没有同步。 双重检查[推荐用]1234567891011121314151617public class Singleton { private static volatile Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; }} Double-Check 概念对于多线程开发者来说不会陌生，如代码中所示，进行两次 if (singleton == null) 检查，这样就可以保证线程安全了。实例化代码只执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象。 优点：线程安全、懒加载、效率较高。 静态内部类[推荐用]123456789101112public class Singleton { private Singleton() { } private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; }} 与饿汉式方式采用的机制类似：两者都是采用了类装载的机制来保证初始化实例时只有一个线程。 不同处：饿汉式方式是只要 Singleton 类被装载就会实例化，没有懒加载的效果；静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。类的静态属性只会在第一次加载类的时候初始化，在这里 JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：线程安全、懒加载、效率高。 枚举[推荐用]12345public enum Singleton { INSTANCE; public void whateverMethod() { }} 借助 JDK 1.5 后添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。","link":"/2018/03/19/zh/programing/java/singleton_pattern/"},{"title":"写作","text":"","link":"/2022/10/28/zh/english/ielts/writing/writing/"},{"title":"广度搜索和深度搜索","text":"前言搜索界两大基础搜索算法分别是广度优先搜索和深度优先搜索。 搜索算法可以用于寻找图的连通性。 广度优先搜索一个普通的二维地图，从 A 点到 B 点，有两个问题。 能否到达？ 怎样以最短的路径走到B点？ 这是搜索算法能够解决的事情。 要使用广度优先搜索算法来搜索从 A 点到 B 点的最短路径 依据广度优先的原则，每走一步，都将下一步所有可能的选择入队之后，才进行下一步。 结束标记： 队列为空时，搜索结束 搜索到指定结果时，搜索结束 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* * A * B C * D G E * F * 搜索从A到F的最少步数，广度优先搜索： * 第一步： * A入队，步数是0 * A为队头 * 第二步： * 查看A下一步的所有选择 * 有B和C，所以第二步可以到达B和C，步数是1 * B、C入队，同时标记B和C，表示已经走过了。 * A已经没用了，因为A所有可能到达的点已经在队列里了，所以A出队。 * 判断是否达到目标地点： * 是，结束循环。当前步数是最短步数 * 否，继续 * 此时队头为B * 第三步： * B、C是同时入队的，所以两个都要在第三步里扩展所有可能。 * * 1. 查看B下一步的所有选择 * 有D、G * D、G入队，标记D、G * B也没用了，B出队 * 判断是否达到目标地点： * 是，结束循环。当前步数是最短步数 * 否，继续 * 此时队头为C * 2. 查看C下一步的所有选择 * 有G、E，但是G已经标记走过了 * 所以只有E可选 * E入队，同时标记E * C已无效，C出队 * 此时队头为D * 合并B、C扩展出来的所有选择，有D、G、E * 所以第三步可以达到的是D、G、E，步数是2 * 判断是否达到目标地点： * 是，结束循环。当前步数是最短步数 * 否，继续 * 第四步： * 搜索D、G、E所有的的扩展可能 * * 1. 查看D下一步的所有选择 * 有F，F入队，此时步数是3 * D出队 * 判断是否达到目标地点： * 发现F是目标，结束遍历。 * * A到达F的最小步数是3 */class Main { static int maxLine = 6, maxRow = 5; static int[][] map = new int[maxLine][maxRow]; static int[][] mark = new int[maxLine][maxRow]; static int targetLine = 4, targetRow = 3; static int totalStep = -1; static int[][] nextDirection = { { 0, -1 }, { 1, 0 }, { 0, 1 }, { -1, 0 } }; public static void main(String[] args) { map[1][3] = 1; map[3][3] = 1; map[4][2] = 1; map[5][4] = 1; bfs(1, 1); System.out.print(totalStep == -1 ? &quot;\\n没有到达&quot; : &quot;\\n到达&quot;); System.out.println(&quot;目标位置: &quot; + targetLine + &quot;行&quot; + targetRow + &quot;列，总步数：&quot; + totalStep); } public static void bfs(int startLine, int startRow) { mark[startLine][startRow] = 1; Node[] queue = new Node[maxLine * maxRow]; int head = 0, tail = 0; queue[tail] = new Node(startLine, startRow, 0, head); tail++; int nextLine, nextRow; // 队列不为空，即队头下标还没与队尾下标相遇 while (head &lt; tail) { // 4个方向 for (int i = 0; i &lt; 4; i++) { nextLine = queue[head].getLine() + nextDirection[i][0]; nextRow = queue[head].getRow() + nextDirection[i][1]; // 如果下一个位置不符合迷宫位置 if (nextLine &gt;= maxLine || nextRow &gt;= maxRow || nextLine &lt; 1 || nextRow &lt; 1) { continue; } // 没有走过并且不是障碍物 if (mark[nextLine][nextRow] != 1 &amp;&amp; map[nextLine][nextRow] != 1) { queue[tail] = new Node(nextRow, nextLine, queue[head].getStep() + 1, head); tail++; mark[nextLine][nextRow] = 1; } // 是否到达目标位置 if (nextLine == targetLine &amp;&amp; nextRow == targetRow) { int index = tail - 1; // 到达目标位置的总步数 totalStep = queue[index].getStep(); // 经过的路径 for (int j = 0; j &lt;= totalStep; j++) { System.out.println(&quot;(&quot; + queue[index].getLine() + &quot;,&quot; + queue[index].getRow() + &quot;)&quot;); index = queue[index].getNodeIndex(); } return; } } // 队头出队 head++; } // 如果没走出 totalStep = -1; } private static class Node { // 节点下标 int nodeIndex; // 走到某节点时的行、列以及走过的步数 int row, line, step; Node(int line, int row) { this.line = line; this.row = row; } Node(int row, int line, int step, int nodeIndex) { this.row = row; this.line = line; this.step = step; this.nodeIndex = nodeIndex; } public int getNodeIndex() { return nodeIndex; } public int getRow() { return row; } public int getLine() { return line; } public int getStep() { return step; } }} 深度优先搜索","link":"/2018/03/09/zh/programing/basis/algorithm/bfs_dfs/"},{"title":"Java 算法模版","text":"辗转相除法求最大公约数最小公倍数 = ab/最大公约数 递归123long gcd(long a, long b) { return a == 0 ? b : gcd(b % a, a);} 迭代12345678long gcd(long a, long b) { long tmp; while ((tmp = a % b) != 0) { a = b; b = tmp; } return b;} 斯特林公式求 n 阶乘后的位数 10.5 * log10(2 * n * PI) + n * log10(n / E) + 1 扩展欧几里德求乘法逆元 1234567891011long[] extendEuclid(long a, long b) { if (b == 0) { return new long[] { a, 1, 0 }; } else { long[] next = extendEuclid(b, a % b); long g = next[0]; long x = next[2]; long y = next[1] - next[2] * (a / b); return new long[] { g, x, y }; }} 中国剩余定理/孙子定理12345678910111213141516long CRT(long p[], long m[], long n) { long M = 1; long result = 0; for (int i = 0; i &lt; n; i++) { M *= m[i]; } for (int i = 0; i &lt; n; i++) { long Mi = M / m[i]; long x = extendEuclid(Mi, m[i])[1]; result = (result + Mi * x * p[i]) % M; } if (result &lt; 0) { result += M; } return result;} 快速幂12345678910long quickPowerMod(long x, long n, long mod) { long result = 1; while (n &gt; 0) { if ((n &amp; 1) != 0) result = result * x % mod; x = x * x % mod; n &gt;&gt;= 1; } return result;} 全排列12345678910111213141516171819202122232425/** * char[] a = { 'a', 'b', 'c' }; * permutate(a, 0); */void permutate(char[] A, int n) { if (n == A.length) { System.out.println(new String(A)); } else { for (int i = n; i &lt; A.length; i++) { if (isUnique(A, n, i)) { swap(A, n, i); permutate(A, n + 1); swap(A, n, i); } } }}// 如果有重复字符，要去重boolean isUnique(char[] A, int start, int end) { for (int i = start; i &lt; end; i++) if (A[i] == A[end]) return false; return true;} 最长公共子序列两个字符串中的最长公共子序列，不要求子序列连续 123456789101112131415161718192021222324252627282930313233void LCS(String s1, String s2) { int s1Length = s1.length(), s2Length = s2.length(); int[][] dp = new int[s1Length + 1][s2Length + 1]; for (int i = 1; i &lt;= s1Length; i++) { for (int j = 1; j &lt;= s2Length; j++) { if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } StringBuilder sb = new StringBuilder(); // 利用上面得到的矩阵计算子序列，从最右下角往左上走 for (int i = s1Length, j = s2Length; i &gt; 0 &amp;&amp; j &gt; 0;) { // 相同时即为相同的子串 if (s1.charAt(i - 1) == s2.charAt(j - 1)) { sb.append(s1.charAt(i - 1)); i--; j--; } else { if (dp[i - 1][j] &gt; dp[i][j - 1]) { i--; } else { j--; } } } System.out.println(sb.reverse().toString()); System.out.println(&quot;length: &quot; + dp[s1Length][s2Length]);} 最长公共子串两个字符串中的最长公共子串，要求子串一定连续 12345678910111213141516171819int Longest(String s1, String s2) { int s1Length = s1.length(), s2Length = s2.length(); int[][] dp = new int[s1Length][s2Length]; int longest = 0; for (int i = 0; i &lt; s1Length; i++) { for (int j = 0; j &lt; s2Length; j++) { if (s1.charAt(i) == s2.charAt(j)) { if (i == 0 || j == 0) { dp[i][j] = 1; } else { dp[i][j] = dp[i - 1][j - 1] + 1; } longest = Math.max(longest, dp[i][j]); } } } return longest;} Manacher求最长回文子串长度 123456789101112131415161718192021222324252627282930313233343536373839404142int Manacher(String str) { // 构造新的字符串 // 为了避免奇数回文和偶数回文的不同处理问题，在原字符串中插入'#'，将所有回文变成奇数回文 StringBuilder newStr = new StringBuilder(); newStr.append('#'); for (int i = 0; i &lt; str.length(); i++) { newStr.append(str.charAt(i)); newStr.append('#'); } // rad[i]表示以i为中心的回文的最大半径，i至少为1，即该字符本身 int[] rad = new int[newStr.length()]; // right表示已知的回文中，最右的边界的坐标 int right = -1; // id表示已知的回文中，拥有最右边界的回文的中点坐标 int id = -1; // 计算所有的rad // 这个算法是O(n)的，因为right只会随着里层while的迭代而增长，不会减少。 for (int i = 0; i &lt; newStr.length(); i++) { // 确定一个最小的半径 int r = 1; if (i &lt;= right) { r = Math.min(rad[id] - i + id, rad[2 * id - i]); } // 尝试更大的半径 while (i - r &gt;= 0 &amp;&amp; i + r &lt; newStr.length() &amp;&amp; newStr.charAt(i - r) == newStr.charAt(i + r)) { r++; } // 更新边界和回文中心坐标 if (i + r - 1 &gt; right) { right = i + r - 1; id = i; } rad[i] = r; } // 扫描一遍rad数组，找出最大的半径 int maxLength = 0; for (int r : rad) { maxLength = Math.max(r, maxLength); } return maxLength - 1;} 埃拉托斯特尼筛法12345678910111213141516171819202122ArrayList&lt;Integer&gt; getPrime(int n) { boolean[] notPrime = new boolean[n + 1]; int sqrtN = (int) Math.sqrt(n); for (int i = 2; i &lt;= sqrtN; i++) { if (notPrime[i]) continue; for (int j = i * i; j &lt;= n; j += i) { // j是i的倍数，即不是素数 notPrime[j] = true; } } ArrayList&lt;Integer&gt; prime = new ArrayList&lt;&gt;(); if (n &gt; 1) prime.add(2); for (int i = 3; i &lt;= n; i += 2) { if (notPrime[i]) continue; prime.add(i); } return prime;} KMP匹配字符串 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) { String a = &quot;ababa&quot;; String b = &quot;ssdfgasdbababa&quot;; int[] next = KMPNext(a); int res = KMP(b, a, next); System.out.println(res); //9}static int KMP(String source, String dest, int[] next) { for (int i = 0, j = 0; i &lt; source.length(); i++) { while (j &gt; 0 &amp;&amp; source.charAt(i) != dest.charAt(j)) { j = next[j - 1]; } if (source.charAt(i) == dest.charAt(j)) { j++; } if (j == dest.length()) { return i - j + 1; } } return 0;}static int[] KMPNext(String dest) { int[] next = new int[dest.length()]; for (int i = 1, j = 0; i &lt; dest.length(); i++) { while (j &gt; 0 &amp;&amp; dest.charAt(j) != dest.charAt(i)) { j = next[j - 1]; } if (dest.charAt(i) == dest.charAt(j)) { j++; } next[i] = j; } return next;} 判断线段相交12345678910111213double crossProduct(Point a, Point b, Point c) { return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);}boolean isIntersects(Point a, Point b, Point c, Point d) { // 判断叉积是否异号 // 为正顺时针方向，为负则逆时针方向 // 即判断c、d两点是否在ab线段的两侧 // 再判断a、b两点是否在cd线段的两侧 // 都成立才正确 return crossProduct(a, b, c) * crossProduct(a, b, d) &lt;= 0 &amp;&amp; crossProduct(c, d, a) * crossProduct(c, d, b) &lt;= 0;} 01背包12345678910111213int capacity = 12;int items = 5;int[] weight = new int[] { 2, 2, 6, 5, 4 };int[] value = new int[] { 6, 3, 5, 4, 6 };int[] dp = new int[capacity + 1];void bagOneZero() { for (int i = 0; i &lt; items; i++) { for (int j = capacity; j &gt;= weight[i]; j--) { // 逆序 dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } }} 完全背包12345678910void bagComplete() { for (int i = 0; i &lt; items; i++) { for (int j = weight[i]; j &lt;= capacity; j++) { // 顺序 dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } }}// 初始化分两种情况：// 1. 背包要求正好装满：dp[0] = 0, dp[1~w] = Integer.MIN_VALUE; // 2. 不需要正好装满：dp[0~v] = 0; 多重背包12345678910111213141516int capacity = 12;int items = 5;int[] weight = new int[] { 2, 2, 6, 5, 4 };int[] value = new int[] { 6, 3, 5, 4, 6 };int[] num = new int[] { 2, 3, 1, 4, 2 };int[] dp = new int[capacity + 1];void bagMultiple() { for (int i = 0; i &lt; items; i++) { for (int k = 0; k &lt; num[i]; k++) { // 比01背包多一个数量限制 for (int j = capacity; j &gt;= weight[i]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } } }} 快排123456789101112131415161718192021222324int partition(int[] A, int low, int high) { int i = low; int j = high + 1; int pivot = A[low]; // 基准 while (true) { // 左边的比基准值小 while (i &lt; high &amp;&amp; A[++i] &lt; pivot); // 右边的比基准值大 while (A[--j] &gt; pivot); if (i &gt;= j) break; swap(A, i, j); } // 基准值交换到 i j 相遇的位置 swap(A, low, j); return j;}void quicksort(int[] A, int low, int high) { if (low &lt; high) { int mid = partition(A, low, high); quicksort(A, low, mid - 1); quicksort(A, mid + 1, high); }} 矩阵乘法12345678910111213141516class Matrix { int[][] matrix; Matrix(int n) { matrix = new int[n][n]; }}Matrix mul(Matrix a, Matrix b) { Matrix c = new Matrix(n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++) c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j]; return c;} 三角形外心12345678910Point circumcenter(Point a, Point b, Point c) { // 返回三角形的外心 double a1 = b.x - a.x; double b1 = b.y - a.y; double c1 = (a1 * a1 + b1 * b1) / 2; double a2 = c.x - a.x; double b2 = c.y - a.y; double c2 = (a2 * a2 + b2 * b2) / 2; double d = a1 * b2 - a2 * b1; return new Point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);} 多边形面积123double Cross(Point a, Point b) { return a.x * b.y - a.y * b.x;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387/*Kruskal算法适用于 稀疏图 求最小生成树*//* 第一步：点、边、加入vector，把所有边按从小到大排序 第二步：并查集部分 + 下面的code*/void Kruskal() { ans = 0; for (int i = 0; i&lt;len; i++) { if (Find(edge[i].a) != Find(edge[i].b)) { Union(edge[i].a, edge[i].b); ans += edge[i].len; } } } /*Prim算法适用于 稠密图 求最小生成树堆优化版，时间复杂度：O(elgn)*/struct node { int v, len; node(int v = 0, int len = 0) :v(v), len(len) {} bool operator &lt; (const node &amp;a)const { // 加入队列的元素自动按距离从小到大排序 return len&gt; a.len; } };vector&lt;node&gt; G[maxn];int vis[maxn];int dis[maxn];void init() { for (int i = 0; i&lt;maxn; i++) { G[i].clear(); dis[i] = INF; vis[i] = false; } } int Prim(int s) { priority_queue&lt;node&gt;Q; // 定义优先队列 int ans = 0; Q.push(node(s,0)); // 起点加入队列 while (!Q.empty()) { node now = Q.top(); Q.pop(); // 取出距离最小的点 int v = now.v; if (vis[v]) continue; // 同一个节点，可能会推入2次或2次以上队列，这样第一个被标记后，剩下的需要直接跳过。 vis[v] = true; // 标记一下 ans += now.len; for (int i = 0; i&lt;G[v].size(); i++) { // 开始更新 int v2 = G[v][i].v; int len = G[v][i].len; if (!vis[v2] &amp;&amp; dis[v2] &gt; len) { dis[v2] = len; Q.push(node(v2, dis[v2])); // 更新的点加入队列并排序 } } } return ans;} /* Dijkstra算法 适用于边权为正的有向图或者无向图 求从单个源点出发，到所有节点的最短路 优化版：时间复杂度 O(elbn)*/struct node { int v, len; node(int v = 0, int len = 0) :v(v), len(len) {} bool operator &lt; (const node &amp;a)const { // 距离从小到大排序 return len &gt; a.len; } }; vector&lt;node&gt;G[maxn]; bool vis[maxn]; int dis[maxn];void init() { for (int i = 0; i&lt;maxn; i++) { G[i].clear(); vis[i] = false; dis[i] = INF; } } int dijkstra(int s, int e) { priority_queue&lt;node&gt;Q; Q.push(node(s, 0)); // 加入队列并排序 dis[s] = 0; while (!Q.empty()) { node now = Q.top(); // 取出当前最小的 Q.pop(); int v = now.v; if (vis[v]) continue; // 如果标记过了, 直接continue vis[v] = true; for (int i = 0; i&lt;G[v].size(); i++) { // 更新 int v2 = G[v][i].v; int len = G[v][i].len; if (!vis[v2] &amp;&amp; dis[v2] &gt; dis[v] + len) { dis[v2] = dis[v] + len; Q.push(node(v2, dis[v2])); } } } return dis[e]; } /* SPFA算法 队列优化 可处理负环*/vector&lt;node&gt; G[maxn];bool inqueue[maxn];int dist[maxn];void Init() { for(int i = 0 ; i &lt; maxn ; ++i){ G[i].clear(); dist[i] = INF; } }int SPFA(int s,int e) { int v1,v2,weight; queue&lt;int&gt; Q; memset(inqueue,false,sizeof(inqueue)); // 标记是否在队列中 memset(cnt,0,sizeof(cnt)); // 加入队列的次数 dist[s] = 0; Q.push(s); // 起点加入队列 inqueue[s] = true; // 标记 while(!Q.empty()){ v1 = Q.front(); Q.pop(); inqueue[v1] = false; // 取消标记 for(int i = 0 ; i &lt; G[v1].size() ; ++i){ // 搜索v1的链表 v2 = G[v1][i].vex; weight = G[v1][i].weight; if(dist[v2] &gt; dist[v1] + weight){ // 松弛操作 dist[v2] = dist[v1] + weight; if(inqueue[v2] == false){ // 再次加入队列 inqueue[v2] = true; //cnt[v2]++; // 判负环 //if(cnt[v2] &gt; n) return -1; Q.push(v2); } } } } return dist[e]; }/* 不断的将s的邻接点加入队列，取出不断的进行松弛操作，直到队列为空 如果一个结点被加入队列超过n-1次，那么显然图中有负环 *//* Floyd算法 任意点对最短路算法 求图中任意两点的最短距离的算法*/for (int i = 0; i &lt; n; i++) { // 初始化为0 for (int j = 0; j &lt; n; j++) scanf(&quot;%lf&quot;, &amp;dis[i][j]); } for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } }}/* |交叉染色法判断二分图| |16/11/05ztx|*/int bipartite(int s) { int u, v; queue&lt;int&gt;Q; color[s] = 1; Q.push(s); while (!Q.empty()) { u = Q.front(); Q.pop(); for (int i = 0; i &lt; G[u].size(); i++) { v = G[u][i]; if (color[v] == 0) { color[v] = -color[u]; Q.push(v); } else if (color[v] == color[u]) return 0; } } return 1; } /* |求解最大匹配问题| |递归实现| |16/11/05ztx|*/vector&lt;int&gt;G[maxn]; bool inpath[maxn]; // 标记 int match[maxn]; // 记录匹配对象 void init() { memset(match, -1, sizeof(match)); for (int i = 0; i &lt; maxn; ++i) { G[i].clear(); } } bool findpath(int k) { for (int i = 0; i &lt; G[k].size(); ++i) { int v = G[k][i]; if (!inpath[v]) { inpath[v] = true; if (match[v] == -1 || findpath(match[v])) { // 递归 match[v] = k; // 即匹配对象是“k妹子”的 return true; } } } return false; } void hungary() { int cnt = 0; for (int i = 1; i &lt;= m; i++) { // m为需要匹配的“妹子”数 memset(inpath, false, sizeof(inpath)); // 每次都要初始化 if (findpath(i)) cnt++; } cout &lt;&lt; cnt &lt;&lt; endl; } /* |求解最大匹配问题| |dfs实现| |16/11/05ztx|*/int v1, v2; bool Map[501][501]; bool visit[501]; int link[501]; int result; bool dfs(int x) { for (int y = 1; y &lt;= v2; ++y) { if (Map[x][y] &amp;&amp; !visit[y]) { visit[y] = true; if (link[y] == 0 || dfs(link[y])) { link[y] = x; return true; } } } return false; } void Search() { for (int x = 1; x &lt;= v1; x++) { memset(visit,false,sizeof(visit)); if (dfs(x)) result++; }}/* |最长上升子序列| |状态转移| |16/11/05ztx|*//* 状态转移dp[i] = max{ 1.dp[j] + 1 }; j&lt;i; a[j]&lt;a[i]; d[i]是以i结尾的最长上升子序列 与i之前的 每个a[j]&lt;a[i]的 j的位置的最长上升子序列+1后的值比较*/void solve(){ // 参考挑战程序设计入门经典; for(int i = 0; i &lt; n; ++i){ dp[i] = 1; for(int j = 0; j &lt; i; ++j){ if(a[j] &lt; a[i]){ dp[i] = max(dp[i], dp[j] + 1); } } }} /* 优化方法： dp[i]表示长度为i+1的上升子序列的最末尾元素 找到第一个比dp末尾大的来代替*/ void solve() { for (int i = 0; i &lt; n; ++i){ dp[i] = INF; } for (int i = 0; i &lt; n; ++i) { *lower_bound(dp, dp + n, a[i]) = a[i]; // 返回一个指针 } printf(&quot;%d\\n&quot;, *lower_bound(dp, dp + n, INF) - dp; }/* 函数lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value的值。*/AC自动机/* |16/11/06ztx|*/#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; #define N 1000010 char str[N], keyword[N]; int head, tail; struct node { node *fail; node *next[26]; int count; node() { //init fail = NULL;// 默认为空 count = 0; for(int i = 0; i &lt; 26; ++i) next[i] = NULL; } }*q[N]; node *root; void insert(char *str) { // 建立Trie int temp, len; node *p = root; len = strlen(str); for(int i = 0; i &lt; len; ++i) { temp = str[i] - 'a'; if(p-&gt;next[temp] == NULL) p-&gt;next[temp] = new node(); p = p-&gt;next[temp]; } p-&gt;count++; } void build_ac() { // 初始化fail指针，BFS 数组模拟队列： q[tail++] = root; while(head != tail) { node *p = q[head++]; // 弹出队头 node *temp = NULL; for(int i = 0; i &lt; 26; ++i) { if(p-&gt;next[i] != NULL) { if(p == root) { // 第一个元素fail必指向根 p-&gt;next[i]-&gt;fail = root; }else { temp = p-&gt;fail; // 失败指针 while(temp != NULL) { // 2种情况结束：匹配为空or找到匹配 if(temp-&gt;next[i] != NULL) { // 找到匹配 p-&gt;next[i]-&gt;fail = temp-&gt;next[i]; break; } temp = temp-&gt;fail; } if(temp == NULL) // 为空则从头匹配 p-&gt;next[i]-&gt;fail = root; } q[tail++] = p-&gt;next[i]; // 入队 } } } } int query() // 扫描 { int index, len, result; node *p = root; // Tire入口 result = 0; len = strlen(str); for(int i = 0; i &lt; len; ++i) { index = str[i] - 'a'; while(p-&gt;next[index] == NULL &amp;&amp; p != root) // 跳转失败指针 p = p-&gt;fail; p = p-&gt;next[index]; if(p == NULL) p = root; node *temp = p; // p不动，temp计算后缀串 while(temp != root &amp;&amp; temp-&gt;count != -1) { result += temp-&gt;count; temp-&gt;count = -1; temp = temp-&gt;fail; } } return result; } int main() { int num; head= tail = 0; root = new node(); scanf(&quot;%d&quot;, &amp;num); getchar(); for(int i = 0; i &lt; num; ++i) { scanf(&quot;%s&quot;,keyword); insert(keyword); } build_ac(); scanf(&quot;%s&quot;, str); if(query()) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); return 0; } /* 假设有N个模式串，平均长度为L；文章长度为M。 建立Trie树：O(N*L) 建立fail指针：O(N*L) 模式匹配：O(M*L) 所以，总时间复杂度为:O( (N+M)*L )。*/","link":"/2018/05/01/zh/programing/basis/algorithm/java_algorithm_template/"},{"title":"","text":"丑数丑数：只含因子 2、3、5 的数。4、6、8 是丑数；而 14 不是，因为其包含因子 7。习惯上把 1 当作第一个丑数。 ** 分析 ** 根据定义，一个丑数应该是另一个丑数乘以 2、3 或 5 的结果。4 是丑数 2 乘以 2 的结果；6 是丑数 2 乘以 3 的结果（或 3 乘以 2 ） 3个队列解决1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 1. 初始化 3 个队列 Q2、Q3、Q5，分别保存 2、3、5 的倍数 * 2. 初始化 x 为 1 * 3. 分别将 x * 2、 x * 3、x * 5 插入 3 个队列 * 4. 令 x 为 Q2 Q3 Q5 中队头最小值 * 5. 若 x 在： * Q2：出队，将 x * 2、x * 3、x * 5 分别放入 Q2、Q3、Q5 * Q3：出队，将 x * 3、x * 5 分别放入 Q3、Q5 * Q5：出队，将 x * 5 放入 Q5 * （不将倍数全部插入队列是为了避免重复， * 队列先进先出，总会保持从小到大的顺序） * 6. 重复 4 ~ 5，直到找到第 k 个元素 */import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;import java.lang.Math;public class UglyNumber { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int index = scanner.nextInt(); UglyNumber uglyNumber = new UglyNumber(); System.out.println(uglyNumber.GetUglyNumber_Solution(index)); scanner.close(); } public int GetUglyNumber_Solution(int index) { if (index &lt; 1) return 0; int minVal = 0; Queue&lt;Integer&gt; q2 = new LinkedList&lt;Integer&gt;(); Queue&lt;Integer&gt; q3 = new LinkedList&lt;Integer&gt;(); Queue&lt;Integer&gt; q5 = new LinkedList&lt;Integer&gt;(); q2.offer(1); for (int i = 0; i &lt; index; i++) { int val2 = q2.isEmpty() ? Integer.MAX_VALUE : q2.element(); int val3 = q3.isEmpty() ? Integer.MAX_VALUE : q3.element(); int val5 = q5.isEmpty() ? Integer.MAX_VALUE : q5.element(); minVal = Math.min(val2, Math.min(val3, val5)); if (minVal == val2) { q2.poll(); q2.offer(2 * minVal); q3.offer(3 * minVal); } else if (minVal == val3) { q3.poll(); q3.offer(3 * minVal); } else { q5.poll(); } q5.offer(5 * minVal); } return minVal; }} 左旋转字符串用字符串模拟循环左移如：字符序列”abcXYZdef”，要求输出循环左移3位后的结果，即”XYZdefabc” 直接使用内置函数12345678910111213141516171819202122import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); String string = scanner.next(); System.out.println(LeftRotateString(string, n)); scanner.close(); } public static String LeftRotateString(String str, int n) { if (str == null) { return &quot;&quot;; } n = n % str.length(); if (n == 0) { return str; } return str.substring(n) + str.substring(0, n); }} 限制使用某些关键字有些题目会要求不能使用某些运算符，或者其他，这时候就需要一些骚操作先把不能用的去掉，从能用的操作中找到能解决问题的 求1+2+3+…+n求1+2+3+…+n不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A ? B : C） ** 分析 ** 排除不能用的运算，现在可以使用（按优先级高低）单目运算符：++，–双目运算符：+，-移位运算符：&lt;&lt;，&gt;&gt;关系运算符：&gt;，&lt;等逻辑运算符：&amp;&amp;，||，&amp;，|，^赋值：= 单目和双目的作用一样，移位显然没有规律性，因为一个二进制位并不能区分某个数和其他数，这也就排除了&amp;,|,^,因为不需要做位运算了 关系运算符要和if匹配，但不能用if，这时剩下的运算符只能选&amp;&amp;，||，它们有短路特性。 （类似shell里的&amp;&amp;） 短路特性123456public int Sum_Solution(int n) { int sum = n; // 当n大于0，顺序执行后面的操作 boolean flag = (n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n - 1)) &gt; 0); return sum;} 不用加减乘除做加法求两个整数之和不得使用+、-、*、/四则运算符号 ** 分析 ** 位运算解决第1步：先忽略进位，异或两个数第2步：相与再左移：求两个数的进位第3步：重复上述两步，直到第2步的进位为0 ** 例子 ** 5+7=12第1步：相加各位的值，即异或操作：101^111，不算进位，得010第2步：相与再左移(101&amp;111)&lt;&lt;1，计算进位值，得1010第3步：重复上述两步，相加：010^1010 = 1000，进位：(010&amp;1010) &lt;&lt;1 = 100继续重复上述两步：1000^100 = 1100，进位：(1000&amp;100) &lt;&lt;1 = 0 跳出循环，1100为最终结果 123456789public int Add(int num1, int num2) { int tmp = 0; while (num2 != 0) { tmp = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = tmp; } return num1;} 翻转单词顺序如：”student. a am I”正确的句子应该是”I am a student.” 使用split12345678910111213141516171819202122232425import java.util.Scanner;public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); String string = scanner.nextLine(); System.out.println(ReverseSentence(string)); scanner.close(); } public static String ReverseSentence(String str) { if (str == null || str.trim().equals(&quot;&quot;)) { return str; } String[] strings = str.split(&quot; &quot;); StringBuilder stringBuilder = new StringBuilder(); for (int i = strings.length - 1; i &gt;= 0; i--) { stringBuilder.append(strings[i]); if (i != 0) { stringBuilder.append(&quot; &quot;); } } return stringBuilder.toString(); }} 不使用split1 斐波那契数列从第3项开始，每一项都等于前两项之和的数列。如：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144…… 递推公式：$f(n) = f(n-2) + f(n-1)$通项公式：$f = \\frac{ 1 }{ \\sqrt{ 5 } } \\times [(\\frac{ 1 + \\sqrt{ 5 } }{ 2 })^n - (\\frac{ 1 - \\sqrt{ 5 } }{ 2 })^n]$ 跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级，求该青蛙跳上一个n级的台阶总共有多少种跳法？ 分析 假设有n=4个台阶第1次若跳2级，则剩下2级台阶；若跳1级台阶，则剩下3级台阶若剩下2级，则有2种情况：11，2若剩下3级，则有3种情况，111，21，12 以上加起来即4级台阶有5种跳法，是斐波那契数列 递推公式1234567891011121314151617public int JumpFloor(int target) { if (target &lt;= 0) { return 0; } else if (target == 1) { return 1; } else if (target == 2) { return 2; } else { int f1 = 1, f2 = 2, fn = 0; for (int i = 3; i &lt;= target; i++) { fn = f1 + f2; f1 = f2; f2 = fn; } return fn; }} 矩形覆盖用 2x1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2x1 的小矩形无重叠地覆盖一个 2xn 的大矩形，总共有多少种方法？ 分析 手动画下矩形，从 2x1 开始： 2xn 大矩阵 k 种方法 2*1 1 2*2 2 2*3 3 2*4 5 2*5 8 每一个大矩形都包含小于它的大矩形的覆盖方法，是斐波那契数列。 01串知道某一01串的长度，求不含有”11”子串的这种长度的01串共有多少个？ 分析 当01串长度为1时，有2种：0，1当01串长度为2时，有3种：00，01，10当01串长度为3时，有5种：000，001，010，100，101当01串长度为4时，有8种：0000，0001，0010，0100，0101，1000，1001，1010 每个串都包含小于它的串的排列，是斐波那契数列 孩子们的游戏圆圈中最后剩下的数 让小朋友们围成一个大圈。 随机指定一个数m，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从下一个小朋友开始,继续0…m-1报数…. 这样下去….直到剩下最后一个小朋友,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) ** 分析 ** 约瑟夫环问题N个人围城一桌（首位相连），约定从1报数，报到数为k的人出局，然后下一位又从1开始报，以此类推。最后留下的人获胜。 （有很多类似问题，如猴子选代王等等，解法都一样） 递推公式$f[1] = 0$$f[i] = (f[i-1] + m) % i (i &gt; 1)$ 递归公式123456789101112131415161718192021import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(System.in); public static void main(String args[]) { int n = scanner.nextInt(); int m = scanner.nextInt(); System.out.println(LastRemaining_Solution(n, m)); } public static int LastRemaining_Solution(int n, int m) { if (n == 0) { return -1; } int last = 0; for (int i = 2; i &lt;= n; i++) { last = (last + m) % i; } return last; }} 数组中只出现一次的数字形式1一个整型数组里除了一个数字之外，其他的数字都出现了两次。找出这个只出现一次的数字 分析 将所有数字异或，最后结果就是这个只出现一次的数字。因为出现两次的数字异或后为0。 形式2一个整型数组里除了两个数字之外，其他的数字都出现了两次。找出这两个只出现一次的数字 分析 根据形式1，可以将该问题分成两个分别包含一个数字的子数组。 如：原数组： 1 2 1 2 3 5子数组1：2 2 3子数组2：1 1 5 以上面例子为例的步骤： 将所有数字异或，得出包含这两个只出现一次的数字的异或二进制值0110 以二进制从右向左第一个1所在的位为标准，分出子数组 原数组中2和3的第二位都是1，所以分到了一组；而1和5分到另一组 最后得到上述表格的子数组，按简版的方法异或即可 和为S的连续正数序列有多少种连续的正数序列的和为100(至少包括两个数)如：18 19 20 21 22 输出所有和为S的连续正数序列，序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 1. 前后各一个指针：front、reer * 2. 若序列和小于 S，reer 后移；否则 front 后移 * front -&gt; | …… | reer -&gt; | …… * x1 | …… | xn | …… * 终止条件：reer、front 相遇 */import java.util.Scanner;import java.util.ArrayList;import java.util.Iterator;public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); int sum = scanner.nextInt(); Main tmp = new Main(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = tmp.FindContinuousSequence(sum); Iterator&lt;ArrayList&lt;Integer&gt;&gt; iterator = lists.iterator(); for (; iterator.hasNext();) { System.out.println(iterator.next()); } scanner.close(); } public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) { ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Integer front = 1; Integer reer = 2; while (reer != front) { int s = (front + reer) * (reer - front + 1) / 2; if (s &gt; sum) { front += 1; } else if (s &lt; sum) { reer += 1; } else { ArrayList&lt;Integer&gt; iArrayList = new ArrayList&lt;&gt;(); for (Integer i = front; i &lt;= reer; i++) { iArrayList.add(i); } lists.add(iArrayList); front += 1; } } return lists; }} 二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示 循环去掉最右边的11234567891011121314/** * 有多少个1，就去掉多少个1 * 利用减1后的数和原数相与，循环去掉最右边的1 * &lt;p&gt; * 如：十进制的12，二进制为1100，12-1后变为1011，原来的1100和1011相与：1000，即去掉了最右边的1，循环直到数为0。 */public int NumberOf1(int n) { int nums = 0; while (n != 0) { n &amp;= n - 1; nums++; } return nums;} 循环左移123456789101112131415/** * 循环左移，&amp;2的次方判断（从2的0次方开始，即8 4 2 1） * 如：十进制11，二进制为1011，&amp;1判断第1位后，将1左移&lt;&lt;变为10，判断第2位，循环直到2的次方等于0。 * （int i左移溢出变回0，可以判断32次） */public int NumberOf1(int n) { int nums = 0; int i = 1; while (i != 0) { if ((n &amp; i) == i) nums++; i &lt;&lt;= 1; } return nums;} 逻辑右移123456789101112/** * Java的逻辑右移，可以忽略负数补1的情况 */public int NumberOf1(int n) { int nums = 0; while (n != 0) { if ((n &amp; 1) == 1) nums++; n &gt;&gt;&gt;= 1; } return nums;}","link":"/2018/01/01/zh/programing/basis/algorithm/sword_to_offer/"},{"title":"三个常见博弈游戏","text":"前言通过数论或者自然数性质完美解决的三个常见博弈游戏： 博弈 解决方法 Bash Game 同余理论 Nim Game 异或理论 Wythoff Game 黄金分割 Bash Game描述：一堆 n 个物品，两人轮流取，每次取 1 至 m 个，最后取完者胜。 以先手为例，分析： 面对 [1…m] 个局面，必胜。 面对 m + 1 个局面，必败。 如果可以使对手面临必败局面，那么必胜。 如果不能使对手面临必败局面，那么必败。 进一步：基础：1， 2，……， m 是必胜局面， m + 1是必败局面。递推：m + 2，m + 3，……，2m + 1 是必胜局面，2m + 2是必败局面。 k(m + 1) 是必败局面，应该允许 k = 0，因为 0 显然也是必败局面。在必败局和必胜局中，胜方的策略是：拿掉部分物品，使对方面临 k(m + 1) 的局面。 即：n % (m + 1) == 0 时，先手必败。 比如，有 10 个物品，每次只能取 1 到 5 个，则先手方必胜：先手方拿 4 个，对手无论拿多少个，先手方下次总能拿完。 从另一个角度思考该问题：如果物品数量随机，那么先手方胜利的概率是 m/(m + 1)，后手方胜利的概率是 1/(m + 1)。 Nim Game描述：m 堆 n 个物品，两人轮流取，每次取某堆中不少于 1 个，最后取完者胜。 分析： 所有物品数目二进制异或不为 0，则先手必胜。 所有物品数目二进制异或为 0，则后手必胜。 从另一个角度思考该问题：如果物品数量随机，那么每个数目的每一位上 1 或 0 概率相同： 如果有奇数个堆，那么 1 的个数为偶数或者奇数的概率相同， 如果有偶数个堆，那么 1 的个数为偶数的概率略大 1/(m + 1)，也就是说异或结果的每一位为 0 或 1 的概率几乎差不多，而先手必败要求异或结果每一位都为 0，其实败的概率很小。 Wythoff Game描述：2 堆（ak, bk）(ak &lt;= bk)物品，两人轮流取，每次从 1 堆中取 k 个或者从 2 堆中同时取 k 个，最后面对 (0, 0) 局面的败（设ak &lt;= bk是为了忽略顺序的影响）。 以先手为例，分析： 面对 (0,0) 局面必败。 面对 (1,1)(2,2)…(n,n)、(0,1)(0,2)…(0,n) 局面必胜。 如果可以使对手面临必败局面，那么必胜。 如果不能使对手面临必败局面，那么必败。 进一步：基础：(0,0) 是必败局面；(0,1)(0,2)…(0,n) 是必胜局面。递推： 123456789101112(1,2) 是必败局面； (1,1) (1,3)(1,4)...(1,n) (2,2)(2,3)...(2,n) 是必胜局面，(3,5) 是必败局面； (3,3)(3,4) (3,6)(3,7)...(3,n) (5,5)(5,6)...(5,n) 是必胜局面，(4,7) 是必败局面； (4,4)(4,5)(4,6) (4,8)(4,8)(4,9)...(4,n) (7,7)(7,8)(7,9)...(7,n) 是必胜局面，(6,10) 是必败局面； (6,6)(6,7)(6,8)(6,9) (6,11)(6,12)(6,13)...(6,n) (10,10)(10,11)(10,12)...(10,n) 是必胜局面。 规律：（必败局面的规律比较容易找到）ak 是前面必败局未出现的数中最小者，bk = ak + k (k = 0,1,2,3,…n) 必败局（奇异局）的重要性质：1,2,…,n 中每一个自然数，出现且只出现在一个奇异局中。 推导： 由于 ak 总是选择未出现的数，所以每个数总能出现在奇异局中且 ak 不会选择到重复的数。 bk = ak + k，所以 bk 总是比前面所有奇异局出现的数都大，所以 bk 不会选择到重复的数。 必胜方的策略是：始终让对手面对必败局（奇异局）。 给定任意局势 (a,b)，判定 (a,b) 是否为必败局的方法：k = 0,1…n，黄金比例 φ = 1.618033，ak = [φ * k]，bk = ak + k = [φ^2 * k]。比如：k = 0，ak = 0，bk = 0k = 1，ak = 1，bk = 2k = 2，ak = 3，bk = 5k = 3，ak = 4，bk = 7 更好的一种判断策略：k = bk - ak，当 ak == [φ * k] 时，为奇异局。 从胜负概率角度，如果堆中数量随机，先手一方优势很大。 组合游戏 - SG 函数和 SG 定理必胜点与必败点必胜点和必败点的概念：P 点（Previous player）：必败点，换而言之，就是谁处于此位置，则在双方操作正确的情况下必败。N 点（Next player）：必胜点，处于此情况下，双方操作均正确的情况下必胜。 必胜点和必败点的性质： 所有终结点是必败点 P。 从任何必胜点 N 操作，至少有一种方式可以进入必败点 P。 无论如何操作，必败点 P 都只能进入必胜点 N。 通常我们分析必胜点和必败点都是以终结点进行逆序分析。 例子HDU 1847 Good Luck in CET-4 Everybody! 打牌的规则： 总共 n 张牌; 双方轮流抓牌； 每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）； 抓完牌，胜负结果也出来了：最后抓完牌的人为胜者。 假设 Kiki 和 Cici 都足够聪明，并且每次都是Kiki先抓牌，请问谁能赢呢？ 分析：当 n = 0 时，显然为必败点，因为此时你已经无法进行操作了。当 n = 1 时，因为你一次就可以拿完所有牌，故此时为必胜点。当 n = 2 时，也是一次就可以拿完，故此时为必胜点。当 n = 3 时，要么剩 1 张要么剩 2 张，无论怎么取对方都将面对必胜点，故这一点为必败点。 以此类推： 120 1 2 3 4 5 6 ...P N N P N N P ... 你发现了什么没有，对，他们就是成有规律，使用了 P/N 来分析，有没有觉得问题变简单了。 SG 函数和 SG 定理组合游戏的和通常是很复杂的，但是有一种新工具，可以使组合问题变得简单 ———— SG 函数和 SG 定理。 Sprague-Grundy 定理： 游戏和的 SG 函数等于各个游戏 SG 函数的 Nim 和。这样就可以将每一个子游戏分而治之，从而简化了问题。而 Bouton 定理就是 Sprague-Grundy 定理在 Nim 游戏中的直接应用，因为单堆的 Nim 游戏 SG 函数满足 SG(x) = x。 Sprague-Grundy 函数： 首先定义 mex(minimal excludant) 运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。比如，mex{0, 1, 2, 4} = 3、mex{2, 3, 5} = 0、mex{} = 0。 对于任意状态 i，定义 SG(x) = mex(S)，其中 S 是 i 后继状态的 SG 函数值的集合。如 i 有三个后继状态分别为 SG(a)、SG(b)、SG(c)，那么 SG(i) = mex{SG(a), SG(b), SG(c)}。这样集合 S 的终态必然是空集，所以 SG 函数的终态为 SG(i) = 0，当且仅当 i 为必败点 P 时。 取石子问题有 1 堆 n 个的石子，每次只能取{1, 3, 4}个石子，先取完石子者胜利，那么各个数的 SG 值为多少？ SG[0] = 0，f[] = {1, 3, 4} i = 1，可以取走 1 - f{1} 个石子，剩余 {0} 个，SG[1] = mex{SG[0]} = mex{0} = 1;i = 2，可以取走 2 - f{1} 个石子，剩余 {1} 个，SG[2] = mex{SG[1]} = mex{1} = 0;i = 3，可以取走 3 - f{1, 3} 个石子，剩余 {2, 0} 个，SG[3] = mex{SG[2], SG[0]} = mex{0, 0} =1;i = 4，可以取走 4 - f{1, 3, 4} 个石子，剩余 {3, 1, 0} 个，SG[4] = mex{SG[3], SG[1], SG[0]} = mex{1, 1, 0} = 2;i = 5，可以取走 5 - f{1, 3, 4} 个石子，剩余 {4, 2, 1} 个，SG[5] = mex{SG[4], SG[2], SG[1]} = mex{2, 0, 1} = 3; 以此类推….. 12i 0 1 2 3 4 5 6 7 8....SG[i] 0 1 0 1 2 3 2 0 1.... 由上例我们就可以得到 SG 函数值求解步骤： 使用数组 f 将可改变当前状态的方式记录下来。 使用另一个数组将当前状态 i 的后继状态标记。 最后模拟 mex 运算，在标记值中搜索未被标记值的最小值，将其赋值给 SG(i)。 不断重复 23 步，知道计算完 1n 的函数值。 模版12345678910111213141516171819202122232425262728293031// 可改变当前状态的方式，N为方式的种类int[] f = new int[N];// 当前状态 i 的后继状态的集合boolean[] isVisit = new boolean[MAXN];// 0~n的SG函数值int[] SG = new int[MAXN];void getSG(int n) { // 因为SG[0]始终等于0，所以i从1开始 for (int i = 1; i &lt; n; i++) { // 每一次都要将上一状态的后继集合重置 Arrays.fill(isVisit, false); for (int j = 0; j &lt; N &amp;&amp; f[j] &lt;= i; j++) { // 将后继状态的SG函数值进行标记 isVisit[SG[i - f[j]]] = true; } for (int j = 0;; j++) { // 查询当前后继状态SG值中最小的非零值 if (!isVisit[j]) { SG[i] = j; break; } } }} 实战HDU 1848 Fibonacci again and again 任何一个大学生对菲波那契数列(Fibonacci numbers)应该都不会陌生，它是这样定义的：F(1)=1;F(2)=2;F(n)=F(n-1)+F(n-2)(n&gt;=3);所以，1,2,3,5,8,13……就是菲波那契数列。 在HDOJ上有不少相关的题目，比如1005 Fibonacci again就是曾经的浙江省赛题。 今天，又一个关于Fibonacci的题目出现了，它是一个小游戏，定义如下：1、这是一个二人游戏;2、一共有3堆石子，数量分别是m, n, p个；3、两人轮流走;4、可以选择任意一堆石子，然后取走f个；5、f只能是菲波那契数列中的元素（即每次只能取1，2，3，5，8…等数量）；6、最先取光所有石子的人为胜者； 假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。 Input输入数据包含多个测试用例，每个测试用例占一行，包含3个整数m,n,p（1&lt;=m,n,p&lt;=1000）。m=n=p=0则表示输入结束。 Output如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。 Sample Input1 1 11 4 10 0 0 Sample OutputFiboNacci 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;import java.util.Arrays;public class Main { static int MAXN = 1001; static int N = 16; static int[] f = new int[N]; static boolean[] isVisit = new boolean[MAXN]; static int[] SG = new int[MAXN]; public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); getFibonacci(); getSG(MAXN); int m, n, p; while (true) { in.nextToken(); m = (int) in.nval; in.nextToken(); n = (int) in.nval; in.nextToken(); p = (int) in.nval; if (m == 0 &amp;&amp; n == 0 &amp;&amp; p == 0) { break; } out.println((SG[n] ^ SG[m] ^ SG[p]) != 0 ? &quot;Fibo&quot; : &quot;Nacci&quot;); } out.flush(); } static void getFibonacci() { f[0] = f[1] = 1; for (int i = 2; i &lt; N; i++) { f[i] = f[i - 1] + f[i - 2]; } } static void getSG(int n) { for (int i = 1; i &lt; n; i++) { Arrays.fill(isVisit, false); for (int j = 0; j &lt; N &amp;&amp; f[j] &lt;= i; j++) { isVisit[SG[i - f[j]]] = true; } for (int j = 0;; j++) { if (!isVisit[j]) { SG[i] = j; break; } } } }}","link":"/2018/03/21/zh/programing/basis/algorithm/three_common_gaming_games/"},{"title":"十大经典排序算法","text":"简介原作者博客 0、排序算法说明0.1 排序的定义 对一序列对象根据某个关键字进行排序。 0.2 术语说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 0.3 算法总结 图片名词解释： n: 数据规模 k: “桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存 0.5 算法分类 0.6 比较和非比较的区别 常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。 计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 1、冒泡排序（Bubble Sort） 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现复制代码 1 /** 2 * 冒泡排序 3 * 4 * @param array 5 * @return 6 */ 7 public static int[] bubbleSort(int[] array) { 8 if (array.length == 0) 9 return array;10 for (int i = 0; i &lt; array.length; i++)11 for (int j = 0; j &lt; array.length - 1 - i; j++)12 if (array[j + 1] &lt; array[j]) {13 int temp = array[j + 1];14 array[j + 1] = array[j];15 array[j] = temp;16 }17 return array;18 } 复制代码 1.4 算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)2、选择排序（Selection Sort） 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。2.1 算法描述 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现复制代码 /** * 选择排序 * @param array * @return */ public static int[] selectionSort(int[] array) { if (array.length == 0) return array; for (int i = 0; i &lt; array.length; i++) { int minIndex = i; for (int j = i; j &lt; array.length; j++) { if (array[j] &lt; array[minIndex]) //找到最小的数 minIndex = j; //将最小数的索引保存 } int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; } return array; } 复制代码 2.4 算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)3、插入排序（Insertion Sort） 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。3.1 算法描述 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.2 代码实现复制代码 /** * 插入排序 * @param array * @return */ public static int[] insertionSort(int[] array) { if (array.length == 0) return array; int current; for (int i = 0; i &lt; array.length - 1; i++) { current = array[i + 1]; int preIndex = i; while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) { array[preIndex + 1] = array[preIndex]; preIndex–; } array[preIndex + 1] = current; } return array; } 复制代码 3.4 算法分析 最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2)4、希尔排序（Shell Sort） 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。4.1 算法描述 我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 过程演示 4.3 代码实现复制代码 /** * 希尔排序 * * @param array * @return */ public static int[] ShellSort(int[] array) { int len = array.length; int temp, gap = len / 2; while (gap &gt; 0) { for (int i = gap; i &lt; len; i++) { temp = array[i]; int preIndex = i - gap; while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) { array[preIndex + gap] = array[preIndex]; preIndex -= gap; } array[preIndex + gap] = temp; } gap /= 2; } return array; } 复制代码 4.4 算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog2n) 5、归并排序（Merge Sort） 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现复制代码 /** * 归并排序 * * @param array * @return */ public static int[] MergeSort(int[] array) { if (array.length &lt; 2) return array; int mid = array.length / 2; int[] left = Arrays.copyOfRange(array, 0, mid); int[] right = Arrays.copyOfRange(array, mid, array.length); return merge(MergeSort(left), MergeSort(right)); } /** * 归并排序——将两段排序好的数组结合成一个排序数组 * * @param left * @param right * @return */ public static int[] merge(int[] left, int[] right) { int[] result = new int[left.length + right.length]; for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) { if (i &gt;= left.length) result[index] = right[j++]; else if (j &gt;= right.length) result[index] = left[i++]; else if (left[i] &gt; right[j]) result[index] = right[j++]; else result[index] = left[i++]; } return result; } 复制代码 4 算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)6、快速排序（Quick Sort） 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。6.1 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 5.2 动图演示 5.3 代码实现复制代码 /** * 快速排序方法 * @param array * @param start * @param end * @return */ public static int[] QuickSort(int[] array, int start, int end) { if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null; int smallIndex = partition(array, start, end); if (smallIndex &gt; start) QuickSort(array, start, smallIndex - 1); if (smallIndex &lt; end) QuickSort(array, smallIndex + 1, end); return array; } /** * 快速排序算法——partition * @param array * @param start * @param end * @return */ public static int partition(int[] array, int start, int end) { int pivot = (int) (start + Math.random() * (end - start + 1)); int smallIndex = start - 1; swap(array, pivot, end); for (int i = start; i &lt;= end; i++) if (array[i] &lt;= array[end]) { smallIndex++; if (i &gt; smallIndex) swap(array, i, smallIndex); } return smallIndex; } /** * 交换数组内两个元素 * @param array * @param i * @param j */ public static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } 复制代码 5.4 算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 7、堆排序（Heap Sort） 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现 注意：这里用到了完全二叉树的部分性质：详情见《数据结构二叉树知识点总结》复制代码 //声明全局变量，用于记录数组array的长度；static int len; /** * 堆排序算法 * * @param array * @return / public static int[] HeapSort(int[] array) { len = array.length; if (len &lt; 1) return array; //1.构建一个最大堆 buildMaxHeap(array); //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆 while (len &gt; 0) { swap(array, 0, len - 1); len–; adjustHeap(array, 0); } return array; } /* * 建立最大堆 * * @param array / public static void buildMaxHeap(int[] array) { //从最后一个非叶子节点开始向上构造最大堆 for (int i = (len - 1) / 2; i &gt;= 0; i–) { adjustHeap(array, i); } } /* * 调整使之成为最大堆 * * @param array * @param i */ public static void adjustHeap(int[] array, int i) { int maxIndex = i; //如果有左子树，且左子树大于父节点，则将最大指针指向左子树 if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex]) maxIndex = i * 2; //如果有右子树，且右子树大于父节点，则将最大指针指向右子树 if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex]) maxIndex = i * 2 + 1; //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。 if (maxIndex != i) { swap(array, maxIndex, i); adjustHeap(array, maxIndex); } } 复制代码 7.4 算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)8、计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现复制代码 /** * 计数排序 * * @param array * @return */ public static int[] CountingSort(int[] array) { if (array.length == 0) return array; int bias, min = array[0], max = array[0]; for (int i = 1; i &lt; array.length; i++) { if (array[i] &gt; max) max = array[i]; if (array[i] &lt; min) min = array[i]; } bias = 0 - min; int[] bucket = new int[max - min + 1]; Arrays.fill(bucket, 0); for (int i = 0; i &lt; array.length; i++) { bucket[array[i] + bias]++; } int index = 0, i = 0; while (index &lt; array.length) { if (bucket[i] != 0) { array[index] = i - bias; bucket[i]–; index++; } else i++; } return array; } 复制代码 8.4 算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)9、桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排9.1 算法描述 人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序； 从不是空的桶里把排好序的数据拼接起来。 注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。9.2 图片演示 9.3 代码实现复制代码 /** * 桶排序 * * @param array * @param bucketSize * @return */ public static ArrayList BucketSort(ArrayList array, int bucketSize) { if (array == null || array.size() &lt; 2) return array; int max = array.get(0), min = array.get(0); // 找到最大值最小值 for (int i = 0; i &lt; array.size(); i++) { if (array.get(i) &gt; max) max = array.get(i); if (array.get(i) &lt; min) min = array.get(i); } int bucketCount = (max - min) / bucketSize + 1; ArrayList&lt;ArrayList&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount); ArrayList resultArr = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bucketCount; i++) { bucketArr.add(new ArrayList()); } for (int i = 0; i &lt; array.size(); i++) { bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i)); } for (int i = 0; i &lt; bucketCount; i++) { if (bucketCount == 1) bucketSize–; ArrayList temp = BucketSort(bucketArr.get(i), bucketSize); for (int j = 0; j &lt; temp.size(); j++) resultArr.add(temp.get(j)); } return resultArr; } 复制代码 9.4 算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 10、基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现复制代码 /** * 基数排序 * @param array * @return */ public static int[] RadixSort(int[] array) { if (array == null || array.length &lt; 2) return array; // 1.先算出最大数的位数； int max = array[0]; for (int i = 1; i &lt; array.length; i++) { max = Math.max(max, array[i]); } int maxDigit = 0; while (max != 0) { max /= 10; maxDigit++; } int mod = 10, div = 1; ArrayList&lt;ArrayList&gt; bucketList = new ArrayList&lt;ArrayList&gt;(); for (int i = 0; i &lt; 10; i++) bucketList.add(new ArrayList()); for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) { for (int j = 0; j &lt; array.length; j++) { int num = (array[j] % mod) / div; bucketList.get(num).add(array[j]); } int index = 0; for (int j = 0; j &lt; bucketList.size(); j++) { for (int k = 0; k &lt; bucketList.get(j).size(); k++) array[index++] = bucketList.get(j).get(k); bucketList.get(j).clear(); } } return array; } 复制代码 10.4 算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值","link":"/2018/03/20/zh/programing/basis/algorithm/top_10_classic_sorting_algorithms/"},{"title":"数据结构与算法","text":"数据结构与算法1.数组、链表（单向、双向、双端）、栈和队列、二叉树、红黑树、哈希表、堆（最大和最小）、图 2.个人经验：栈和队列、哈希表、链表、二叉树的题较多，图的较少 3.查找：二分查找及其变形 4.二叉树：前序、中序、后序遍历，按规定方式打印，两个节点之间操作（最近公共祖先、距离）等问题。 5.最大堆和最小堆：大数量级数据找最大几个等问题、堆如何调整等问题。 6.图：深度优先、广度优先、单源最小路径Dijkstra，任意两点间最短路径Floyd-Warshall，最小生成树Prime和Kruskal 7.红黑树：特点及如何调整（基本上没人让你手撸红黑树） 8.栈和队列：经常作为算法题要用到的数据结构 8.八大排序：3个简单的：冒泡、选择、插入及其优化，5个高级的：快速排序、归并排序、堆排序、希尔排序、桶排序（快排、归并、堆很重要，经常手撸） 9.时间复杂度及空间复杂度分析 10.动态规划dp：这个比较难，背包问题之内的 推荐：数据结构C语言版（严蔚敏）、Java数据结构和算法（Robert Lafore）、剑指offer及leetcode刷题、大神可以看一下算法导论","link":"/2018/02/14/zh/programing/basis/data_structure/data_structure/"},{"title":"是否有必要建外键","text":"前言最近做项目，是在已有数据库基础上写业务，然后发现了很多本是外键的字段并没有设置外键约束。因为之前都是按照规范建数据表，所以对此有点奇怪，然后在网上找到了比较好的回答。 观点对比大家共同观点：主键和索引是不可少的，不仅可以优化数据检索速度，开发人员还省了其它的工作。 矛盾焦点：数据库设计是否需要外键。这里有两个问题：如何保证数据库数据的完整性和一致性；在第一条的基础上对性能的影响。 正方观点： 由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器宕机或者出现其他问题的时候，也能够最大限度的保证数据的一致性和完整性。比如：数据库和应用是一对多的关系，Ａ应用会维护他那部分数据的完整性，系统一变大时，增加了Ｂ应用，Ａ和Ｂ两个应用也许是不同的开发团队来做的。他们如何协调保证数据的完整性，而且一年以后如果又增加了C应用呢？ 有主外键的数据库设计可以增加 ER 图的可读性，这点在数据库设计时非常重要。 外键在一定程度上说明的业务逻辑，会使设计周到具体全面。 反方观点： 可以用触发器或应用程序保证数据的完整性。 过分强调或者说使用主键／外键会平添开发难度，导致表过多等问题。 不用外键时数据管理简单，操作方便，性能高（导入导出等操作，在 insert, update, delete 时更快）比如：在海量的数据库中不用去想外键，试想，一个程序每天要 insert 数百万条记录，当存在外键约束的时候，每次要去扫描此记录是否合格，一般还不止一个字段有外键，这样扫描的数量是成级数的增长！一个程序入库在3个小时做完，如果加上外键，需要28个小时！ 结论： 在对【性能要求不高，安全要求高】的系统中使用外键；在【性能要求高，安全自己控制】的系统中不用外键；小系统都可以，最好用外键。 用外键要适当，不能过分追求。 不用外键而用程序控制数据一致性和完整性时，应该写一层来保证，然后个个应用通过这个层来访问数据库。 思考看完上面的回答之后让我想起了 NOSQL 的兴起，和在设计数据表结构时可以通过适当降低范式提高性能等技巧，要多用两面性看待问题恩。","link":"/2018/06/17/zh/programing/basis/database/create_foreign_keys/"},{"title":"Redis、Memcached","text":"共同点Memcached 和 Redis 都很类似：都是内存型数据库，数据保存在内存中，通过 TCP 直接存取，速度快，并发高，但数据类型有限，查询功能不强，一般用作缓存。 Memcached优点 可以利用多核优势，单实例吞吐量极高，可以达到几十万 QPS（取决于 key/value 的字节大小以及服务器硬件性能，日常环境中 QPS 高峰大约在4-6w左右）。 适用于最大程度扛量，有效为服务器减压。 支持直接配置为 Session handle。 缺点 数据结构很简单单一，只支持简单的 key/value 数据结构，不像 Redis 可以支持丰富的数据类型。 无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。 无法进行数据同步，不能将 MC 中的数据迁移到其他 MC 实例中。 内存分配采用 Slab Allocation 机制管理内存，value 大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题，需要用户注重 value设计。 服务端原生不支持水平扩展，必须在客户端编写缓存分布策略来实现分布式缓存，并且由于无法进行数据同步，因此生产环境中出现单机故障时可能会影响部分业务运行。 Redis优点 支持多种数据结构，比如 string（字符串）、list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）等。 支持持久化操作，可以进行 aof 及 rdb 数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。 支持通过 Replication 进行数据复制，通过 master-slave 主从机制，可以实时进行数据的同步复制，支持多级复制和增量复制， master-slave 机制是 Redis 进行 HA 的重要手段。 单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。 支持 pub/sub 消息订阅机制，可以用来进行消息订阅与通知。 支持简单的事务需求，但业界使用场景很少，并不成熟。 缺点 Redis 只能使用单线程，性能受限于 CPU 性能，故单实例 CPU 最高QPS才可能达到每秒5-6w（取决于数据结构，数据大小以及服务器硬件性能，日常环境中 QPS 高峰大约在1-2w左右）。 支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。 Redis 在 string 类型上会消耗较多内存，可以使用 dict（hash表）压缩存储以降低内存耗用。 总结 Memcached 是多线程非阻塞IO复用的网络模型；Redis 使用单线程的IO复用模型。 Memcached 使用预分配的内存池的方式；Redis 使用现场申请内存的方式来存储数据。 Memcached 的服务器端互相完全独立；Redis 计划在服务器端内建对集群的支持。 Memcached 可以使用多核；Redis 只使用单核。","link":"/2018/07/22/zh/programing/basis/database/redis_and_memcached/"},{"title":"linux","text":"启动流程POST -&gt; BIOS(Boot Sequence) -&gt; MBR(bootloader,446) -&gt; Kernel -&gt; initrd -&gt; (ROOTFS)/sbin/init(/etc/inittab) BIOS自检 -&gt; 从BIOS中读取启动顺序 -&gt; 读取MBR中的bootloader -&gt; 加载内核 -&gt; 读取伪根 -&gt; 读取根文件中的init 文件系统Linux 中，一切资源皆文件。比如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。 文件类型Linux 支持5种文件类型： 文件类型 描述 事例 普通文件 用于在辅存（如磁盘）上存储信息和数据 图片，影像等 目录文件 用于表示和管理系统中的文件，目录文件中包含一些文件名和目录名 /root、/home 链接文件 用于不同目录下文件的共享 /root/a -&gt; /tmp/a 设备文件 用于访问硬件设备 包括硬件、键盘、光驱、打印机等 命名管道（FIFO） 进程间的通信可通过该文件完成 目录结构类似一棵倒立的树，最顶层是其根目录： 常见目录： /bin ：存放二进制可执行文件（ls,cat,mkdir等），常用命令一般都在这里；/etc ：存放系统管理和配置文件；/home：存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是 /home/user，可以用 ~user 表示；/usr ：存放系统应用程序；/opt ：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 Tomcat 等都安装到这里；/proc：虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；/root：超级用户（系统管理员）的主目录；/sbin: 存放系统管理员使用的系统级别的管理命令和程序，比如 ifconfig 等；/dev ：存放设备文件；/mnt ：系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；/boot：存放用于系统引导时使用的各种文件；/lib ：存放着和系统运行相关的库文件；/tmp ：存放各种临时文件，是公用的临时文件存储点；/var ：存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志）等；/lost+found：这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。 权限操作系统中每个文件都拥有特定的权限、所属用户和所属组。 权限是操作系统用来限制资源访问的机制。所属分为属主（owner），属组（group）、其他用户（other）。 标识 文件类型 d 目录 - 文件 l 链接 标识 权限 数字标识 r 可读（readable） 4 w 可写（writable） 2 x 可执行（excutable） 1 文件和目录权限的区别 对于文件 权限名称 可执行操作 r 可用 cat 查看文件的内容 w 可修改文件的内容 x 可运行 对于目录 权限名称 可执行操作 r 可查看目录下列表 w 可创建和删除目录下文件 x 可用 cd 进入目录 常用命令Linux命令大全 findfind 目录 参数：寻找目录（查） 列出当前目录及子目录下所有文件和文件夹：find . 在 /home 目录下查找以 .txt 结尾的文件名：find /home -name '*.txt' 同上，但忽略大小写：find /home -iname '*.txt' 当前目录及子目录下查找所有以.txt和.pdf结尾的文件：find . \\( -name '*.txt' -o -name '*.pdf' \\) 或 find . -name '*.txt' -o -name '*.pdf' chmod修改 a.txt 的权限为属主有全部权限，属组有读写权限，其他用户只有读的权限：chmod u=rwx,g=rw,o=r a.txt 还可以使用数字表示：chmod 764 a.txt 用户管理添加用户账号：useradd 选项 用户名删除用户帐号：userdel 选项 用户名修改帐号 ：usermod 选项 用户名清除用户密码：passwd -d 用户名更改或创建用户的密码：passwd 用户名显示用户账号密码信息：passwd -S 用户名 用户组的管理添加用户组：groupadd 选项 用户组删除用户组：groupdel 用户组修改用户组：groupmod 选项 用户组 查看进程查看进程：ps -ef/ps aux（两者的展示格式不同） 杀死进程：kill -9 pid（-9 表示强制终止） 查看端口使用：netstat -an 2.Linux状态分析：CPU（top）、内存（top和free，注意buffer和cache区别）、磁盘（fdisk和df）、IO（iostat）等 服务器状态分析检测CPU和内存：vmstat（Virtual Meomory Statistics）检测磁盘状态 ：iostat检测带宽状态 ：netstat vmstat1234$ vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r b swpd free buff cache si so bi bo in cs us sy id wa st2 0 17920 15568 66639 38382 0 0 151 103 756 815 8 12 79 2 0 Procs（进程）： r：运行队列中进程数量。 b：等待IO的进程数量。 当r值超过了CPU个数，就会出现CPU瓶颈，解决办法： 增加CPU个数和核数。 通过调整任务执行时间，如大任务放到系统不繁忙的情况下进行执行，进而平衡系统任务。 调整已有任务的优先级。 Memory（内存）： swpd：使用虚拟内存大小。如果该值不为0，但 SI，SO 的值长期为0，这种情况不会影响系统性能。 free：空闲物理内存大小。 buff：用作缓冲的内存大小。 cache：用作缓存的内存大小。该值越大，说明缓存的文件越多，如果频繁访问到的文件都能被缓存，那么磁盘的读IO bi会非常小。 Swap： si：每秒从交换区写到内存的大小，磁盘 -&gt; 内存。 so：每秒写入交换区的内存大小，内存 -&gt; 磁盘。 注：内存够用时，这2个值都是0。如果这2个值长期大于0，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。 IO： bi：每秒读取的块数。 bo：每秒写入的块数。 注：随机磁盘读写的时候，这2个值越大（如超出1024k)，CPU在IO等待的值也会越大。 system（系统）： in：每秒中断数，包括时钟中断。 cs：每秒上下文切换数。 注：上面2个值越大，内核消耗的CPU时间就越大。 CPU（以百分比表示）： us：用户进程执行时间百分比(user time)。该值越大，说明用户进程消耗的CPU时间越多，如果长期超50%，就该考虑优化程序。 sy：内核系统进程执行时间百分比(system time)。该值越大，说明系统内核消耗的CPU资源多，应该检查原因。 wa：IO等待时间百分比。该值越大，说明IO等待越严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 id：空闲时间百分比。如果长期低于10%，那么表示CPU的资源已经非常紧张，应该考虑进程优化或添加更多地CPU。 iostatBlk_read/s：每秒读取的数据块数Blk_wrtn/s：每秒写入的数据块数Blk_read：读取的所有块数Blk_wrtn：写入的所有块数 如果 Blk_read/s 和 Blk_wrtn/s 一直都很高，说明服务器对于硬盘的读写操作过于频繁，应该对其进行优化。 文本处理wc-c/–bytes/–chars：只显示字节数-l/–lines：只显示列数-w/–words：只显示字数（以空格划分） grep-v：反向查找-i：查找时不区分大小写-w：全词匹配-n：显示每个搜索结果的行号 sed暂略 awk暂略","link":"/2018/04/08/zh/programing/book_read/linux/linux/"},{"title":"HashMap","text":"源码 https://www.cnblogs.com/skywang12345/p/3310835.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable { // 实际上 Node 是一个单向链表 private static class Node&lt;K, V&gt; implements java.util.Map.Entry&lt;K, V&gt; { //... } // 哈希表的&quot;key-value键值对&quot;都是存储在 Node 数组中的 private transient HashMap.Node&lt;K, V&gt;[] table; // HashMap 中保存的键值对的实际数量 private transient int size; // 阈值，用于判断是否需要调整 HashMap 的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private final float loadFactor; // HashMap 被改变的次数，实现 fail-fast 机制 private transient int modCount; // ... public V put(K key, V value) { return this.putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { HashMap.Node&lt;K, V&gt;[] tab = this.table; Node&lt;K, V&gt; p; int n, i; if (this.table == null || (n = tab.length) == 0) n = (tab = this.resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K, V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } public V get(Object key) { HashMap.Node&lt;K, V&gt; node = this.getNode(hash(key), key); return node == null ? null : node.value; } final HashMap.Node&lt;K, V&gt; getNode(int hash, Object key) { HashMap.Node&lt;K, V&gt;[] table = this.table; int n = table.length; HashMap.Node&lt;K, V&gt; first = table[n - 1 &amp; hash], e; K k; if (this.table != null &amp;&amp; n &gt; 0 &amp;&amp; first != null) { for (; first != null; first = first.next) { // 在该 hash 值对应的链表上查找键值等于 key 的元素 // 如果 hash 值相同并且键值地址或键值一样 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } } return null; }} 继承关系 123java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.HashMap&lt;K, V&gt; 特点 HashMap 实际上是一个”链表散列”的数据结构，即数组和链表的结合体。底层结构是一个数组，数组中的每一项是一条链表。存储的是 Entry 键值对（key-value）映射。 允许存在一个 key 为 null 和任意个 value 为 null 的键值对。 HashMap 继承于 AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。 HashMap 的方法没有锁，即其不是线程安全的。 构造函数 HashMap 提供了4个构造函数： 1234567891011// 默认构造函数public HashMap()// 指定“容量大小”的构造函数public HashMap(int initialCapacity)// 指定“容量大小”和“加载因子”的构造函数public HashMap(int initialCapacity, float loadFactor)// 包含“子Map”的构造函数public HashMap(Map&lt;? extends K, ? extends V&gt; map) 上面的四个构造方法中，第三个最重要，指定初始化容量和构造因子： 1234567891011121314151617181920212223242526272829public HashMap(int initialCapacity, float loadFactor) { // 验证初始容量 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); // HashMap 的最大容量只能是 MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 验证加载因子 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; // 计算阀值 this.threshold = tableSizeFor(initialCapacity);}// 返回 initialCapacity 的最小2次幂private static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}","link":"/2018/05/12/zh/programing/java/code_analysis/HashMap/"},{"title":"HashMap、Hashtable、HashSet 和 ConcurrentHashMap 的比较","text":"Hashtable 和 HashMap 区别 基类不同：HashTable 基于 Dictionary 类；HashMap 基于 AbstractMap。 null：HashTable 中的 key 和 value 都不允许为 null；HashMap 允许存在一个 key 为 null 和任意个 value 为 null 的键值对。 线程安全：Hashtable 线程安全；HashMap 线程不安全。同样，线程的安全与否会影响性能。 遍历不同：Hashtable 支持 Iterator 和 Enumeration 两种遍历方式；HashMap 仅支持 Iterator 的遍历方式。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的（重新哈希时可能移动元素）。 可以通过下面的语句使得 HashMap 同步： 1Map map = Collections.synchronizeMap(hashMap); 关于 HashMap 线程不安全，《Java并发编程的艺术》中写道：HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近 100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。 相关问题可以使用自定义的对象作为 key 吗？ 可以使用任何对象作为键，只要它遵守了 equals() 和 hashCode() 方法的定义规则，并且当对象插入到 Map 中之后将不会再改变了。","link":"/2018/07/01/zh/programing/java/code_analysis/HashMap_Hashtable_HashSet_ConcurrentHashMap/"},{"title":"HashTable","text":"源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable { // 实际上 Entry 是一个单向链表 private static class Entry&lt;K, V&gt; implements java.util.Map.Entry&lt;K, V&gt; { //... } // 哈希表的 key-value键值对 都是存储在 Entry 数组中的 private transient Hashtable.Entry&lt;?, ?&gt;[] table; // Hashtable 中保存的键值对的实际数量 private transient int count; // 阈值，当保存的数量超过该阀值时 Hashtable 将重新哈希 // threshold = 容量 * 加载因子 private int threshold; // 加载因子 private float loadFactor; // Hashtable 被改变的次数，实现 fail-fast 机制（看 ConcurrentModificationException） private transient int modCount = 0; // ... private void addEntry(int hash, K key, V value, int entry) { this.modCount++; Hashtable.Entry[] tab = this.table; // 如果容器中的元素数量已经达到阀值，则进行扩容操作 if (this.count &gt;= this.threshold) { this.rehash(); tab = this.table; hash = key.hashCode(); entry = (hash &amp; 0x7FFFFFFF) % tab.length; } // 在索引位置处插入一个新的节点 Hashtable.Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) tab[index]; tab[entry] = new Hashtable.Entry(hash, key, value, e); // 容器中元素+1 this.count++; } public synchronized V put(K key, V value) { // 确保 value 不为 null if (value == null) { throw new NullPointerException(); } else { /* * 确保 key 在 table[] 是不重复的 * 处理过程： * 1、计算 key 的 hash 值，确认在 table[] 中的索引位置 * 2、迭代 index 索引位置，如果该位置处的链表中存在一个一样的 key，则替换其 value，返回旧值 */ Hashtable.Entry&lt;?, ?&gt;[] tab = this.table; // key 的 hash 值，而 null 没有 hashCode，所以 key 不能为 null int hash = key.hashCode(); // 确认该 key 的索引位置 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 迭代，寻找该 key，存在则替换，并返回旧值 Hashtable.Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) tab[index]; for (; e != null; e = e.next) { if (e.hash == hash &amp;&amp; e.key.equals(key)) { V old = e.value; e.value = value; return old; } } this.addEntry(hash, key, value, index); return null; } } public synchronized V get(Object key) { Hashtable.Entry&lt;?, ?&gt;[] tab = this.table; // 先获得索引值 int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 然后遍历 Hashtable.Entry&lt;?, ?&gt; e = tab[index]; for (; e != null; e = e.next) { if (e.hash == hash &amp;&amp; e.key.equals(key)) { // 最后返回 return (V) e.value; } } return null; }} 继承关系 123java.lang.Object ↳ java.util.Dictionary&lt;K, V&gt; ↳ java.util.Hashtable&lt;K, V&gt; 特点 Hashtable 是一个散列表，它存储的内容是键值对（key-value）映射。 key、value 都不可以为 null。 Hashtable 继承于 Dictionary，实现了 Map、Cloneable、java.io.Serializable 接口。 Hashtable 的方法都是同步（synchronized）的，即其是线程安全的。 构造函数 Hashtable 提供了4个构造函数： 1234567891011// 默认构造函数public Hashtable()// 指定“容量大小”的构造函数public Hashtable(int initialCapacity)// 指定“容量大小”和“加载因子”的构造函数public Hashtable(int initialCapacity, float loadFactor)// 包含“子Map”的构造函数public Hashtable(Map&lt;? extends K, ? extends V&gt; map) 上面的四个构造方法中，第三个最重要，指定初始化容量和构造因子： 1234567891011121314151617181920public Hashtable(int initialCapacity, float loadFactor) { // 验证初始容量 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity); // 验证加载因子 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+ loadFactor); if (initialCapacity == 0) initialCapacity = 1; this.loadFactor = loadFactor; // 初始化 table，获得大小为 initialCapacity 的 table 数组 this.table = new Hashtable.Entry&lt;?,?&gt;[initialCapacity]; // 计算阀值 this.threshold = (int) Math.min((float) initialCapacity * loadFactor, this.MAX_ARRAY_SIZE + 1);}","link":"/2018/05/12/zh/programing/java/code_analysis/HashTable/"},{"title":"Integer","text":"IntegerCache为什么 127 == 127 会返回为 True，而 128 == 128 返回为 False？ 代码如下： 123456789public class Main { public static void main(String[] args) { Integer a = 127, b = 127; System.out.println(a == b); Integer c = 128, d = 128; System.out.println(c == d); }} 结果： 12truefalse 两个引用如果指向的是同一个对象，那么 == 成立；反之，如果指向的不是同一个对象，那么 == 不成立，即使引用的内容是一样的。 如果127都相等，为什么128不相等呢？ 断点设置在初始化时： 可以看到进入了 valueOf 方法： 同时可以看到有个 IntegerCache 类，从名字上可以判断是缓存整数类型的类（并且是私有静态类）。 可以看到上面的注释写着：This method will always cache values in the range -128 to 127. 也就是如果值是在 -128~127 范围内，那么第二次 valueOf 赋值时不再 new Integer(i)，而是直接使用缓存下来的对象。 所以 Integer a = 127, b = 127;，b 的值指向了和 a 一样的对象。 那么是否可以更改缓存的范围呢？ 注释上有一句：The size of the cache may be controlled by the {@code -XX:AutoBoxCacheMax=} option. 也就是我们可以在启动时设置选项 -XX:AutoBoxCacheMax=&lt;size&gt; 来改变这个缓存范围。","link":"/2018/07/01/zh/programing/java/code_analysis/Integer/"},{"title":"Idea 读取 Java 源码","text":"前记如果需要读 Java 源码，默认点查看读的是 Idea 反编译的文件，没有注释，参数名也被简化了。 所以如果需要更好的读源码，需要添加 src.zip 源码包。 官网下载从搜索结果看，都说是直接添加 JDK 目录下的 src.zip，但是我的 JDK8 怎么都找不到。只好去官网下载整个 JDK，然后拿出我想要的源码包。 JDK8 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 里面有 src.zip 源码包，放到 JDK 目录下。 如果 Idea 读取的 SDK 就是你当前使用的 JDK 版本，它会自动帮你添加。 File =&gt; Project Structure =&gt; SDKs，将 JDK 设置成刚才的 JDK 目录。","link":"/2018/07/01/zh/programing/java/code_analysis/idea_read_java_source/"},{"title":"OAuth2 初识","text":"前记OAuth2 可以方便第三方应用获取用户在其他应用的信息。 比如用 QQ 账户登录优酷，优酷就会先让用户登录 QQ，然后让用户确认授权优酷访问 QQ 上的信息，确认后优酷就获得了 QQ 的 OAuth 服务器返回的 token，之后就可以通过 token 访问到权力范围内的用户相关信息。 以下是相关的文章： RFC 6749 OAuth2 Simplified 阮一峰 – 理解 OAuth 2.0 这篇用豆瓣举例的文章 一张图搞定OAuth2.0 写得不错。这里也参考它的简易 Demo，并结合自己对 OAuth2 协议的理解，和腾讯文档写出本文的 Demo —— 模拟 QQ 授权银行客户端（授权码模式）。 应用场景有一个”云冲印”的网站，可以将用户储存在 Google 的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在 Google 上的照片。 问题是只有得到用户的授权，Google 才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？ 传统方法是，用户将自己的 Google 用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点： “云冲印”为了后续的服务，会保存用户的密码，这样很不安全。 Google 不得不部署密码登录，而我们知道，单纯的密码登录并不安全。 “云冲印”拥有了获取用户储存在 Google 所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。 用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。 只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。 OAuth 就是为了解决上面这些问题而诞生的。 名词定义 Third-party Application：第三方应用程序，本文中又称”客户端”（Client），即例子中的”云冲印”。 HTTP Service：HTTP 服务提供商，本文中简称”服务提供商”，即例子中的 Google。 Resource Owner：资源所有者，本文中又称”用户”（User）。 User Agent：用户代理，本文中就是指浏览器。 Authorization Server：认证服务器，即服务提供商专门用来处理认证的服务器。 Resource Server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 OAuth 的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。 OAuth的思路OAuth 在”客户端”与”服务提供商”之间，设置了一个授权层（Authorization Layer）。“客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。“客户端”登录授权层所用的令牌（Token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。 运行流程 （A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（关键，有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源）（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源。 客户端的授权模式客户端必须得到用户的授权（Authorization Grant），才能获得令牌（Access Token）。 OAuth2 定义了四种授权方式： 授权码模式（Authorization Code） 简化模式（Implicit） 密码模式（Resource Owner Password Credentials） 客户端模式（Client Credentials） 授权码模式（Authorization code）功能最完整、流程最严密的授权模式。 特点：通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。 步骤 （A）用户访问客户端，客户端将用户导向认证服务器。（B）用户选择是否给予客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（Redirection URI），同时附上一个授权码。（D）客户端收到授权码，带上”重定向URI”向认证服务器申请令牌。（这一步是在客户端的后台的服务器上完成的，对用户不可见）（E）认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（Access Token）和更新令牌（Refresh Token）。 对于应用而言，需要进行两步： 获取 Authorization Code =&gt; （A）（B）（C）步骤 通过 Authorization Code 获取 Access Token =&gt; （D）（E）步骤 过程详解获取 Authorization Code 请求地址：https://qq.com/authorize 请求方法：GET 请求参数 是否必须 描述 response_type 是 授权类型，此值固定为”code” client_id 是 在认证服务器注册获得的客户端 ID client_secret 否 在认证服务器注册获得的客户端秘钥（如果没有分配，可以为空） state 是 客户端的状态值。防止客户端被CSRF攻击，成功授权后回调时会原样带回。严格按照流程检查用户与 state 参数状态的绑定，参见RFC 文档，以及这篇文章OAuth2 CSRF攻击 redirect_uri 是 成功授权后的回调地址，注意需将 url 进行 URLEncode scope 否 请求用户授权时向用户显示的可进行授权的列表。建议控制授权项的数量，只传入必要的接口名称，因为授权项越多，用户越可能拒绝进行任何授权 例子请求： 12GET /authorize?response_type=code&amp;client_id=abc123&amp;client_secret=abc&amp;state=test&amp;scope=userinfo&amp;redirect_uri=http%3a%2f%2fbank.com%2findex HTTP/1.1Host: demo.com 例子返回： 如果用户成功登录并授权，则会跳转到指定的回调地址，并在 redirect_uri 地址后带上 Authorization Code 和原始的 state 值。比如： 12HTTP/1.1 302 FoundLocation: http://bank.com/index?code=1234-abcd&amp;state=test 返回参数 描述 code Authorization Code，注意设置该码的过期时间。有效期应该很短，通常设为10分钟，客户端只能使用一次该码，否则会被授权服务器拒绝。该码与客户端 ID 和重定向 URI 是一一对应关系。 state 与请求中的 state 一致 如果用户在登录授权过程中取消登录流程，对于 PC 网站，登录页面直接关闭；对于 WAP 网站，同样跳转回指定的回调地址，并在 redirect_uri 地址后带上 usercancel 参数和原始的 state 值，其中 usercancel 值为非零，比如： 12HTTP/1.1 302 FoundLocation: https://bank.com/index?usercancel=1&amp;state=test demo 中并没有写取消登录的代码 通过 Authorization Code 获取 Access Token 请求地址：https://qq.com/token 请求方法：POST 请求头 是否必须 描述 Authorization 是 Base64(client_id + client_secret) 请求参数 是否必须 描述 grant_type 是 授权类型，此值固定为”authorization_code” code 是 上一步返回的 Authorization Code redirect_uri 是 与上一步中的回调地址 redirect_uri 一致 例子请求： 123456POST /token HTTP/1.1Host: demo.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp;code=1234-abcd&amp;redirect_uri=http%3a%2f%2fbank.com%2findex HTTP/1.1 例子返回： 12345678910111213HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8# 在 HTTP 头部明确不得缓存Cache-Control: no-storePragma: no-cache{ &quot;access_token&quot;: &quot;2Young2Simple&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires_in&quot;: 3600, &quot;refresh_token&quot;: &quot;TripleFox&quot;, &quot;scope&quot;: &quot;select&quot;} 返回参数 描述 access_token 授权令牌 expires_in 有效期，单位为秒 refresh_token 在授权自动续期步骤中，获取新的 access_token 时需要提供的参数 token_type 令牌类型，bearer 或 mac 类型 scope 权限范围，如果与客户端申请的范围一致，可省略 更新令牌 请求地址： 请求地址：https://qq.com/token 请求方法：GET 请求参数 是否必须 描述 grant_type 是 授权类型，此值固定为”refresh_token” client_id 是 与上一步中的客户端 ID 一致 refresh_token 是 上一步返回的 refres_token 返回内容同上一步。 简化模式（Implicit Grant Type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”获取授权码”步骤。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 步骤 （A）客户端将用户导向认证服务器。（B）用户决定是否给于客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在 URI 中附上访问令牌。（D）浏览器向资源服务器发出请求，但不包括上一步收到的访问令牌。（E）资源服务器返回一个脚本，其中包含的代码可以获取访问令牌。（F）浏览器执行上一步获得的脚本，提取出令牌。（G）浏览器将令牌发给客户端。 对于应用而言，只需一步：获取 Access Token =&gt; （A）（B）（C）步骤 过程详解获取 Access Token 请求地址：https://qq.com/authorize 请求方法：GET 请求参数 是否必须 描述 response_type 是 授权类型，此值固定为”token” client_id 是 在认证网站注册获得的客户端 ID state 是 客户端的状态值。防止第三方应用被CSRF攻击，成功授权后回调时会原样带回。严格按照流程检查用户与 state 参数状态的绑定 redirect_uri 是 成功授权后的回调地址，注意需将 url 进行 URLEncode scope 否 请求用户授权时向用户显示的可进行授权的列表。 除了请求参数中 response_type 的值不同外，其他与授权码模式基本一致。 例子请求： 12GET /authorize?response_type=code&amp;client_id=abc123&amp;state=test&amp;redirect_uri=http%3a%2f%2fbank.com%2findex HTTP/1.1Host: demo.com 例子返回： 12HTTP/1.1 302 FoundLocation: http://bank.com/index?access_token=2Young2Simple&amp;state=test&amp;expires_in=3600&amp;token_type=bearer&amp;scope=select 返回参数 描述 access_token 授权令牌 expires_in 有效期，单位为秒 token_type 令牌类型，bearer 或 mac 类型 scope 权限范围，如果与客户端申请的范围一致，可省略 state 客户端的状态值。同请求 state 密码模式（Resource Owner Password Credentials Grant）用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。 在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。 步骤 （A）用户向客户端提供用户名和密码。（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。（C）认证服务器确认无误后，向客户端提供访问令牌。 过程详解过程和传统的登录获取 token 基本一致。 获取 Access Token 请求地址：https://qq.com/token 请求方法：GET 请求参数 是否必须 描述 grant_type 是 授权类型，此值固定为”password” username 是 用户名 password 是 用户密码 scope 否 请求用户授权时向用户显示的可进行授权的列表。 例子请求： 12GET /token?grant_type=password&amp;username=abc&amp;password=abc HTTP/1.1Host: demo.com 例子返回： 123456789101112HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{ &quot;access_token&quot;: &quot;2Young2Simple&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires_in&quot;: 3600, &quot;refresh_token&quot;: &quot;TripleFox&quot;, &quot;scope&quot;: &quot;select&quot;} 返回参数 描述 access_token 授权令牌 expires_in 有效期，单位为秒 refresh_token 在授权自动续期步骤中，获取新的 access_token 时需要提供的参数 token_type 令牌类型，bearer 或 mac 类型 scope 权限范围，如果与客户端申请的范围一致，可省略 整个过程中，客户端不能保存用户密码。 客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于 OAuth 框架所要解决的问题。 在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 步骤 （A）客户端向认证服务器进行身份认证，并要求一个访问令牌。（B）认证服务器确认无误后，向客户端提供访问令牌。 获取 Access Token 请求地址：https://qq.com/token 请求方法：GET 请求参数 是否必须 描述 grant_type 是 授权类型，此值固定为”clientcredentials” scope 否 请求用户授权时向用户显示的可进行授权的列表。 例子请求： 12GET /token?grant_type=client_credentials HTTP/1.1Host: demo.com 例子返回： 123456789101112HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache{ &quot;access_token&quot;: &quot;2Young2Simple&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires_in&quot;: 3600, &quot;refresh_token&quot;: &quot;TripleFox&quot;, &quot;scope&quot;: &quot;select&quot;} 返回参数 描述 access_token 授权令牌 expires_in 有效期，单位为秒 refresh_token 在授权自动续期步骤中，获取新的 access_token 时需要提供的参数 token_type 令牌类型，bearer 或 mac 类型 scope 权限范围，如果与客户端申请的范围一致，可省略 Demo 截图模拟 QQ 授权银行客户端（授权码模式）。 选择 QQ 授权登录： 银行客户端将用户导向 QQ 的授权登录页面： 并且在导向前客户端设置了 Session 保存 state： 同样 QQ 也设置了 Session 保存状态： QQ 的 Session： 授权登录后，QQ 将用户重定向回客户端设置的回调页面： 因为 state 设置了时效性，获取授权码后即被销毁，所以刷新即被当做攻击了：","link":"/2018/06/21/zh/programing/java/oauth2/oauth2/"},{"title":"OAuth2 CSRF 攻击","text":"前记本文主要是理解 OAuth2 协议中的 state 参数的用意——防止第三方客户端被 CSRF 攻击。 Demo 依然是 OAuth2 初识中的 模拟 QQ 授权银行客户端（授权码模式）。 参考文章：RFC 6749 – Cross-Site Request ForgeryOAuth2 CSRF攻击 针对 OAuth2 的 CSRF 攻击流程假设有用户张三，攻击者李四，OAuth2 服务提供者 Sparklr，以及第三方客户端 Tonr（它允许使用第三方社交账号 Sparklr 登录，并允许用户将 Sparklr 账号和 Tonr 账号进行绑定）。 攻击者李四 进入 Tonr 网站，使用第三方社交 Sparklr 账号登录。 Tonr 将李四重定向到 Sparklr，由于他本地已经登录过 Sparklr（类似挂着QQ），所以 Sparklr 直接向他显示是否授权 Tonr 访问的页面。 李四在点击”同意授权”之后，使用类似 BurpSuite 这样的流量拦截工具，截获了 Sparklr 服务器返回的含有 Authorization code 参数的 HTTP 响应。（因为该 code 只能使用一次，所以要避免被浏览器正常使用了） 李四精心构造一个 Web 页面，它会触发 Tonr 向 Sparklr 发起令牌申请的请求，而这个请求中的 Authorization Code 参数正是上一步截获到的 code。 李四将这个 Web 页面放到互联网上，等待或者诱骗受害者张三来访问。 张三此时正在 Tonr 上看东西（即登录状态），只是没有把自己的账号和其他社交账号绑定起来。在张三访问了李四准备的这个 Web 页面，令牌申请流程在张三的浏览器里被顺利触发，Tonr 从 Sparklr 那里获取到 access_token，但是这个 token 以及通过它进一步获取到的用户信息却都是攻击者李四的。 Tonr 将李四的 Sparklr 账号同张三的 Tonr 账号关联绑定起来。从此以后，李四就可以用自己的 Sparklr 账号通过第三方登录到张三在 Tonr 网站中的账号，堂而皇之的冒充张三的身份执行各种操作。 让我们从几个不同的角度来看看这当中发生了什么。 受害者张三（Resource Owner）视角受害者张三访问了一个 Web 页面，然后，就没有然后了。 他在 Tonr 网站上的账号就和攻击者李四在 Sparklr 上的账号绑定到了一起。 伪造的请求是经过精心构造的，令牌申请这一过程在张三的浏览器里是非常隐蔽的被触发的，他根本不知道这背后发生了什么。 Tonr 网站（Client）视角从 Tonr 网站来看，它收到的所有请求看上去都是正常的。 首先它收到了一个 HTTP 请求，其代表着当前用户张三在 Sparklr 网站上已经做了”同意授权”操作。其内容：GET /bindingCallback?code=AUTHORIZATION_CODE 注意：此时 URL里的 code 不是当前受害者张三的 Authorization Code，而是攻击者李四的。 当 Tonr 收到这样的请求时，它以为张三已经同意授权（但实际上这个请求是李四伪造的），于是就发起后续的令牌申请请求，用收到的 Authorization Code 向 Sparklr 换取 access_token，只不过最后拿到的是攻击者李四的 access_token。 最后，Tonr 网站把攻击者李四的 access_token 和当前受害者张三在 Tonr 网站上的账号进行关联绑定。 Sparklr 网站（OAuth2 服务提供者）视角认证方 Sparklr 网站也是一脸茫然的样子，因为在它看来，自己收到的授权请求，以及后续的令牌申请请求都是正常的，或者说它无法得知接收到的这些请求之间的关联关系，而且也无法区别出这些请求到底是来自张三本人，还是由李四伪造出来的。 因此只要自己收到的参数是正确有效的，那就提供正常的认证服务，仅此而已。 攻击者李四视角李四伪造了一个用户授权成功的请求，并且将其中的 Authorization Code 参数替换成了自己提前获取到的 code。 这样，当受害者的浏览器被欺骗从而发起令牌申请请求时，实际上是在用张三在 Tonr 网站上的账号和李四在 Sparklr 网站上的账号做绑定。 攻击完成后，李四在 Tonr 网站上可以通过自己在 Sparklr 网站的账号进行登录，而且登录进入的是张三在 Tonr 网站上的账号。而张三通过自己在 Tonr 网站上的账号登录进去之后，看到的是李四在 Sparklr 网站上的数据。 上帝视角从整体上来看，这次攻击的时序图应该是下面这个样子的： 前提条件尽管这个攻击既巧妙又隐蔽，但是要成功进行这样的 CSRF 攻击需要满足一定前提： 在攻击过程中，受害者张三在 Tonr 网站上的用户会话（Session）必须是有效的，也就是说，张三在受到攻击前已经登录了 Tonr 网站。 整个攻击必须在短时间内完成，因为 OAuth2 提供者颁发的 Authorization Code 有效期很短，OAuth2 官方推荐的时间是不大于10分钟，而一旦 Authorization Code 过期那么后续的攻击也就不能进行下去了。 一个 Authorization Code 只能被使用一次，如果 OAuth2 提供者收到重复的 Authorization Code，它会拒绝当前的令牌申请请求。不止如此，根据 OAuth2 官方推荐，这个已经使用过的 Authorization Code 相关联的 access_token 全部都要撤销掉，进一步降低安全风险。 state 参数防御要防止这样的攻击就要用到 state 参数，具体细节： 在将用户重定向到 OAuth2 的 Authorization Endpoint 去的时候，为用户生成一个 state 参数并加入到请求 URL 中。 在收到 OAuth2 服务提供者返回的包含 Authorization Code 重定向请求的时候，验证接收到的 state 参数值。如果是正确合法的请求，那么此时接受到的参数值应该和上一步提到的为该用户生成的 state 参数值完全一致，否则就是异常请求。 state 参数值必须满足下面几个特性： 不可预测性：足够的随机，使得攻击者难以猜到正确的参数值。 关联性：state 参数值保存在 Session、或 Cookie、或 Local storage（同源策略保护）。 唯一性：每个用户，甚至每次请求生成的 state 参数值都是唯一的。 时效性：state 参数一旦被使用则立即失效。 以上面的角色和 Demo 代码举例： 前提：Tonr 的开发者在了解到这个 state 参数后即进行了修复。 用户张三访问攻击者李四的 Web 恶意页面，里面包含了请求 bank 中的 bindingCallback的代码和李四自己的授权码 code=AUTHORIZATION_CODE。 然后 Tonr 收到请求后会先检查浏览器中保存的 state 是否存在，如果不存在或者 state 的值不匹配，即可以判断这可能是恶意请求，从而避免了攻击者的恶意绑定行为。 总结state 参数在 OAuth2 认证过程中不是必选参数，但如果忽略就会导致应用易受 CSRF 攻击。此外，这样的攻击非常巧妙，可以悄无声息的攻陷受害者的账号，难以被察觉到。","link":"/2018/06/24/zh/programing/java/oauth2/oauth2_csrf_attack/"},{"title":"OAuth2 SSO","text":"前记单点登录（Single Sign On）严格上来说和 OAuth2 没太大关系，只是 SSO 可以通过 OAuth2 实现。本文延续 OAuth2 初识的模式，看完原理写 Demo，在上一个 Demo 的基础上加以改造。 认证中心仍然是 QQ，然后子系统是 QQ 邮箱 + QQ 游戏，两个子系统除了配置上有少许差别外，基本一样。 代码：GitHub 原理参考单点登录原理，内容上有删改。 前提知识： session 和 cookie 的使用 单系统登录假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat 在会话对象中设置登录状态： 12HttpSession session = request.getSession();session.setAttribute(&quot;isLogin&quot;, true); 用户再次访问时，tomcat 在会话对象中查看登录状态： 12HttpSession session = request.getSession();session.getAttribute(&quot;isLogin&quot;); 实现了登录状态的浏览器请求服务器模型： 每次请求受保护资源时都会检查会话对象中的登录状态，只有 isLogin=true 的会话才能访问，登录机制因此而实现。 多系统的复杂性Web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？ Web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 Web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 Web 系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了： 虽然单系统的登录解决方案很完美，但对于多系统应用群并不适用。 单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 的作用域是有限制的，通常对应网站的域名，浏览器发送 HTTP 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie。 早期的多系统登录就采用同域名的方式共享 cookie。比如 *.baidu.com，然后将它们的 cookie 域设置为 baidu.com，统一在一个顶级域名下，这样 baidu 子域名下的所有子系统都可以共享 cookie 了。 缺点： 应用群域名统一； 应用间使用的 cookie 的 key 值要一致（比如 tomcat 默认是 JSESSIONID），不然无法获取 cookie 并维持会话； 共享 cookie 的方式无法实现跨语言技术平台登录，比如在 Java、PHP、.NET 系统之间； cookie 本身不安全。 单点登录单点登录：用户只要在多系统应用群中登录其中某一个系统，便可在其他所有系统中得到授权而无需再次登录。 登录相比单系统登录，SSO 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。 间接授权通过令牌实现，SSO 认证中心验证用户名密码，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。 用户登录成功之后，与 SSO 认证中心及各个子系统建立会话。 与 SSO 认证中心建立的会话称为全局会话； 与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过 SSO 认证中心。 全局会话与局部会话有如下约束关系： 局部会话存在，全局会话一定存在； 全局会话存在，局部会话不一定存在； 全局会话销毁，局部会话必须销毁。 注销单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。 SSO 认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作 用户向系统1发起注销请求. 系统1根据用户与系统1建立的会话id拿到令牌，向 SSO 认证中心发起注销请求。 SSO 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。 SSO 认证中心向所有注册系统发起注销请求。 各注册系统接收 SSO 认证中心的注销请求，销毁局部会话。 SSO 认证中心引导用户至登录页面。 部署图单点登录涉及 SSO 认证中心 server 与众子系统 clients，子系统与 SSO 认证中心之间进行通信以交换令牌、校验令牌和发起注销请求，因而子系统必须集成 SSO 的客户端，SSO 认证中心则是 SSO 服务端，整个单点登录过程实质是 SSO 客户端与服务端通信的过程： SSO 认证中心与 SSO 客户端通信方式有多种，比如：Web Service、RPC、RESTFul API。 实现SSO-Client servlet、filter 或 listener 拦截子系统 未登录用户 请求，重定向至 SSO 认证中心 server（附带客户端地址、clientId、clientSecret，类似授权码认证）； 接收并存储 server 发送的令牌； 请求 server 校验令牌的有效性，若无效则和未登录一样重定向到 server； 建立局部会话； 拦截用户注销请求，向 server 发送注销请求； 接收 server 发出的注销请求，销毁局部会话。 SSO-Server 验证客户端信息，无效则回到客户端； 验证用户的登录信息； 创建全局会话； 创建授权令牌； 重定向回 SSO 客户端 client，并附上令牌； 校验 client 令牌有效性（存在、有效），若有效则将客户端注册到 server（暂存）； 接收 client 注销请求，注销所有会话。 Demo首先是访问 QQ 邮箱，因为没有登录过，所以重定向到了认证服务器： 1234567891011121314151617181920@Overridepublic void doFilter(final ServletRequest servletRequest, final ServletResponse servletResponse, final FilterChain filterChain) throws IOException, ServletException { final HttpServletRequest request = (HttpServletRequest) servletRequest; final HttpServletResponse response = (HttpServletResponse) servletResponse; final HttpSession session = request.getSession(); // 用户登录状态 final Object isLogin = session.getAttribute(&quot;isLogin&quot;); // 已登录，放行 if (isLogin != null) { filterChain.doFilter(request, response); return; } // 未登录，跳转到认证服务器 final String to = String.format(&quot;%s/login?&quot; + &quot;sub_id=%s&quot; + &quot;&amp;&quot; + &quot;sub_secret=%s&quot; + &quot;&amp;&quot; + &quot;service=%s&quot;, this.qqURL, this.subId, this.subSecret, this.localhostURL); response.sendRedirect(to);} 认证服务器向用户提供登录界面： 12345678910111213141516171819202122232425262728293031@GetMapping(&quot;/login&quot;)public String login(@RequestParam(&quot;sub_id&quot;) final String subId, @RequestParam(&quot;sub_secret&quot;) final String subSecret, @RequestParam(&quot;service&quot;) final String service, final ModelMap map, final HttpServletResponse response) throws IOException { // 验证子系统 final String validate = this.validateClient(subId, subSecret); if (validate != null) { response.sendRedirect(service + &quot;?error=&quot; + validate); return null; } final HttpSession session = this.request.getSession(); // 如果之前登录过 final Object isLogin = session.getAttribute(&quot;isLogin&quot;); if (isLogin != null) { // 从 Cookie 中获取 token final String token = CookieUtil.get(this.request, &quot;token&quot;); // 带上 token 重定向回去 response.sendRedirect(service + &quot;?token=&quot; + token); return null; } // 未登录，按正常登录进行 // 记录下请求的子系统地址 session.setAttribute(&quot;service&quot;, service); // 页面变量 map.addAttribute(&quot;username&quot;, this.username); map.addAttribute(&quot;password&quot;, this.password); return &quot;login&quot;;} 用户登录成功，重定向回 QQ 邮箱子系统： 1234567891011121314151617181920212223@PostMapping(&quot;/doLogin&quot;)public ModelAndView doLogin(@RequestParam(&quot;username&quot;) final String username, @RequestParam(&quot;password&quot;) final String password, final HttpServletResponse response) throws IOException { final ModelAndView modelAndView = new ModelAndView(); if (!this.username.equals(username) || !this.password.equals(password)) { modelAndView.setViewName(&quot;/login&quot;); modelAndView.addObject(&quot;alertMsg&quot;, &quot;用户名或密码错误&quot;); return modelAndView; } // 生成 token final String token = UUID.randomUUID().toString(); // 在 Cookie 中设置 token CookieUtil.set(response, &quot;token&quot;, token); // 全局 session final HttpSession session = this.request.getSession(); // 设置用户已登录 session.setAttribute(&quot;isLogin&quot;, true); final String service = session.getAttribute(&quot;service&quot;).toString(); response.sendRedirect(service + &quot;?token=&quot; + token); return null;} 子系统接受回调内容： 12345678910111213141516171819@GetMapping(&quot;/&quot;)public String callback(@RequestParam(value = &quot;token&quot;, required = false) final String token, @RequestParam(value = &quot;error&quot;, required = false) final String error, final HttpServletResponse response, final ModelMap modelMap) { if (!StringUtils.isEmpty(error)) { modelMap.addAttribute(&quot;error&quot;, error); } if (!StringUtils.isEmpty(token) &amp;&amp; StringUtils.isEmpty(error)) { final HttpSession session = this.request.getSession(); // 设置用户已登录 session.setAttribute(&quot;isLogin&quot;, true); // 在 Cookie 中设置 token CookieUtil.set(response, this.tokenCookieName, token); modelMap.addAttribute(this.tokenCookieName, token); } return &quot;index&quot;;} 然后尝试访问 QQ 游戏子系统，可以看到直接就带上了 token，表明用户已经登录： 认证服务器的控制台也显示了，在 QQ 游戏不知道用户是否登录时，重定向到了认证服务器，因为全局 session 设置了 isLogin=true，所以认证服务器直接把 token 带上，重定向回 QQ 游戏，避免了用户二次登录。 总结通过原理和 demo 可以看出，其实单点登录也是利用了 cookie、session，只是进一步分为了全局的，和局部的，分别对应认证服务器和各个子系统。 当子系统不能确认用户登录时，重定向到认证服务器确认： 如果未登录，全局 session 为空或者 isLogin=false，认证服务器提供登录界面，登陆成功就设置认证服务器和浏览器之间的全局 session 中 isLogin=true。 如果登录过，带上 token，重定向回子系统，避免用户重复登录。","link":"/2018/06/27/zh/programing/java/oauth2/oauth2_sso/"},{"title":"Spring OAuth2 SSO","text":"前记项目需要用到 Spring OAuth2 SSO，但是还没使用过，记录下来。 项目包括：UI 站点【常规网站】：admin-ui，admin-ui2网关【Zuul】：gatewayRESTFulAPI 服务 + 认证中心：uac服务发现：eureka 问题： UI 站点用到的某些资源是通过 ajax 请求 uac，如果未登录认证，则无法获取，而且因为是 ajax，无法通过后端直接重定向，只能由前端识别到未登录时进行跳转登录。 RESTFulAPI 是由网关 gateway 进行统一管理的，所以路由到认证中心 uac 时需要记录下请求的地址，不然无法在登录后重定向回去。 admin-ui 登录后，再访问 admin-ui2 时应该能自动登录上，因为实现了 SSO 单点登录。 问题解决： 在请求是 ajax 时，只返回 Json 和未认证的 HttpState，不要返回认证中心的登录页面，之后再由前端自己根据返回的包含认证中心字段的 Json 重定向过去。 认证中心应该放在网关 gateway，这样可以更好管理用户登录认证问题，并且更易从 savedRequest 中获取请求前的地址。 注解内部应该直接实现了，具体还得看运行情况。","link":"/2018/07/13/zh/programing/java/oauth2/spring_oauth2_sso/"},{"title":"Autowired 和 Resource 区别","text":"共同点：装配 Bean，写在字段或 setter 方法上。 @Autowired Spring 的注解，来自 org.springframework.beans.factory.annotation.Autowired 默认按类型装配，也可以使用名称装配，但要配合 @Qualifier 注解。 依赖对象必须存在，如果要允许 null 值，可以设置 @Autowired(required=false) 12345public class TestServiceImpl { @Autowired(required=false) @Qualifier(&quot;userDao&quot;) private UserDao userDao; } @Resource JDK1.6 的注解，来自 javax.annotation.Resource 默认按名称进行装配，通过 name 属性进行指定，不指定时默认使用首字母小写驼峰格式。 12345678910111213public class TestServiceImpl { // 下面两种 @Resource 只要使用一种即可 // 用于字段上 @Resource(name=&quot;userDao&quot;) private UserDao userDao; // 用于 setter 方法上 @Resource(name=&quot;userDao&quot;) public void setUserDao(UserDao userDao) { this.userDao = userDao; }}","link":"/2018/06/18/zh/programing/java/spring/autowired_annotation_and_resource_annotation/"},{"title":"Jetty 部署 SpringBoot","text":"前记项目需要部署到线上，原来都是直接 java -jar 这样运行的，后来才发现服务器的 CPU 占满了，不得不说第一次部署 Java 这么困难。打算用 Tomcat，但是一直启动不了，各种奇怪的原因，无奈换成 Jetty。 下载官网下载地址，这里用的最新版9.4.10.v20180503。 当然还要装 JDK 环境什么的，我这里是 Linux 环境，就不介绍了。 然后把下载包解压放到你喜欢的位置就好了，比如 JETTY_HOME。 SpringBoot 改造首先去除内置的 Tomcat 环境，然后添加 Jetty，将打包方式改为 war： 1234567891011121314151617181920212223&lt;groupId&gt;com.xx&lt;/groupId&gt;&lt;artifactId&gt;xx&lt;/artifactId&gt;&lt;version&gt;xx&lt;/version&gt;&lt;!-- war 打包 --&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt;&lt;!-- 去除 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt;&lt;!-- 添加 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;dependency&gt;&lt;/dependencies&gt; 然后修改 Application： 12345678910111213@SpringBootApplicationpublic class Application extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(final SpringApplicationBuilder builder) { // 注意 Application 是启动类 return builder.sources(Application.class); } public static void main(final String[] args) { SpringApplication.run(Application.class, args); }} 然后在项目下打包（-Dmaven.test.skip=true 忽略测试）： 1mvn clean package -Dmaven.test.skip=true 没有错误信息，BUILD SUCCESS 即成功打包。 部署上面的步骤已经将项目打包到 target 目录下了，比如 xx.war。 将 xx.war 放到刚才下载解压的 Jetty 目录的 JETTY_HOME/webapps 即可（可以在 jetty 运行时直接放进去，会动态检测）。 然后运行 JETTY_HOME 下的 start.jar：java -jar start.jar 或者 bin/jetty.sh：./bin/jetty.sh start 访问 http://localhost:8080/xx/ 即可看到效果。 也可以修改 Jetty 的端口，在 JETTY_HOME/start.ini 下： 1jetty.http.port=9090","link":"/2018/05/27/zh/programing/java/spring/deploy_springboot_on_jetty/"},{"title":"JDBC、Hibernate、MyBatis","text":"JDBC 简介JDBC：Java Data Base Connectivity（Java数据库连接） 它是用于 Java 和数据库之间的数据库无关连接的标准 Java API。即：JDBC 是用于在 Java 中与数据库连接的 API。 JDBC 库包括通常与数据库使用相关，如： 连接到数据库 创建 SQL 语句 在数据库中执行 SQL 查询 查看和修改结果记录 从根本上说，JDBC 是一个规范，它提供了一整套接口，允许以一种可移植的访问底层数据库 API。 Java 可以用它来编写不同类型的可执行文件，如： Java 应用程序 Java Applet Java Servlets Java ServerPages(JSP) 企业级 JavaBeans(EJB) 所有这些不同的可执行文件都能够使用 JDBC 驱动程序来访问数据库，并用于存储数据到数据库中。 JDBC 提供与 ODBC 相同的功能，允许 Java 程序包含与数据库无关的代码（同样的代码，只需要指定使用的数据库类型，不需要重修改数据库查询或操作代码）。 参考资料 Hibernate 简介Hibernate 是一个开源的对象关系映射框架，它对 JDBC 进行非常轻量级的对象封装，所以可以应用在任何使用 JDBC 的场合，使得程序员可以在此基础上使得由原来直接操纵数据库变成直接操作映射数据表后生成的 Java 类，从而用对象编程思维来操纵数据库。 Hibernate 对数据库结构提供了较为完整的封装，Hibernate 的 O/R Mapping 实现了 POJO 和数据库表之间的映射和 SQL 的自动生成、执行。 所以程序员不需要对 SQL 的熟练掌握，只需定义好 POJOs（Plain Old Java Objects，普通 Java 对象） 到数据库表的映射关系，即可通过 Hibernate 提供的方法完成持久层操作，Hibernate/OJB 会根据制定的存储逻辑，自动生成对应的 SQL 并调用 JDBC 接口加以执行。 参考资料 MyBatis 简介MyBatis 同样是一个开源的对象关系映射框架，它支持定制化 SQL、存储过程以及高级映射。避免了 JDBC 代码和手动设置参数以及获取结果集。可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录。 参考资料 各自优缺点JDBC大致编程步骤： 连接数据库，注册驱动和数据库信息。 操作 Connection，打开 Statement 对象。 通过 Statement 对象执行 SQL，返回结果到 ResultSet 对象。 使用 ResultSet 读取数据，然后通过代码转化为具体的 POJO 对象。 关闭数据库相关的资源。 缺点： 工作量大，需要连接，然后处理 JDBC 底层事务，处理数据类型。 需要操作 Connection、Statement、ResultSet 对象去拿数据并关闭它们。 要对 JDBC 可能产生的异常进行捕捉处理并正确关闭资源。 由于 JDBC 存在的缺陷，实际工作中很少直接使用 JDBC，用的更多的是 ORM 对象关系模型来操作数据库，比如 Hibernate 和 Mybatis。 HibernateHibernate 是建立在若干 POJO 通过 xml 映射文件（或注解）提供的规则映射到数据库表上的。 我们可以通过 POJO 直接操作数据库的数据，它提供的是一种全表映射的模型。Hibernate 对 JDBC 的封装程度还是比较高的，我们已经不需要写 SQL，只要使用 HQL 语言就可以了。 优点： 消除了代码的映射规则，把这些规则都分离到了 xml 或注解。 不用再管理数据库连接，它也配置到 xml 里面了。 一个会话中不需要操作多个对象，只需要操作 Session 对象。 关闭资源只需要关闭一个 Session 即可。 大大提高了编程的简易性和可读性。 Hibernate 还提供了级联，缓存，映射，一对多等功能。Hibernate 是全表映射，通过 HQL 去操作 POJO 进而操作数据库的数据。 缺点： 全表映射带来的不便。比如，更新时需要发送所有的字段。 无法根据不同的条件组装不同的 SQL。 对多表关联和复杂的 SQL 查询支持较差，需要自己写 SQL，返回后，需要自己将数据封装为 POJO。 不能有效的支持存储过程。 虽然有 HQL，但是性能较差，大型互联网系统往往需要优化 SQL，而 Hibernate 做不到。 Mybatis为了解决 Hibernate 的不足，Mybatis 出现了，Mybatis 是半自动的框架。之所以称它为半自动，是因为它需要手工匹配提供 POJO，SQL 和映射关系，而全表映射的 Hibernate 只需要提供 POJO 和映射关系即可。 Mybatis 需要提供的映射文件包含了三个部分：SQL，映射规则，POJO。 在 Mybatis 里需要自己编写 SQL，虽然比 Hibernate 配置多，但是 Mybatis 可以配置动态 SQL，解决了 Hibernate 表名根据时间变化，不同条件下列不一样的问题，同时也可以对 SQL 进行优化，通过配置决定你的 SQL 映射规则，也能支持存储过程，所以对于一些复杂和需要优化性能的 SQL 查询它就更加方便。 什么时候使用 Hibernate/MybatisHibernate 作为 Java ORM 框架，编程简易，同时无需编写sql确实开发效率优于Mybatis。此外 Hibernate 还提供了缓存，日志，级联等强大的功能。 但是 Hibernate 的缺陷也是十分明显，多表关联复杂 SQL，数据系统权限限制，根据条件变化的 SQL，存储过程等场景使用 Hibernate 十分不方便，而性能又难以通过 SQL 优化，所以注定了 Hibernate 只适用于在场景不太复杂，要求性能不太苛刻的时候使用。 如果你需要一个灵活的，可以动态生成映射关系的框架，那么 Mybatis 确实是一个最好的选择。它几乎可以替代 JDBC，拥有动态列，动态表名，存储过程支持，同时提供了简易的缓存，日志，级联。但是它的缺陷是需要你提供映射规则和 SQL，所以开发工作量比 Hibernate 要大些。 区别层次JDBC 是较底层的持久层操作方式，而 Hibernate 和 MyBatis 都是在 JDBC 的基础上进行了封装使其更加方便程序员对持久层的操作。 功能JDBC 就是简单的建立数据库连接，然后创建 Statement，将 SQL 语句传给 Statement 去执行，如果是有返回结果的查询语句，会将查询结果放到 ResultSet 对象中，通过对 ResultSet 对象的遍历操作来获取数据。 Hibernate 是将数据库中的数据表映射为持久层的 Java 对象，对 SQL 语句进行修改和优化比较困难。 MyBatis 是将 SQL 语句中的输入参数和输出参数映射为 Java 对象，SQL 修改和优化比较方便。 使用如果进行底层编程，而且对性能要求极高的话，应该采用 JDBC 的方式。 如果要对数据库进行完整性控制的话建议使用 Hibernate。 如果要灵活使用 SQL 语句的话建议采用 MyBatis 框架。","link":"/2018/03/19/zh/programing/java/spring/jdbc_hibernate_mybatis/"},{"title":"获取 request 及其线程安全性分析","text":"原文Spring中获取request的几种方法，及其线程安全性分析 前言本文将介绍在使用 Spring MVC 开发中，获取 request 对象的几种方法，并讨论其线程安全性。 概述在使用 Spring MVC 开发 Web 系统时，经常需要在处理请求时使用 request 对象。比如：获取客户端 IP 地址、请求的 URL、header 中的属性（Cookie、授权信息）、body 中的数据等。 由于在 Spring MVC 中，处理请求的 Controller、Service 等对象都是单例的，因此获取 request 对象时最需要注意的问题，便是 request 对象是否线程安全：当有大量并发请求时，能否保证不同请求/线程中使用不同的 request 对象。 注意事项前面所说的“在处理请求时”使用 request 对象，大体是在两类地方使用： 在 Spring 的 Bean 中使用 request 对象：既包括 Controller、Service、Repository 等 MVC 的 Bean，也包括了 Component 等普通的 Spring Bean。为了方便说明，本文中 Spring 中的 Bean 一律简称为Bean。 在非 Bean 中使用 request 对象：如普通的 Java 对象的方法中使用，或在类的静态方法中使用。 本文讨论是围绕代表请求的 request 对象展开的，但所用方法同样适用于 response 对象、InputStream/Reader、OutputStream/ Writer 等；其中 InputStream/Reader 可以读取请求中的数据，OutputStream/Writer 可以向响应写入数据。 最后，获取 request 对象的方法与 Spring 及 MVC 的版本也有关系；本文基于 Spring4 进行讨论，且所做的实验都是使用4.1.1版本。 如何测试线程安全性测试的基本思路：模拟客户端大量并发请求，然后在服务器判断这些请求是否使用了相同的 request 对象，最直观的方式是打印出 request 对象的地址，如果相同则说明使用了相同的对象。 存在的问题：在几乎所有 Web 服务器的实现中，都使用了线程池，这样就导致先后到达的两个请求，可能由同一个线程处理。在前一个请求处理完成后，线程池收回该线程，并将该线程重新分配给了后面的请求。而在同一线程中，使用的 request 对象很可能是同一个（地址相同，属性不同）。因此即便是对于线程安全的方法，不同的请求使用的 request 对象地址也可能相同。 为了避免上面的问题，有两种办法： 在请求处理过程中使线程休眠几秒，这样可以让每个线程工作的时间足够长，从而避免同一个线程分配给不同的请求。 使用 request 的其他属性（如参数、header、body等）作为 request 是否线程安全的依据，因为即便不同的请求先后使用了同一个线程（request 对象地址也相同），只要使用不同的属性分别构造了两次 request 对象，那么 request 对象的使用就是线程安全的。 本文使用第二种方法进行测试。 客户端测试代码（创建1000个线程分别发送请求）： 1234567891011121314151617181920212223public class Test { public static void main(String[] args) throws Exception { // 前缀 String prefix = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + &quot;::&quot;; // 启动1000个线程发送请求 for (int i = 0; i &lt; 1000; i++) { final String value = prefix + i; new Thread() { @Override public void run() { try { CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/test?key=&quot; + value); httpClient.execute(httpGet); httpClient.close(); } catch (IOException e) { e.printStackTrace(); } } }.start(); } }} 服务器中 Controller 代码（暂时省略了获取request对象的代码）： 123456789101112131415161718192021222324@Controllerpublic class TestController { // 存储已有参数，用于判断参数是否重复，从而判断线程是否安全 public static Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;&gt;(); @RequestMapping(&quot;/test&quot;) public void test() throws InterruptedException { // …………………………通过某种方式获得了request对象……………………………… String value = request.getParameter(&quot;key&quot;); // 判断线程安全 if (set.contains(value)) { System.out.println(value + &quot;\\t重复出现，request 并发不安全！&quot;); } else { System.out.println(value); set.add(value); } // 模拟程序执行了一段时间 Thread.sleep(1000); }} Controller 参数12345678@Controllerpublic class TestController { @RequestMapping(&quot;/test&quot;) public void test(HttpServletRequest request) throws InterruptedException { // 模拟程序执行了一段时间 Thread.sleep(1000); }} 该方法实现的原理：Controller 方法开始处理请求时，Spring 会将 request 对象赋值到方法参数中。 除了 request 对象，可以通过这种方法获取的参数还有很多：https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods 线程安全性 测试结果：线程安全 分析：此时 request 对象是方法参数，相当于局部变量，毫无疑问是线程安全的。 缺点 request 对象冗余，如果多个 Controller 方法中都需要 request 对象，那么在每个方法中都需要添加一遍 request 参数。 request 对象的获取只能从 Controller 开始，如果使用 request 对象的地方在函数调用层级比较深的地方，那么整个调用链上的所有方法都需要添加 request 参数。 实际上，在整个请求处理的过程中，request 对象是贯穿始终的；也就是说，除了定时器等特殊情况，request 对象相当于线程内部的一个全局变量。而该方法，相当于将这个全局变量，传来传去。 自动注入123456789101112@Controllerpublic class TestController{ // 自动注入request @Autowired private HttpServletRequest request; @RequestMapping(&quot;/test&quot;) public void test() throws InterruptedException{ // 模拟程序执行了一段时间 Thread.sleep(1000); }} 线程安全性 测试结果：线程安全 分析：在 Spring 中，Controller 的 scope 是 singleton（单例），也就是说在整个 Web 中，只有一个 TestController；但是其中注入的 request 却是线程安全的，原因：使用这种方式，当 Bean（TestController）初始化时，Spring 并没有注入一个 request 对象，而是注入了一个 proxy（代理）；当 Bean 中需要使用 request 对象时，通过该代理获取 request 对象。 通过具体的代码对这一实现进行说明，在上述代码中加入断点，查看 request 对象的属性： 可以看出 request 实际上是一个代理：代理的实现参见 AutowireUtils 的内部类 ObjectFactoryDelegatingInvocationHandler： 123456789101112131415161718192021/** * Reflective InvocationHandler for lazy access to the current target object. */private static class ObjectFactoryDelegatingInvocationHandler implements InvocationHandler, Serializable { private final ObjectFactory&lt;?&gt; objectFactory; public ObjectFactoryDelegatingInvocationHandler(ObjectFactory&lt;?&gt; objectFactory) { this.objectFactory = objectFactory; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // …… try { // 代理实现核心代码 return method.invoke(this.objectFactory.getObject(), args); } catch (InvocationTargetException ex) { throw ex.getTargetException(); } }} 可以看出实际上是调用 objectFactory.getObject() 生成的 request 对象。 继续观察上图发现 objectFactory 的类型为 WebApplicationContextUtils 的内部类 RequestObjectFactory： 12345678910111213/** * Factory that exposes the current request object on demand. */private static class RequestObjectFactory implements ObjectFactory&lt;ServletRequest&gt;, Serializable { @Override public ServletRequest getObject() { return currentRequestAttributes().getRequest(); } @Override public String toString() { return &quot;Current HttpServletRequest&quot;; }} 其中，要获得 request 对象需要先调用 currentRequestAttributes() 方法获得 RequestAttributes 对象： 12345678910/** * Return the current RequestAttributes instance as ServletRequestAttributes. */private static ServletRequestAttributes currentRequestAttributes() { RequestAttributes requestAttr = RequestContextHolder.currentRequestAttributes(); if (!(requestAttr instanceof ServletRequestAttributes)) { throw new IllegalStateException(&quot;Current request is not a servlet request&quot;); } return (ServletRequestAttributes) requestAttr;} 生成 RequestAttributes 对象的核心代码在类 RequestContextHolder 类： 123456789101112131415161718public abstract class RequestContextHolder { public static RequestAttributes currentRequestAttributes() throws IllegalStateException { RequestAttributes attributes = getRequestAttributes(); // ………… return attributes; } public static RequestAttributes getRequestAttributes() { RequestAttributes attributes = requestAttributesHolder.get(); if (attributes == null) { attributes = inheritableRequestAttributesHolder.get(); } return attributes; } private static final ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder = new NamedThreadLocal&lt;RequestAttributes&gt;(&quot;Request attributes&quot;); private static final ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder = new NamedInheritableThreadLocal&lt;RequestAttributes&gt;(&quot;Request context&quot;);} 可以看出，生成的 RequestAttributes 对象是线程局部变量（ThreadLocal），因此 request 对象也是线程局部变量，这就保证了 request 对象的线程安全性。 优点 减少代码冗余。（当然如果每个 Controller 都需要的话还是很冗余） 注入不限于 Controller，还可以在任何 Bean 中注入，包括 Service、Repository 及普通的 Bean。 注入的对象不限于 request，还可以注入其他 scope 为 request 或 session 的对象，如 response 对象、session 对象等。 基类中自动注入与自动注入相比，将注入部分代码放入到了基类： 1234public class BaseController { @Autowired protected HttpServletRequest request; } BaseController 的两个派生类（同时测试代码需要修改为向2个 URL 发送大量并发请求）： 12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class TestController extends BaseController { // 存储已有参数，用于判断参数value是否重复，从而判断线程是否安全 public static Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;&gt;(); @RequestMapping(&quot;/test&quot;) public void test() throws InterruptedException { String value = request.getParameter(&quot;key&quot;); // 判断线程安全 if (set.contains(value)) { System.out.println(value + &quot;\\t重复出现，request并发不安全！&quot;); } else { System.out.println(value); set.add(value); } // 模拟程序执行了一段时间 Thread.sleep(1000); }} @Controllerpublic class Test2Controller extends BaseController { @RequestMapping(&quot;/test2&quot;) public void test2() throws InterruptedException { String value = request.getParameter(&quot;key&quot;); // 判断线程安全（与TestController使用一个set进行判断） if (TestController.set.contains(value)) { System.out.println(value + &quot;\\t重复出现，request并发不安全！&quot;); } else { System.out.println(value); TestController.set.add(value); } // 模拟程序执行了一段时间 Thread.sleep(1000); }} 线程安全性 测试结果：线程安全 分析：当创建不同的派生类对象时，基类中的域（这里是注入的 request）在不同的派生类对象中会占据不同的内存空间，也就是说将注入 request 的代码放在基类中对线程安全性没有任何影响。 优点 和自动注入一样，但避免了在不同的 Controller 中重复注入 request。 缺点 单继承的缺点。 手动调用123456789@Controllerpublic class TestController { @RequestMapping(&quot;/test&quot;) public void test() throws InterruptedException { HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest(); // 模拟程序执行了一段时间 Thread.sleep(1000); }} 线程安全性 测试结果：线程安全 分析：与自动注入类似，只不过本方法通过手动方法调用实现。 优点 可以在非 Bean 中直接获取。 缺点 如果使用的地方较多，代码非常繁琐；因此可以与其他方法配合使用。 @ModelAttribute下面这种方法及其变种（变种：将 request 和 bindRequest 放在子类中）在网上经常见到： 12345678910111213@Controllerpublic class TestController { private HttpServletRequest request; @ModelAttribute public void bindRequest(HttpServletRequest request) { this.request = request; } @RequestMapping(&quot;/test&quot;) public void test() throws InterruptedException { // 模拟程序执行了一段时间 Thread.sleep(1000); }} @ModelAttribute 注解在 Controller 方法中作用：Controller 中的每个 @RequestMapping 方法执行前，该方法都会执行。 线程安全性 测试结果：线程不安全 分析：虽然 bindRequest() 中的参数 request 本身是线程安全的，但由于 TestController 是单例的，request 作为 TestController 的一个域，无法保证线程安全。","link":"/2018/07/25/zh/programing/java/spring/request_and_its_thread_safety_analysis/"},{"title":"Spring 和 SpringBoot","text":"SpringSpring 框架简介 简介Spring 是一个为了解决企业应用程序开发复杂性而创建的开源框架。它的主要优势之一就是分层架构，允许你选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式： 模块组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。 核心容器核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 Spring DAOJDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORMSpring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map，所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文，所以 Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象，所以这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。 IOCIOC：Inversion of Control（控制反转） 基本概念：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。 AOPAOP：Aspect Oriented Programming（面向切面编程） AOP 是 OOP 的有力补充：OOP 将程序分成各个层次的对象，AOP 将运行过程分解成各个切面。AOP 是从运行程序的角度去考虑程序的结构，提取业务处理过程的切面，OOP 是静态的抽象，AOP 是动态的抽象，是对应用执行过程的步骤进行抽象，从而获得步骤之间的逻辑划分。 AOP 和 IOC 是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的 OOP 开发方式中，可能要将日志记录语句放在所有方法和 Java 类中才能实现日志功能。在 AOP 方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是 Java 类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用 Spring AOP 编写的应用程序代码是松散耦合的。 AOP 的功能完全集成到了 Spring 事务管理、日志和其他各种特性的上下文中。 优点 使用 Spring 的 IOC 容器，将对象之间的依赖关系交给 Spring，降低组件之间的耦合性，让我们更专注于应用逻辑。 可以提供众多服务，事务管理，WS 等。 AOP 的很好支持，方便面向切面编程。 对主流的框架提供了很好的集成支持，如 Hibernate,Struts2,JPA 等 Spring 低侵入，代码污染极低。 Spring 的高度可开放性，并不强制依赖于 Spring，开发者可以自由选择 Spring 部分或全部 SpringBootSpringBoot 实现了自动配置，降低了项目搭建的复杂度。 Spring 框架需要进行大量的配置，SpringBoot 引入自动配置的概念，让项目设置变得很容易。SpringBoot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。 同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，SpringBoot 应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的 SpringBoot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 SpringBoot 只是承载者，辅助你简化项目搭建过程的。如果承载的是 WEB 项目，使用 Spring MVC 作为 MVC 框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是 Spring MVC 做的而不是 SpringBoot。 对使用者来说，换用 SpringBoot 以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装 Tomcat 这类容器服务器了，maven 打出 jar 包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。 所以，用最简练的语言概括就是： Spring 是一个“引擎”； Spring MVC 是基于 Spring 的一个 MVC 框架 ； SpringBoot 是基于 Spring4 的条件注册的一套快速开发整合包。","link":"/2018/03/19/zh/programing/java/spring/spring_and_springboot/"},{"title":"事务注解","text":"什么是事务在使用应用软件过程中，用户的一个操作实际是对数据读写的多步操作的结合。 由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。 Spring 事务事务有两种实现方式：编程式事务管理、声明式事务管理。 编程式事务管理：使用 TransactionTemplate 或直接使用底层的 PlatformTransactionManager。 声明式事务管理：建立在 AOP 上。其本质是对方法前后进行拦截，然后在目标方法开始前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 对于编程式事务管理，Spring 推荐使用 TransactionTemplate。 声明式事务管理不需要入侵代码，通过注解 @Transactional 就可以进行事务操作，更快捷而且简单。 声明式事务有两种使用方式： 基于 XML 的声明式事务 基于注解的声明式事务 使用方式在 SpringBoot 中，当我们使用了 spring-boot-starter-jdbc 或 spring-boot-starter-data-jpa 依赖的时候，框架会自动注入 DataSourceTransactionManager 或 JpaTransactionManager，使用时只需要在函数上增加 @Transactional 注解。 @Transactional 可以注解在接口 interface、接口方法 interface method、类 class、类方法 class method。 当注解在类 class 时，该类所有 public 方法将都具有该类型的事务属性，也可以在方法上注解来覆盖类级别的事务注解。 通常在 Service 层和 Controller 层使用。 举个栗子，在 Controller 层增加事务： 1234567891011121314151617@Autowiredprivate UserService userService;@ApiOperation(value = &quot;根据Id删除用户&quot;)@ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户Id&quot;, required = true, dataType = &quot;Integer&quot;)@DeleteMapping(&quot;/{id}&quot;)@ResponseBody@Transactionalpublic JsonBean&lt;User&gt; deleteUser(@PathVariable final Integer id) { try { this.userService.deleteById(id); return new JsonBean(SUCCESS, null); } catch (ErrorCodeException e) { TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); return new JsonBean(e.getErrorCode()); }} 声明式事务管理，默认回滚 unchecked 异常，即默认对 RuntimeException 异常或是其子类进行事务回滚。checked 异常，即可以通过 catch 捕获的异常不会回滚。 如果希望捕获异常后，进行回滚： 1TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 也可以通过设置回滚点，回滚到某一状态： 123Object savePoint = TransactionAspectSupport.currentTransactionStatus().createSavepoint();...TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint); 常用属性readOnly设置当前事务是否为只读事务：true 只读，false 可读写，默认 false。 @Transactional(readOnly = true) rollbackFor设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。 指定单一异常类：@Transactional(rollbackFor = RuntimeException.class)指定多个异常类：@Transactional(rollbackFor = {RuntimeException.class, Exception.class}) rollbackForClassName设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。 指定单一异常类名称：@Transactional(rollbackForClassName = &quot;RuntimeException&quot;)指定多个异常类名称：@Transactional(rollbackForClassName = {&quot;RuntimeException&quot;, &quot;Exception&quot;}) noRollbackFor设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。 指定单一异常类：@Transactional(noRollbackFor = RuntimeException.class)指定多个异常类：@Transactional(noRollbackFor = {RuntimeException.class, Exception.class}) noRollbackForClassName设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。 指定单一异常类名称：@Transactional(noRollbackForClassName = &quot;RuntimeException&quot;)指定多个异常类名称：@Transactional(noRollbackForClassName = {&quot;RuntimeException&quot;, &quot;Exception&quot;}) propagation设置事务的传播行为。（如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为） REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED。 @Transactional(propagation = Propagation.REQUIRED) isolation设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况。 DEFAULT：默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。READ_UNCOMMITTED：表示一个事务可以读取另一个事务修改但还没有提交的数据。（不能防止脏读和不可重复读）READ_COMMITTED：表示一个事务只能读取另一个事务已经提交的数据。（可以防止脏读）REPEATABLE_READ：表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。（可以防止脏读和不可重复读）SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。通常情况下不会使用，因为这将严重影响程序的性能。（可以防止脏读、不可重复读以及幻读） @Transactional(isolation = Isolation.DEFAULT) timeout设置事务的超时秒数，默认为 -1 表示永不超时。 一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是 none，没有超时限制。","link":"/2018/03/19/zh/programing/java/spring/transaction_annotation/"},{"title":"SpringCloud 笔记1","text":"前记最近的任务是学习 Sping Cloud，这期间将完成从概念到 Demo 的搭建。 所有代码：GitHub 本章主要是介绍部署的方式和 SpringCloud 的一些概念。 蓝绿部署、A/B测试、灰度发布蓝绿部署 蓝绿部署是一种以可预测的方式发布应用的技术，目的是减少发布过程中服务停止的时间。 简单来说，你需要准备两个相同的环境（基础架构），在蓝色环境运行当前生产环境中的应用，也就是旧版本应用，如图中 App1 version1、App2 version1、App3 version3。 当你想要升级 App2 到 version2，在蓝色环境中进行操作，即部署新版本应用，并进行测试。如果测试没问题，就可以把负载均衡器／反向代理／路由指向蓝色环境了。 随后你需要监测新版本应用，也就是 App2 version2 是否有故障和异常。如果运行良好，就可以删除 App2 version1 使用的资源。如果运行出现了问题，你可以通过负载均衡器指向快速回滚到绿色环境。 理论上听起来很棒，但还是要注意一些细节： 当你切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果你的数据库后端无法处理，会是一个比较麻烦的问题； 有可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能导致服务停止的； 需要提前考虑数据库与应用部署同步迁移/回滚的问题； 蓝绿部署需要有基础设施支持； 在非隔离基础架构（VM、Docker等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。 A/B测试 A/B测试跟蓝绿部署完全是两码事。 A/B测试是用来测试应用功能表现的方法，例如可用性、受欢迎程度、可见性等等。A/B测试通常用在应用的前端上，不过当然需要后端来支持。 A/B测试与蓝绿部署的区别在于，A/B测试目的在于通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信该结论在推广到全部流量可信；蓝绿部署的目的是安全稳定地发布新版本应用，并在必要时回滚。 A/B测试和蓝绿部署可以同时使用。 灰度发布／金丝雀发布 灰度发布是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”（金丝雀对瓦斯极敏感，矿井工人携带金丝雀，以便及时发现危险），测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。 灰度发布／金丝雀发布由以下几个步骤组成： 准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。 从负载均衡列表中移除掉“金丝雀”服务器。 升级“金丝雀”应用（排掉原有流量并进行部署）。 对应用进行自动化测试。 将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。 如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚）。 SpringCloudSpringCloud 是一系列框架的有序集合。它利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 SpringBoot 的开发风格做到一键启动和部署。Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 SpringBoot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，SpringCloud 就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，SpringCloud 做为大管家需要管理好这些微服务，自然需要很多工具框架来帮忙。 SpringCloud 的核心功能：分布式/版本化配置、服务注册和发现、路由、服务和服务之间的调用、负载均衡、断路器、分布式消息传递。 各组件配置使用运行流程： 请求统一通过API网关（Zuul）来访问内部服务 网关接收到请求后，从注册中心（Eureka）获取可用服务 由 Ribbon 进行均衡负载后，分发到后端具体实例 微服务之间通过Feign进行通信处理业务 Hystrix 负责处理服务超时熔断 Turbine 监控服务间的调用和熔断相关指标 上图只是 SpringCloud 体系的一部分，SpringCloud 共集成了19个子项目，里面都包含一个或者多个第三方的组件或者框架！ SpringCloud 工具框架 SpringCloud Config 配置中心，利用 Git 集中管理程序的配置。 SpringCloud Netflix 集成众多 Netflix 的开源软件。 SpringCloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化。 SpringCloud for Cloud Foundry 利用 Pivotal Cloudfoundry 集成你的应用程序。 SpringCloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。 SpringCloud Cluster 基于 Zookeeper, Redis, Hazelcast, Consul 实现的领导选举和平民状态模式的抽象和实现。 SpringCloud Consul 基于 Hashicorp Consul 实现的服务发现和配置管理。 SpringCloud Security 在 Zuul 代理中为 OAuth2 rest 客户端和认证头转发提供负载均衡。 SpringCloud Sleuth SpringCloud 应用的分布式追踪系统，和 Zipkin，HTrace，ELK 兼容。 SpringCloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。 SpringCloud Stream 基于 Redis,Rabbit,Kafka 实现的消息微服务，简单声明模型用以在 SpringCloud 应用中收发消息。 SpringCloud Stream App Starters 基于 SpringBoot 为外部系统提供 Spring 的集成。 SpringCloud Task 短生命周期的微服务，为 SpringBoot 应用简单声明添加功能和非功能特性。 SpringCloud Task App Starters SpringCloud Zookeeper 服务发现和配置管理基于 Apache Zookeeper。 SpringCloud for Amazon Web Services 快速和亚马逊网络服务集成。 SpringCloud Connectors 便于 PaaS 应用在各种平台上连接到后端像数据库和消息经纪服务。 SpringCloud Starters （项目已经终止并且在 Angel.SR2 后的版本和其他项目合并）。 SpringCloud CLI 插件用 Groovy 快速的创建 SpringCloud 组件应用。 当然这个数量还在一直增加… 微服务/SpringBoot/SpringCloud 三者之间的关系 微服务是一种架构的理念，提出了微服务的设计原则，从理论为具体的技术落地提供了指导思想。 SpringBoot 是一套快速配置脚手架，可以基于 SpringBoot 快速开发单个微服务 SpringCloud 是一个基于 SpringBoot 实现的服务治理工具包SpringBoot 专注于快速、方便集成的单个微服务个体，SpringCloud 关注全局的服务治理框架。 如何进行微服务架构演进当我们将所有的新业务都使用SpringCloud这套架构之后，就会出现这样一个现象，公司的系统被分成了两部分，一部分是传统架构的项目，一部分是微服务架构的项目，如何让这两套配合起来使用就成为了关键，这时候 SpringCloud 里面的一个关键组件解决了我们的问题，就是 Zuul。在 SpringCloud 架构体系内的所有微服务都通过 Zuul 来对外提供统一的访问入口，所有需要和微服务架构内部服务进行通讯的请求都走统一网关。如下图： 从上图可以看出我们对服务进行了分类：基础服务、业务服务、前置服务、组合服务。由上到下优先级逐步降低。 基础服务：是一些基础组件，与具体的业务无关。比如：短信服务、邮件服务。这里的服务最容易摘出来做微服务，也是我们第一优先级分离出来的服务。 业务服务：是一些垂直的业务系统，只处理单一的业务类型，比如：风控系统、积分系统、合同系统。这类服务职责比较单一，根据业务情况来选择是否迁移，比如：如果突然有需求对积分系统进行大优化，我们就趁机将积分系统进行改造，是我们的第二优先级分离出来的服务。 前置服务：前置服务一般为服务的接入或者输出服务，比如网站的前端服务、APP 的服务接口这类，这是我们第三优先级分离出来的服务。 组合服务：组合服务就是涉及到了具体的业务，比如买标过程，需要调用很多垂直的业务服务，这类的服务我们一般放到最后再进行微服务化架构来改造，因为这类服务最为复杂，除非涉及到大的业务逻辑变更，我们是不会轻易进行迁移。 在这四类服务之外，新上线的业务全部使用 Sprng Boot/Cloud 这套技术栈。就这样，我们从开源项目云收藏开始，上线几个 SpringBoot 项目，到现在公司绝大部分的项目都是在 SpringCloud 这个架构体系中。 经验和教训架构演化的步骤： 在确定使用 SpringBoot/Cloud 这套技术栈进行微服务改造之前，先梳理平台的服务，对不同的服务进行分类，以确认演化的节奏。 先让团队熟悉 SpringBoot 技术，并且优先在基础服务上进行技术改造，推动改动后的项目投产上线。 当团队熟悉 SpringBoot 之后，再推进使用 SpringCloud 对原有的项目进行改造。 在进行微服务改造过程中，优先应用于新业务系统，前期可以只是少量的项目进行了微服务化改造，随着大家对技术的熟悉度增加，可以加快加大微服务改造的范围 传统项目和微服务项目共存是一个很常见的情况，除非公司业务有大的变化，不建议直接迁移核心项目。 服务拆分原则 横向拆分。按照不同的业务域进行拆分，例如订单、营销、风控、积分资源等。形成独立的业务领域微服务集群。 纵向拆分。把一个业务功能里的不同模块或者组件进行拆分。例如把公共组件拆分成独立的原子服务，下沉到底层，形成相对独立的原子服务层。这样一纵一横，就可以实现业务的服务化拆分。 要做好微服务的分层：梳理和抽取核心应用、公共应用，作为独立的服务下沉到核心和公共能力层，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求 服务拆分是越小越好吗？微服务的大与小是相对的。比如在初期，我们把交易拆分为一个微服务，但是随着业务量的增大，可能一个交易系统已经慢慢变得很大，并且并发流量也不小，为了支撑更多的交易量，我会把交易系统，拆分为订单服务、投标服务、转让服务等。因此微服务的拆分力度需与具体业务相结合，总的原则是服务内部高内聚，服务之间低耦合。 微服务vs传统开发使用微服务有一段时间了，这种开发模式和传统的开发模式对比，有很大的不同。 分工不同，以前我们可能是一个一个模块，现在可能是一人一个系统。 架构不同，服务的拆分是一个技术含量很高的问题，拆分是否合理对以后发展影响巨大。 部署方式不同，如果还像以前一样部署估计累死了，自动化运维不可不上。 容灾不同，好的微服务可以隔离故障避免服务整体 Down 掉，坏的微服务设计仍然可以因为一个子服务出现问题导致连锁反应。 给数据库带来的挑战每个微服务都有自己独立的数据库，那么后台管理的联合查询怎么处理？这应该是大家会普遍遇到的一个问题，有三种处理方案。 严格按照微服务的划分来做，微服务相互独立，各微服务数据库也独立，后台需要展示数据时，调用各微服务的接口来获取对应的数据，再进行数据处理后展示出来，这是标准的用法，也是最麻烦的用法。 将业务高度相关的表放到一个库中，将业务关系不是很紧密的表严格按照微服务模式来拆分，这样既可以使用微服务，也避免了数据库分散导致后台系统统计功能难以实现，是一个折中的方案。 数据库严格按照微服务的要求来切分，以满足业务高并发，实时或者准实时将各微服务数据库数据同步到 NoSQL 数据库中，在同步的过程中进行数据清洗，用来满足后台业务系统的使用，推荐使用 MongoDB、HBase 等。 三种方案在不同的公司我都使用过，第一种方案适合业务较为简单的小公司；第二种方案，适合在原有系统之上，慢慢演化为微服务架构的公司；第三种适合大型高并发的互联网公司。 微服务的经验和建议建议尽量不要使用Jsp 页面开发推荐使用 Thymeleaf。Web 项目建议独立部署 Tomcat，不要使用内嵌的 Tomcat，内嵌 Tomcat 部署 JSP 项目会偶现龟速访问的情况。 服务编排 主要的作用是减少项目中的相互依赖。 A -&gt; B -&gt; C -&gt; …… -&gt; H 比如现在有项目A调用项目 B，项目B调用项目 C …一直到 H，是一个调用链，那么项目上线的时候需要先更新最底层的 H 再更新 G … 更新 C 更新 B 最后是更新项目 A。这只是这一个调用链，在复杂的业务中有非常多的调用，如果要记住每一个调用链对开发运维人员来说就是灾难。 改善：尽量的减少项目的相互依赖，就是服务编排，一个核心的业务处理项目，负责和各个微服务打交道。 比如之前是 A 调用 B，B 掉用 C，C 调用 D，现在统一在一个核心项目 W 中来处理，W 服务使用 A 的时候去调用B，使用 B 的时候 W 去调用 C，举个例子：在第三方支付业务中，有一个核心支付项目是服务编排，负责处理支付的业务逻辑，W 项目使用商户信息的时候就去调用“商户系统”，需要校验设备的时候就去调用“终端系统”，需要风控的时候就调用“风控系统”，各个项目需要的依赖参数都由 W 来做主控。以后项目部署的时候，只需要最后启动服务编排项目即可。 不要为了追求技术而追求技术 确定进行微服务架构改造之前，需要考虑以下几方面的因素： 团队的技术人员是否已经具备相关技术基础。 公司业务是否适合进行微服务化改造，并不是所有的平台都适合进行微服务化改造，比如：传统行业有很多复杂垂直的业务系统。 SpringCloud 生态的技术有很多，并不是每一种技术方案都需要用上，适合自己的才是最好的。 详细的10种组件介绍springcloud config 远程配置服务。 远程配置是每个都必不可少的中间件，远程配置的特点一般需要：多节点主备、配置化、动态修改、配置本地化缓存、动态修改的实时推送等。Config 允许配置文件放在 Git 上或者 SVN 上，和 SpringBoot 的集成非常容易，但是缺点就是修改了 Git 上的配置以后，只能一个一个的请求每个 Service 的接口，让他们去更新配置，没有修改配置的推送消息。而且，如果要根据配置文件的修改，做一些重新初始化操作的话(如线程池的容量变化等)，会需要一些 Work around的方法，所以建议如果有其他方案，不建议选择 SpringCloud Config。 SpringCloud Bus 事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化。经常与 SpringCloud Config 联合使用。 SpringCloud Config本身不能向注册过来的服务提供实时更新的推送。比如我们配置放在了 Git 上，那么当修改github上配置内容的时候，最多可以配置 Webhook 到一台 Config-server 上，但是 Config-server 自己不会将配置更新实时推送到各个服务上。bus 的作用就是将大家链接在一条总线上，这条线上的所有 Server 共享状态，当 Webhook 到 Bus 上的某一台 Server 的时候，其他 Server 也会收到相同的 hook 状态。但是 Bus的使用需要依赖于 MQ，Bus 直接继承了 RabbitMq &amp; kafka，只需要在 Spring中直接配置地址即可，但是对于其他类型的 MQ，就需要一些手动配置。最大的问题还是，如果仅仅因为 SpringCloud Bus而让自己的系统引入 MQ，显然会有些得不偿失。我理解系统应该在满足现有业务需求的基础上，越简单越好，依赖越少链路越短，越能减少出问题的风险。 Eureka springcloud 的服务发现组件。这个组件讲起来需要大篇幅，最好和 consul 一起讲。 eureka 负责服务注册和服务发现，为了高可用，一般需要多个 eureka server 相互注册，组成集群。Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。eureka 内部对于注册的 service 主要通过心跳来监控 service 是否已经挂掉，默认心跳时间是15s。这就意味着，当一个服务提供方挂掉以后，服务订阅者最长可能30s以后才发现。service 启动连上 eureka 之后，会同步一份服务列表到本地缓存，服务注册有更新时，eureka 会推送到每个 service。eureka 也会有一些策略防止由于某个服务所在网络的不稳定导致的所有服务心跳停止的雪崩现象。eureka 自带web页面，在页面上能看到所有的服务注册情况 和 eureka 集群状态。eureka 支持服务自己主动下掉自己，请求 service 的下列地址，可以让服务从 eureka 上下掉自己，同时 service 进程也会自己停掉自己。curl -H ‘Accept:application/json’ -X POST localhost:${management.port}/shutdown Consul 也是一个服务发现工具，而且自带 key-value 存储服务、健康检查 和 Web 页面。 听起来好像比 Eureka 高大上一些，里面使用了 Gossip 协议和 Raft 协议，但是他的缺点就是比 Eureka 难维护。服务注册是微服务架构的关键节点。所以我们现阶段选择的是eureka，然后远程配置使用的是 SpringCloud config。如果要上容器和编排的话，会再看具体情况做选择。但是，后来发现其实 Consul 提供了官方的 Docker 镜像，直接使用 Docker-consul 集群用户服务发现的话，运维成本会直线下降，后面会考虑把 Eureka + SpringCloud Config 换成 Consul。 Ribbon 客户端负载均衡组件。 服务发现以后，每个 Service 在本地知道自己要调用的服务有多少台机器，机器的ip是什么，端口号是多少，那这个 Service 在本地需要有一个负载均衡策略，为每一次请求选择一台目标机器进行调用，而ribbon做的就是负载均衡策略的选择。 Ribbon 提供了多种负载均衡策略，包括 BestAvailableRule、AvailabilityFilteringRule、WeightedResponseTimeRule、RetryRule、RoundRobinRule、RandomRule、ZoneAvoidanceRule等，没记错的话，默认是ZoneAvoidanceRule。当然，也可以自定义自己的负载均衡策略，比如被调用服务需要灰度发布或者 A/B 测试的话，就可以在ribbon这一层做自定义。 Feign 声明式、模板化的 HTTP 客户端。 微服务之间的调用本质还是 HTTP 请求，如果对于每个请求都需要写请求代码，增加请求参数，同时对请求结果做处理，就会存在大量重复工作，而feign非常优雅的帮助我们解决了这个问题，只需要定义一个 interface， Fegin 就知道 HTTP 请求的时候参数应该如何设置。同时，Feign 也集成了 Ribbon，只要在微服务中依赖了 Ribbon，feign默认会使用ribbon定义的负载均衡策略。最重要的是，Feign并不是仅仅只能使用在有 Eureka 或者 Ribbon 的微服务系统中，任何系统中，只要涉及到http调用第三方服务，都可以使用 Feign，帮我们解决http请求的代码重复编写。 Hystrix 断路器，类似于物理电路图中的断路器。 正常情况下，当整个服务环境中，某一个服务提供方由于网络原因、数据库原因或者性能原因等，造成响应很慢的话，调用方就有可能短时间内累计大量的请求线程，最终造成调用方 Down，甚至整个系统崩溃。而加入 Hystrix 之后，如果 Hystrix 发现某个服务的某台机器调用非常缓慢或者多次调用失败，就会短时间内把这条路断掉，所有的请求都不会再发到这台机器上。如果某个服务所有的机器都挂了，Hystrix 会迅速失败，马上返回，保证被调用方不会有大量的线程堆积。Feign 默认集成了 Hystrix。上面有提到，使用 Eureka 时，当一个服务提供方挂掉以后，服务订阅者最长可能30s以后才知道，那这30s就会出现大量的调用失败。如果在系统里面集成了 Hystrix，就会马上把挂掉的这台服务提供方断路掉，让请求不再转发到这台机器上，大量减少调用失败。 Hystrix 执行断路操作以后，并不表示这条路就永远断了，而是会一定时间间隔内缓慢尝试去请求这条路，如果能请求成功，断路就会恢复。有一点需要注意的是 Hystrix 在做断路时，默认所有的调用请求都会放在一个的线程池中进行，线程池的作用很明显，有隔离性。比如 Gateway，集成了5个子业务系统，可能其中一个系统的调用量非常大，而另外四个系统的调用很小，如果没有线程池的话，显然第一个系统的大量调用会影响到后面四个系统的调用性能。Hystrix 的线程池和 Java 标准线程池一样，可以配置一些参数：coreSize、maximumSize、maxQueueSize、queueSizeRejectionThreshold、allowMaximumSizeToDivergeFromCoreSize、keepAliveTimeMinutes 等，如果某一个子系统的调用量突然激增，超过了线程池的容量，也会迅速失败，直接返回，起到降级和保护系统本身的作用。当然hystrix也支持非线程池的方式，在本地请求线程中做调用，即 semaphore 模式，官方不建议，除非系统qps真的很大。 Zuul 是一个网关组件。提供动态路由,监控,弹性,安全等边缘服务的框架。 Zuul 主需要简单配置一下 properties 文件，不需要写具体的代码就可以实现将请求转发到相应的服务上去。还可以定制化一些 filter 做验证、隔离、限流、文件处理等切面，对于网关来说，使用 Zuul 能减少大量的代码。不过我没有使用过，不太了解，现在我们的网关主要还是基于 FeignClient、Ribbon、Hystrix 来实现的。Zuul 默认也集成了这些组件。有兴趣可以研究研究。 Turbine 是聚合服务器发送事件流数据的一个工具，用来监控集群下 Hystrix 的 metrics 情况。 在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 Turbine 提供把多个 Hystrix.stream 的内容聚合为一个数据源供 Dashboard 展示. SpringCloud Starters SpringBoot 热插拔、提供默认配置、开箱即用的依赖。Starter 是 SpringBoot框架非常基础的部分。可以自定义 Starter。","link":"/2018/05/26/zh/programing/java/spring_cloud/1_basis/"},{"title":"SpringCloud 笔记2","text":"前记上一章介绍完基本概念，这章将开始搭建服务。 主要从注册中心、发布服务、消费服务这几个方面开始。 Eureka Server 服务注册中心为了方便搭建，这里直接使用 Idea 中的 Spring Initializr 构建。 流程： 先创建 Maven 主工程。 然后创建2个 Module，一个作为 server，一个作为 client。 这里先在 server 中进行操作。 添加依赖： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加注解 @EnableEurekaServer，使得 SpringBoot 应用成为服务注册中心： 12345678@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); }} 在 application.properties 配置文件中写入： 123456789101112# eureka server端口server.port=7000# eureka server的主机名eureka.instance.hostname=localhost# 当前服务不需要到eureka server上注册（默认情况下server也是一个client）eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false# 供客户端注册的地址eureka.client.service-url.defaultZone=http://localhost:${server.port}/eureka/ 启动工程，打开 http://localhost:7000/ 即可进入 Eureka Server。 可以看到标红的地方显示没有发现任何服务。 Eureka Client 服务提供现在创建一个可以提供计算服务的客户端，添加依赖： 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加注解 @EnableDiscoveryClient 声明该应用是一个 Eureka Client。 12345678@EnableDiscoveryClient@SpringBootApplicationpublic class ComputeServiceApplication { public static void main(String[] args) { SpringApplication.run(ComputeServiceApplication.class, args); }} 在 application.properties 配置文件中写入： 1234567# eureka client端口server.port=8000# 消费者将通过该名称调用所提供的服务spring.application.name=computeService# 在server的上注册，这里在可以多个server注册eureka.client.service-url.defaultZone=http://localhost:7000/eureka/ 实现一个 RESTFul API 风格的 /add 接口，提供加法服务： 12345678910111213141516171819@RestControllerpublic class ComputeController { private final Logger logger = LoggerFactory.getLogger(ComputeController.class); @Resource private EurekaInstanceConfig eurekaInstanceConfig; @Value(&quot;${server.port}&quot;) private Integer serverPort; @GetMapping(&quot;/add&quot;) public String add(@RequestParam Integer a, @RequestParam Integer b) { Integer after = a + b; logger.info(&quot;/add, instanceId:{} , host:{} , result:{}&quot;, eurekaInstanceConfig.getInstanceId(), eurekaInstanceConfig.getHostName(false), after); return String.format(&quot;Result: %d, from port: %d&quot;, after, serverPort); }} 启动客户端，可以看到已经在 server 上注册： 通过启动多个实例达到集群的目的（如何启动可以看这篇[文章]https://blog.csdn.net/forezp/article/details/76408139)） 服务消费上面已经完成了计算服务的注册，接下来是消费其提供出来的接口。 SpringCloud 有两种服务调用方式： Ribbon + RestTemplate Feign Ribbon + RestTemplate同样，添加一个服务消费的 Module，命名为 ribbonConsumer。 依赖： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加注解 @EnableDiscoveryClient 使得消费者可以发现服务；添加 RestTemplate Bean： 123456789101112131415@EnableDiscoveryClient@SpringBootApplicationpublic class RibbonConsumerApplication { public static void main(String[] args) { SpringApplication.run(RibbonConsumerApplication.class, args); } @Bean // 开启负载均衡 @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); }} 在 application.properties 配置文件中写入： 1234567# 消费者端口server.port=9000# 消费者名称spring.application.name=ribbonConsumer# 和客户端一样，这里可以在多个server注册eureka.client.service-url.defaultZone=http://localhost:7000/eureka/ 创建接口，去消费 COMPUTESERVICE 提供的 add 服务： 123456789@Servicepublic class RibbonComputeService { @Resource private RestTemplate restTemplate; public String add(Integer a, Integer b) { return restTemplate.getForEntity(&quot;http://COMPUTESERVICE/add?a=&quot; + a + &quot;&amp;b=&quot; + b, String.class).getBody(); }} 控制器： 1234567891011@RestControllerpublic class RibbonConsumerController { @Resource private RibbonComputeService computeService; @GetMapping(&quot;/add&quot;) public String add(@RequestParam Integer a, @RequestParam Integer b) { return computeService.add(a, b); }} 然后启动消费者，可以看到都注册上了： 访问多几次消费者的网址 http://localhost:9000/add： 1234567891011$ curl http://localhost:9000/add\\?a\\=1\\&amp;b\\=66Result: 67, from port: 8001$ curl http://localhost:9000/add\\?a\\=1\\&amp;b\\=45Result: 46, from port: 8000$ curl http://localhost:9000/add\\?a\\=1\\&amp;b\\=100Result: 101, from port: 8001$ curl http://localhost:9000/add\\?a\\=1\\&amp;b\\=81Result: 82, from port: 8000 可以看到两个 compute-service 客户端被交替调用。这是 Ribbon 在客户端已经实现了对服务调用的均衡负载。 一个服务注册中心 Eureka Server 端口为7000 Client 跑了两个实例，端口分别为 8000、8001 分别向服务注册中心注册 Consumer 端口为9000，向服务注册中心注册 当 Consumer 通过 RestTemplate 调用 Client 的 add 接口时，因为用 Ribbon 进行了负载均衡，会轮流的调用 Client：8000、8001 两个端口的 add 接口 Feign Feign 基于接口的注解请求 Feign 整合了 Ribbon 添加新的 Module，命名为 feignConsumer，添加依赖： 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 因为整合了 Ribbon，所以主程序中只需要注解 @EnableFeignClients 即可： 123456789@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class FeignConsumerApplication { public static void main(String[] args) { SpringApplication.run(FeignConsumerApplication.class, args); }} 配置文件 application.properties 和上面的差不多： 1234567server.port=9100spring.application.name=feignConsumereureka.client.service-url.defaultZone=http://localhost:7000/eureka/feign.hystrix.enabled=true 定义消费的接口： 1234567// 消费 computeService@FeignClient(value = &quot;computeService&quot;)public interface FeignComputeService { @GetMapping(&quot;/add&quot;) String add(@RequestParam(value = &quot;a&quot;) Integer a, @RequestParam(value = &quot;b&quot;) Integer b);} 控制器： 1234567891011@RestControllerpublic class FeignConsumerController { @Resource private FeignComputeService computeService; @GetMapping(&quot;/add&quot;) public String add(@RequestParam Integer a, @RequestParam Integer b) { return computeService.add(a, b); }} 同样，像上面那样启动多个客户端后进行测试。 1234567891011$ curl http://localhost:9100/add\\?a\\=1\\&amp;b\\=66Result: 67, from port: 8001$ curl http://localhost:9100/add\\?a\\=1\\&amp;b\\=45Result: 46, from port: 8000$ curl http://localhost:9100/add\\?a\\=1\\&amp;b\\=100Result: 101, from port: 8001$ curl http://localhost:9100/add\\?a\\=1\\&amp;b\\=81Result: 82, from port: 8000 结果和 Ribbon 一样，对服务提供方 client 实现了负载均衡。 参考：spring-cloud-feign","link":"/2018/05/26/zh/programing/java/spring_cloud/2_eureka_server/"},{"title":"SpringCloud 笔记3","text":"前记上一章搭建了基本的服务架构，这章将了解断路器。 场景在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，最终导致自身服务的瘫痪。 举个栗子：在电商网站中，我们可能会将系统拆分成用户、订单、库存、积分、评论等一系列的服务单元。 用户在调用订单服务创建订单的时候，会向库存服务请求出货（判断是否有足够库存来出货）。如果此时库存服务因网络原因无法被访问到，将会导致创建订单服务的线程进入等待库存申请服务的响应，在漫长的等待之后用户会因为请求库存失败而得到创建订单失败的结果。在高并发情况下，这些等待线程在等待库存服务的响应而未能释放，会使得后续到来的创建订单请求被阻塞，最终导致订单服务也不可用。 因此相较传统架构，微服务的架构就显得不稳定。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。为了解决这样的问题，就产生了断路器模式。 断路器 Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls. 断路器模式源于 Martin Fowler 的 Circuit Breaker 一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。 在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。 在微服务架构中，一个请求通常需要调用多个服务： 较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 断路打开后，就可以避免连锁故障，fallback 方法可以直接返回一个固定值。 Ribbon 添加断路器在 ribbonConsumer 工程中添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在启动类上加上 @EnableHystrix 注解开启 Hystrix： 123456789101112131415@EnableHystrix@EnableDiscoveryClient@SpringBootApplicationpublic class RibbonConsumerApplication { public static void main(String[] args) { SpringApplication.run(RibbonConsumerApplication.class, args); } @Bean @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); }} 在服务 add 处添加注解 @HystrixCommand 开启熔断功能，并且指定在熔断时返回的方法： 1234567891011121314@Servicepublic class RibbonComputeService { @Resource private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = &quot;addFallback&quot;) public String add(Integer a, Integer b) { return restTemplate.getForEntity(&quot;http://COMPUTESERVICE/add?a=&quot; + a + &quot;&amp;b=&quot; + b, String.class).getBody(); } public String addFallback(Integer a, Integer b) { return String.format(&quot;add %d + %d error&quot;, a, b); }} 测试： 12$ curl http://localhost:9000/add\\?a\\=1\\&amp;b\\=100Result: 101, from port: 8000 关闭 client，访问： 12$ curl http://localhost:9000/add\\?a\\=1\\&amp;b\\=100add 1 + 100 error 可以看到在提供服务的 client 不可用时，返回了失败，而不是等待响应超时，这就很好的控制了容器的线程阻塞。 Feign 使用断路器Feign 是自带断路器的，不用添加依赖，但是默认是关闭的，要在 application.properties 配置文件里开启： 1feign.hystrix.enabled=true 在服务接口处注解添加熔断时返回的 类： 123456@FeignClient(value = &quot;computeService&quot;, fallback = FeignComputeServiceFallbackImpl.class)public interface FeignComputeService { @GetMapping(&quot;/add&quot;) String add(@RequestParam(value = &quot;a&quot;) Integer a, @RequestParam(value = &quot;b&quot;) Integer b);} 再添加该处理类： 12345678@Componentpublic class FeignComputeServiceFallbackImpl implements FeignComputeService { @Override public String add(Integer a, Integer b) { return String.format(&quot;add %d + %d error&quot;, a, b); }} 启动 feignConsumer，访问： 12$ curl http://localhost:9100/add\\?a\\=2\\&amp;b\\=91Result: 93, from port: 8000 关闭 client，访问： 12$ curl http://localhost:9991/add\\?a\\=2\\&amp;b\\=91add 2 + 91 error 关于 Hystrix 还有很多用法，这里暂时略过。可以自行查看： http://blog.didispace.com/spring-cloud-starter-dalston-4-1/http://blog.didispace.com/spring-cloud-starter-dalston-4-2/","link":"/2018/05/28/zh/programing/java/spring_cloud/3_circuit_breaker/"},{"title":"SpringCloud 笔记4","text":"前记上一章了解断路器，这章将看看路由网关。 微服务在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。 在 SpringCloud 微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（Zuul、Ngnix），再到达服务网关（Zuul集群），然后再到具体的服务。服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在Git仓库，方便开发人员随时改配置。 ZuulZuul 的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如 /api/user 转发到到 user 服务，/api/shop 转发到到 shop 服务。Zuul 默认和 Ribbon 结合实现了负载均衡的功能。 Zuul 功能： Authentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 使用新建一个 Module，命名为 zuulServer，添加依赖： 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加注解 @EnableZuulProxy 开启 Zuul 功能（作为服务，其本身也要向 Server 中心注册）： 123456789@EnableZuulProxy@EnableEurekaClient@SpringBootApplicationpublic class ZuulServiceApplication { public static void main(String[] args) { SpringApplication.run(ZuulServiceApplication.class, args); }} 配置文件 application.properties： 123456789101112server.port=10000spring.application.name=zuulServiceeureka.client.service-url.defaultZone=http://localhost:7000/eureka/# 以 /api-a/ 开头的请求都转发给 ribbonConsumer 服务zuul.routes.api-a.path=/api-a/**zuul.routes.api-a.service-id=ribbonConsumer# 以 /api-b/ 开头的请求都转发给 feignConsumer 服务zuul.routes.api-b.path=/api-b/**zuul.routes.api-b.service-id=feignConsumer 访问 api-a： 12$ curl http://localhost:10000/api-a/add\\?a\\=2\\&amp;b\\=91Result: 93, from port: 8000 访问 api-b： 12$ curl http://localhost:10000/api-b/add\\?a\\=2\\&amp;b\\=91Result: 93, from port: 8000 可以看到 Zuul 起到了路由作用。 服务过滤Zuul 还有过滤，安全验证的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Componentpublic class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); /** * 不同生命周期的过滤器类型 * pre：在请求被路由之前调用 * routing：在路由请求时候被调用 * post： 在routing和error过滤器之后被调用 * error：处理请求时发生错误时被调用 * * @return 生命周期 */ @Override public String filterType() { return &quot;pre&quot;; } /** * 定义过滤器的执行顺序 * 数字越大，优先级越低 */ @Override public int filterOrder() { return 0; } /** * 判断该过滤器是否要执行 */ @Override public boolean shouldFilter() { return true; } /** * 过滤器的具体逻辑 * 包括查询数据库中的权限信息 */ @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(&quot;send {} request to {}&quot;, request.getMethod(), request.getRequestURL().toString()); // 获取 GET 参数 token Object token = request.getParameter(&quot;token&quot;); if (token == null) { log.warn(&quot;token is empty&quot;); // 过滤该请求，不往下级服务去转发请求，到此结束 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); ctx.setResponseBody(&quot;token is empty&quot;); return null; } // 如果有token，则进行路由转发 log.info(&quot;token ok&quot;); // 这里return的值没有意义，zuul框架没有使用该返回值 return null; }} 测试没有 token 时： 123456$ curl -i http://localhost:10000/api-b/add\\?a\\=2\\&amp;b\\=91HTTP/1.1 401Transfer-Encoding: chunkedDate: Mon, 28 May 2018 08:16:09 GMTtoken is empty 测试有 token 时： 12$ curl http://localhost:10000/api-b/add\\?a\\=2\\&amp;b\\=91\\&amp;token\\=123Result: 93, from port: 8000 总结 不仅仅实现了路由功能来屏蔽诸多服务细节，更实现了服务级别、均衡负载的路由。 实现了接口权限校验与微服务业务逻辑的解耦。通过服务网关中的过滤器，在各生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更集中关注业务逻辑的处理。 实现了断路器，不会因为具体微服务的故障而导致服务网关的阻塞，依然可以对外服务。","link":"/2018/05/28/zh/programing/java/spring_cloud/4_microservice/"},{"title":"SpringCloud 笔记5","text":"前记上一章使用了路由网关进行路由转发和安全验证，这章将搭建分布式的配置中心。 SpringCloud Config在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在 SpringCloud 中，有分布式配置中心组件 SpringCloud Config，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在 SpringCloud Config 组件中，分两个角色：Config Server 和 Config Client。 SpringCloud Config 为服务端和客户端提供了分布式系统的外部化配置支持。配置服务器为各应用的所有环境提供了一个中心化的外部配置。它实现了对服务端和客户端对 Spring Environment 和 PropertySource 抽象的映射，所以它除了适用于 Spring 构建的应用程序，也可以在任何其他语言运行的应用程序中使用。作为一个应用可以通过部署管道来进行测试或者投入生产，我们可以分别为这些环境创建配置，并且在需要迁移环境的时候获取对应环境的配置来运行。 Config 服务端沿用之前的套路，新增一个 Module 作为服务端，并添加依赖： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注 之前我对上面的 config-server 依赖写上了版本号，结果一直无法访问到配置内容，直接添加就行了，会根据 springboot 的版本选择版本的。 添加注解 @EnableConfigServer 开启配置服务器功能： 12345678@EnableConfigServer@SpringBootApplicationpublic class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); }} 配置文件 application.properties： 123456789101112131415161718server.port=20000spring.application.name=configServer# 配置Git仓库地址spring.cloud.config.server.git.uri=https://github.com/Zoctan/spring-cloud-demo.git# 连接仓库超时时间spring.cloud.config.server.git.timeout=10# 配置仓库路径spring.cloud.config.server.git.search-paths=config# 配置仓库的分支，默认为masterspring.cloud.config.label=master# 如果是私有仓库，才要填下面的信息# 访问git仓库的用户名#spring.cloud.config.client.git.username=your username# 访问git仓库的用户密码#spring.cloud.config.client.git.password=your password 注 SpringCloud Config也提供本地存储配置的方式： 配置文件 application.properties： 12345# Config Server会默认从应用的src/main/resource目录下检索配置文件spring.profiles.active=native# 也可以通过该属性来指定配置文件的位置# spring.cloud.config.server.native.search-locations=file:/home/xx/properties/ 但是为了支持更好的管理内容和版本控制的功能，还是推荐使用Git的方式。 然后在项目下建立 config 文件夹，分别添加不同的配置文件，用于给客户端 configClient 进行配置（后面创建的客户端名 spring.application.name=configClient）： configClient.properties configClient-dev.properties configClient-test.properties configClient-prod.properties 分别给它们添加一个 from 属性： from=git-default-1.0 from=git-dev-1.0 from=git-test-1.0 from=git-prod-1.0 记得先将上面的配置上传到Git比如我上面的配置在 https://github.com/Zoctan/spring-cloud-demo 的 config 目录下 configClient 就是 application.name，不能有不同，否则取不到配置； dev | test | prod 等是 profile； label 是分支的名称。 URL与配置文件的映射关系如下： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 启动该配置程序，访问： 第一种映射：/{application}/{profile}[/{label}]，不注明 label 默认访问 master。 123456789101112131415161718192021222324$ curl http://localhost:20000/configClient/dev/{ &quot;name&quot;: &quot;configClient&quot;, &quot;profiles&quot;: [ &quot;dev&quot; ], &quot;label&quot;: null, &quot;version&quot;: &quot;0ec6f9f1f9316fdeb2c86e06d943770bf6b40528&quot;, &quot;state&quot;: null, &quot;propertySources&quot;: [ { &quot;name&quot;: &quot;https://github.com/Zoctan/spring-cloud-demo.git/config/configClient-dev.properties&quot;, &quot;source&quot;: { &quot;from&quot;: &quot;git-dev-1.0&quot; } }, { &quot;name&quot;: &quot;https://github.com/Zoctan/spring-cloud-demo.git/config/configClient.properties&quot;, &quot;source&quot;: { &quot;from&quot;: &quot;git-default-1.0&quot; } } ]} 客户端新增一个 Module，命名为 configClient，并添加依赖： 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 普通的 Boot 应用： 1234567@SpringBootApplicationpublic class ConfigClientApplication { public static void main(String[] args) { SpringApplication.run(ConfigClientApplication.class, args); }} 配置文件 bootstrap.properties： 12345678910server.port=30000spring.application.name=configClient# 配置服务中心网址spring.cloud.config.uri=http://localhost:20000/# 使用的配置spring.cloud.config.profile=dev# 配置仓库的分支，默认为masterspring.cloud.config.label=master 注 上面的属性必须配置在 bootstrap.properties 中，才能正确加载 config 内容。因为 config 的相关配置会先于 application.properties，而 bootstrap.properties的加载也是先于 application.properties。 添加控制器： 123456789101112@RestControllerpublic class TestController { // 绑定配置中的from属性 @Value(&quot;${from}&quot;) private String from; @GetMapping(&quot;/from&quot;) public String from() { return String.format(&quot;I'm from %s&quot;, from); }} 测试： 12$ curl localhost:30000/from I'm from git-dev-1.0 可以看到读取的就是 configClient-dev.properties 下的 from 值。","link":"/2018/05/29/zh/programing/java/spring_cloud/5_config/"},{"title":"SpringCloud 笔记6","text":"前记上一章使用了配置中心服务器和客户端，使得配置可以统一。 当服务实例很多时，都要从配置中心读取文件，这时就可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用的目的。不需要我们为这些 Config 服务端做任何额外的配置，只需要遵守一个配置规则：将所有的 Config Server 都指向同一个 Git 仓库，这样所有的配置内容就通过统一的共享文件系统来维护，而 Config Client 客户端在指定 Config Server 位置时，只要配置 Config Server 外的均衡负载即可。 高可用 Config Server添加依赖，使 Config Server 作为服务注册到 Eureka 注册中心： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 application.properties 中指定注册中心地址： 1eureka.client.service-url.defaultZone=http://localhost:7000/eureka/ 加上 @EnableDiscoveryClient 注解： 123456789@EnableDiscoveryClient@EnableConfigServer@SpringBootApplicationpublic class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); }} 启动服务后，可以看到已经注册上了： Config Clien 客户端同样，客户端也要添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 添加 @EnableDiscoveryClient 注解： 12345678@EnableDiscoveryClient@SpringBootApplicationpublic class ConfigClientApplication { public static void main(String[] args) { SpringApplication.run(ConfigClientApplication.class, args); }} 配置文件 bootstrap.properties，不仅要添加注册中心地址，还要启用发现配置服务中心和对应的服务名，而配置服务中心网址则不再需要了，由负载均衡动态分配： 1234567891011121314151617server.port=30000spring.application.name=configClienteureka.client.service-url.defaultZone=http://localhost:7000/eureka/# 开启通过服务来访问 Config Serverspring.cloud.config.discovery.enabled=true# 指定 Config Server 注册的服务名spring.cloud.config.discovery.service-id=configServer# 配置服务中心网址# spring.cloud.config.uri=http://localhost:20000/# 使用的配置spring.cloud.config.profile=dev# 配置仓库的分支，默认为 masterspring.cloud.config.label=master 测试： 12curl localhost:30000/from I'm from git-dev-1.0 加密解密官方文档 配置文件会包括大量的敏感信息，比如：数据库的账户与密码等。很显然，如果我们直接将敏感信息以明文的方式存储于微服务应用的配置文件中是非常危险的。针对这个问题，SpringCloud Config 提供了对属性进行加密解密的功能，以保护配置文件中的信息安全。比如： 12spring.datasource.username=rootspring.datasource.password={cipher}dba6505baa81d78bd08799d8d4429de499bd4c2053c05f029e7cfbf143695f5b 在 SpringCloud Config 中通过在属性值前使用 {cipher} 前缀来标注该内容是一个加密值，当微服务客户端来加载配置时，配置中心会自动的为带有 {cipher} 前缀的值进行解密。 使用前提在使用 SpringCloud Config 的加密解密功能时，有一个必要的前提：配置中心的运行环境中安装的 JCE（Unlimited Strength Java Cryptography Extension） 必须是不限长度的。虽然 JRE 中自带 JCE，但是默认使用的是有长度限制的。可以从 Oracle 官网中下载到：JDK6：http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.htmlJDK7：http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html 需要将 local_policy.jar 和 US_export_policy.jar 两个文件复制到 $JAVA_HOME/jre/lib/security 目录下，覆盖原有内容。 注意 原文 从 1.8.0_151 版本和 1.8.0_152 版本开始，Java 已经提供了更简单的方法来启用不受限的加密算法强度。 在你的 $JAVA_HOME/jre/lib/security 目录下有个 java.security 文件，比如： 12345/jdk1.8.0_152 |- /jre |- /lib |- /security |- java.security 里面有关于使用哪种加密算法强度的配置以及说明（可能被#注释了）： 1crypto.policy=unlimited 开启之后，重启你的 Java 应用即可使用不受限制的加密强度。 $JAVA_HOME/jre/lib/security/policy/ 目录下有 limited 和 unlimited 目录，它们分别存放了相应的 local_policy.jar 和 US_export_policy.jar 文件。 可以通过下面的代码验证是否可以使用弱强度的加密： 12345678910111213141516171819202122232425262728public static void securityVerify() throws Exception { byte[] data = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; // create a 64 bit secret key from raw bytes SecretKey key64 = new SecretKeySpec( new byte[]{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}, &quot;Blowfish&quot;); // create a cipher and attempt to encrypt the data block with our key Cipher c = Cipher.getInstance(&quot;Blowfish/ECB/NoPadding&quot;); c.init(Cipher.ENCRYPT_MODE, key64); c.doFinal(data); System.out.println(&quot;64 bit test: passed&quot;); // create a 192 bit secret key from raw bytes SecretKey key192 = new SecretKeySpec( new byte[]{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}, &quot;Blowfish&quot;); // now try encrypting with the larger key c.init(Cipher.ENCRYPT_MODE, key192); c.doFinal(data); System.out.println(&quot;192 bit test: passed&quot;); System.out.println(&quot;Tests completed&quot;);} 配置密钥完成了上面的 JCE 安装后，就可以启动 Config Server 配置中心了。 在控制台中，会输出一些配置中心特有的端点： /encrypt/status：查看加密功能状态的端点 /key：查看密钥的端点 /encrypt：对请求的body内容进行加密的端点 /decrypt：对请求的body内容进行解密的端点 Get 请求 /encrypt/status 查看一下加密功能状态： 12curl http://localhost:20000/encrypt/status{&quot;description&quot;:&quot;No key was installed for encryption service&quot;,&quot;status&quot;:&quot;NO_KEY&quot;} 对称加密因为没有配置密钥，所以无法使用加密功能。在配置文件 bootstrap.properties 中直接指定密钥信息（对称性密钥）： 1encrypt.key=abc123 特别注意是 bootstrap.properties 配置文件，不是 application.properties，不然无法加载密钥信息。 重启 Config Server，再次访问 /encrypt/status： 12curl http://localhost:20000/encrypt/status{&quot;status&quot;:&quot;OK&quot;} 此时，配置中心的加密解密功能就已经可以使用了。 可以尝试下 /encrypt 和 /decrypt 端点来进行加密和解密的功能。（都是POST请求） 测试： 12345$ curl http://localhost:20000/encrypt -d abc123c129bcdd46085f8fdeedfd44cd1ab2918e273cdd6c222a75320764fffa4e0288$ curl http://localhost:20000/decrypt -d c129bcdd46085f8fdeedfd44cd1ab2918e273cdd6c222a75320764fffa4e0288abc123 然后给 Config Client 的所有配置文件 configClient-xx.properties 里都加上一个加密过的密码（加密前的密码是 root）： 1password={cipher}d2538dde1147b51a3b1973e06af1abf0efc4bc40bdb6b27cdcf3307524b14bac 然后将配置 push 到 Git 上。 给 Config Client 添加一个控制器： 123456789101112@RestControllerpublic class TestEncryptController { // 配置文件中加密的密码 @Value(&quot;${password}&quot;) private String password; @GetMapping(&quot;/password&quot;) public String getPassword() { return String.format(&quot;Password: %s&quot;, password); }} 测试： 12$ curl http://localhost:30000/password Password: root 可以看出 Config Server 会自动解密 {cipher} 开头的密文。 有时候我们可能想 Config Server 直接返回密文，而不是解密后的内容，可以在 application.properties 配置中加上： 1spring.cloud.config.server.encrypt.enabled=false 非对称加密上面使用的是对称加密，还可以使用非对称加密，用 JDK 自带的 keytool 生成 RSA 密钥对（有效期设为365天）： 123456keytool -genkeypair -alias configServer -keyalg RSA \\ -dname &quot;CN=myname, OU=company, O=organization, L=city, ST=province, C=china&quot; \\ -keystore configServer.jks \\ -keypass 123456 \\ -storepass 123456 \\ -validity 365 将生成的 configServer.jks 复制到 configServer/src/main/resources 目录下，然后在 bootstrap.properties 中配置： 123456#encrypt.key=abc123encrypt.key-store.location=classpath:/configServer.jksencrypt.key-store.alias=configServerencrypt.key-store.password=123456encrypt.key-store.secret=123456 测试： 12$ curl http://localhost:20000/encrypt -d abc123AQCFza1WcPB3CIiAksdogkupcwyfGxWkSB6YybslhDb9REwOl0yDyCu5Mzd7zjCKysscy1o+QH5NKuEqyCtw3ErbTyDBFBlTfpOMqPAwb2yoH2wNlRC/IPz/ztHAVBYVc9i3tPicXTvXPNBjL7iGsYJqBwbWruTr4EejMvCOpdQqYzdjCe/pnnFScUwTvX9wtIrgOZTvBO+1qb4gtVGqwKMptjsMVKCcmUt4GfUD6NfEzdvfIfdohQ0uqyRUZLLCEXUzl2SE5GuIPZvZmivx+Q4Y63dWtGrE9TXwxTOJ2yVQS6fumV+aTt7pC/MU2N5z5+ckJ7KE+KwziDIW/L1OJasL2fvAudYaJadVk1ucsGnqr2BA8VwPwHa9QTD6V8ELRY4= 可以看出非对称加密也设置成功了。 动态更新配置虽然有了配置中心，但是每次更新了配置后需要重新启动客户端，如果有一堆客户端需要重启呢？可以通过实时更新通知来让它们知道需要更新了，而不是一个个重启它们。这里将使用 SpringCloud Bus，它可以将分布式的节点用轻量的消息代理连接起来。可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。这里主要是用它来实现通知微服务架构的配置文件的更改。 总线架构 当 Git 文件更改的时候，管理员通过向其中一个端口为 8882 的 Config Client 发送请求 /bus/refresh／，8882 端口客户端收到请求后会向消息总线发送一个更新消息，并且由总线传递到其他服务，从而使整个微服务集群都达到更新配置文件的目的。 在 Config Client 中添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;version&gt;1.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 消息总线需要用到 RabbitMQ，Arch 可以参考 ArchWiki，其他系统自行搜索安装。 在配置文件 application.properties 中加上 RabbitMQ 的配置，包括 RabbitMQ 的地址、端口，用户名、密码，代码如下： 12345spring.rabbitmq.host=localhostspring.rabbitmq.port=5672# 如果有用户名和密码的话#spring.rabbitmq.username=#spring.rabbitmq.password= 在更改了配置并上传后，只需要发送 POST 请求到其中一个 Config Client 客户端，比如：http://localhost:30000/bus/refresh，就可以发现所有其他 Config Client 都会重新读取配置文件。","link":"/2018/06/17/zh/programing/java/spring_cloud/6_config/"},{"title":"SpringCloud 笔记7","text":"前记上两章粗略的使用了配置中心和客户端，这一章将开始使用服务链路追踪（SpringCloud Sleuth）。 服务追踪分析微服务架构上通过业务来划分服务，通过 REST 调用，对外暴露一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。 随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下： 术语Span：基本工作单元。比如，在一个新建的 span 中发送一个 RPC 等同于发送一个回应请求给 RPC，span 通过一个64位ID唯一标识，trace 以另一个64位 ID 表示，span 还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span 的 ID、以及进度 ID(通常是IP地址)。span 在不断的启动和停止，同时记录了时间信息，当你创建了一个 span，你必须在未来的某个时刻停止它。 Trace：一系列 spans 组成的一个树状结构。如果你正在跑一个分布式大数据工程，你可能需要创建一个 trace。 Annotation：用来及时记录一个事件的存在，一些核心 annotations 用来定义一个请求的开始和结束。 cs（Client Sent），客户端发起一个请求，这个 annotion 描述了这个 span 的开始。 sr（Server Received），服务端获得请求并准备开始处理它，如果将其 sr 减去 cs 时间戳便可得到网络延迟。 ss（Server Sent），注解表明请求处理的完成(当请求返回客户端)，如果 ss 减去 sr 时间戳便可得到服务端需要的处理请求时间。 cr（Client Received），表明 span 的结束，客户端成功接收到服务端的回复，如果 cr 减去 cs 时间戳便可得到客户端从服务端获取回复的所有所需时间。 准备使用如果是使用的是 Java8 以上的版本，可以这样快速启动 Zipkin： 12curl -sSL https://zipkin.io/quickstart.sh | bash -sjava -jar zipkin.jar 默认的访问网址是：http://localhost:9411 其他启动方式比如 Docker，可以参考 Zipkin 官网文档。 这里沿用之前的三个工程 computeService、feignConsumer 和 ribbonConsumer。 对三个工程进行改造下面的改造都是一样的，添加依赖和指定 zipkin 地址。 添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;1.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件 application.properties 中指定 zipkin 的地址： 1spring.zipkin.base-url=http://localhost:9411 ribbonConsumer 改造在原有控制器上加多一个对外接口 /add2： 12345678910111213141516171819@RestControllerpublic class RibbonConsumerController { @Resource private RibbonComputeService computeService; @GetMapping(&quot;/add&quot;) public String add(@RequestParam Integer a, @RequestParam Integer b) { return computeService.add(a, b); } /** * 加法接口2，测试服务追踪 */ @GetMapping(&quot;/add2&quot;) public String add2(@RequestParam Integer a, @RequestParam Integer b) { return &quot;computeService: &quot; + computeService.add(a, b); }} feignConsumer 改造添加 RibbonConsumerService 服务： 123456@FeignClient(value = &quot;ribbonConsumer&quot;)public interface RibbonConsumerService { @GetMapping(&quot;/add2&quot;) String add2(@RequestParam(value = &quot;a&quot;) Integer a, @RequestParam(value = &quot;b&quot;) Integer b);} 原有控制器上也添加一个测试接口 /add2： 12345678910111213141516171819@RestControllerpublic class FeignConsumerController { @Resource private FeignComputeService computeService; @Resource private RibbonConsumerService ribbonConsumerService; @GetMapping(&quot;/add&quot;) public String add(@RequestParam Integer a, @RequestParam Integer b) { return computeService.add(a, b); } @GetMapping(&quot;/add2&quot;) public String add2(@RequestParam Integer a, @RequestParam Integer b) { return &quot;ribbonConsumer =&gt; &quot; + ribbonConsumerService.add2(a, b); }} 而且配置文件 application.properties 还需要添加采样比例（默认的可能看不到效果）： 12# 将采样比例设置为1.0（全部需要），默认的采样比例为: 0.1spring.sleuth.sampler.probability=1.0 测试然后把工程都启动上：zipkin、eurekaServer、computeService、ribbonConsumer、feignConsumer。 访问 feignConsumer 的接口 /add2： 12$ curl http://localhost:9100/add2\\?a\\=1\\&amp;b\\=25ribbonConsumer =&gt; computeService: Result: 26, from port: 8000 再打开 http://localhost:9411/ 的界面，点击依赖分析,可以发现服务间的依赖关系： 点击查找调用链,可以看到具体服务相互调用的数据：","link":"/2018/06/18/zh/programing/java/spring_cloud/7_service_tracking_analysis/"},{"title":"SpringCloud 笔记8","text":"前记一开始我们就创建了一个注册中心，但是当成千上万个服务向它注册的时候，它的负载是非常高的，这在生产环境上是不太合适的，这章将把 Eureka Server 集群化。 改造在 eurekaService 工程的 resources 文件夹下，创建配置文件 application-peer1.properties: 12345server.port=7001spring.profiles=peer1eureka.instance.hostname=peer1# 注意这里是向 peer2 注册eureka.client.serviceUrl.defaultZone=http://peer2:7002/eureka/ 创建配置文件 application-peer2.properties: 1234server.port=7002spring.profiles=peer2eureka.instance.hostname=peer2eureka.client.serviceUrl.defaultZone=http://peer1:7001/eureka/ 加完配置后修改 /etc/hosts，因为上面使用的是域名： 12127.0.0.1 peer1127.0.0.1 peer2 修改 computeService 中的配置 application.properties： 1eureka.client.service-url.defaultZone=http://peer1:7001/eureka/ 依次启动 peer1、peer2、computeService： 123java -jar eurekaServer-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar eurekaServer-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2java -jar computeService-0.0.1-SNAPSHOT.jar 访问：http://peer1:7001/ 可以看到 DS Replicas 下多了 peer2，computeService 也注册上了。 访问：http://peer2:7002/ 同样可以发现 peer1 和 computeService，也就是两台 eureka 成功集群。 peer1、peer2 相互感应，当有服务注册时，两个 eurekaServer 是对等的，它们都存有相同的信息，这就是通过服务器的冗余来增加可靠性，当有一台服务器宕机了，服务并不会终止，因为另一台服务存有相同的数据。 设置 IP 而不是域名上面改造时还修改了 hosts，比较麻烦。官网文档有说可以通过 eureka.instance.preferIpAddress=true 来设置 IP 让其他服务注册它。","link":"/2018/06/18/zh/programing/java/spring_cloud/8_transform/"},{"title":"My Task 1 条形图","text":"C4 Test3The chart below shows the different levels of post-school qualifications in Australia and the proportion of men and women who held them in 1999.","link":"/2022/10/30/zh/english/ielts/writing/my_task_1/bar_chart/"},{"title":"My Task 2 正反观点","text":"C4 Test3Creative artists should always be given the freedom to express their own ideas (in words, pictures, music or film) in whichever way they wish. There should be no government restrictions on what they do. To what extent do you agree or disagree with this opinion? It is hard to deny that artists express freely may spread some wrong ideas widely, and government have to restrict these ideas by one-time solution, and such a fact leads impressionable people to generate the opinion that there should be government restrictions on what artists do. However, such a statement suffers from both logical and factual fallacies, and it should be examined meticulously. As far as equality, culture, and feasibility are concerned, I strongly hold that government should not restrict artists’ own expressions. First and foremost, all men are created equal, as artists’ expressions should be same respected. To illustrate, creative ideas from artists for various domain are human brain exercises result; Not to mention that, these brain exercises result may grow beautiful cultural flowers in human being history, and with government restrictions, we may miss those excellent ideas. Furthermore, the fact that culture influence indicates that there should be no government restrictions on artists’ content. Take the case of movie limited policy for ten years ago, which limits movies’ content should not contain scenes with violence, drug or other not well things. However, there are lots of movies that contain those negative scenes are also good movies, like ‘Leon’, ‘The Godfather’ and so on. As a result, we couldn’t watch outstanding domestic films but from imported, because limiting movie creator creative imagination lower films quality and quantity at that time. Had it not been for the restrictions on film ideas removing these years, our domestic movie industry may never be great again. Nevertheless, a voice arises that limited action for artists is feasible if government need. Ironically, expressions can be restricted but what artists and their audiences thoughts can’t be restricted; in addition, people can always find another ways to express the same point, which means what government restrict today and it may revival tomorrow. So government regulation is rather better than restriction. Therefore, limiting artists expressions is not a feasible approach. In a nutshell, I maintain that there should be no government restrictions on what artists express, and I believe opponent will compromise after being exposed to my article.","link":"/2022/10/30/zh/english/ielts/writing/my_task_2/agree_disagree/"},{"title":"Task 1 条形图","text":"C4 Test3The chart below shows the different levels of post-school qualifications in Australia and the proportion of men and women who held them in 1999. 6.5 The given chart gives information about five different types of post-school qualifications in Australia and the percentage of men and women who held them in 1999. Overall, women’s education level was generally lower than that of men in Australia. There were more men than women who held a skilled vocational diploma, a postgraduate diploma and a master’s degree, while there were more women who held an undergraduate diploma and a bachelor’s degree. The highest difference in percentage was seen in the group of people who held a skilled vocational diploma. There wee significantly more men holding a skilled vocational diploma than women. Only 10% of those who had a skilled vocational diploma were women, and 90% were men. Simillarly, there were more male postgraduates and master graduates than female ones. 70% of postgraduate diploma holders were men, and 60% of those who had a master’s degree were men.There were more female undergraduates than male ones. 70% of undergraduates and bachelor’s degree holders were women. 30% of those who had a postgraduate diploma were women, and 40% of those who had a master’s degree were women. C5 Test2The charts below show the main reasons for study among students of different age groups and the amount of support they received from employers. 6.5 The given charts gives information regarding the motivations behind study among students of various age groups and the level of support they received from their employers. Employer support is measured by time off and help with fees. Overall, the younger the students are, the more likely they are studying for career. By contrast, the older they get, the more likely they are studying for interest. Employer’s support is the highest with students under the age of 26, and lowest with students aged between 30 to 39. 80% of those aged under 26 are studying for career. This percentage decreases as the age of students goes up. There are less than 20% of the students aged over 49 studying for career. This trend is reversed when it comes to students who study for interest. There are only 10% of students aged under 26 studying for interest. The percentage rises as the student age. Among those aged over 49, 70% of them study for interest. There are as many students who study for career as students who study for interest among the age group 40 to 49, with a percentage at a little above 40%. Students under 26 get the highest level of employer support. Level of support decreases as students age. Students aged between 30 to 39 only get half the amount of support of those received by students under 26. However, the amount of support slowly rises when students’ age goes beyond 40 years old. Students aged between 40 to 49 get more support than those aged between 30 to 39, and those aged over 49 get even more, but the amount never exceeds that received by those under 26. C6 Test4The charts below give information about USA marriage and divorce rates between 1970 and 2000, and the marital status of adult Americans in two of the years. 6.5 The given charts illustrate America’s marriage and divorce rates from 1970 to 2000, as well as the marital status of adult Americans in 1970 and 2000. Overall, number of marriages decreased over the time period given, while number of divorces increased in 1980 and decreased to its original amount by 2000. In both 1970 and 2000, most American adults were married but there were slightly more marriages in 1970 than in 2000. The group who never married ranked the second, followed by the widowed population and then the divorced population. There were 2.5 million marriages in America in both 1970 and 1980, then the number decreased to 2 million in 2000. There were 1 million divorces in America in 1970, and then the number rose to something close to 1.5 million in 1980. However, the number of divorce dropped in the following years and by 2000 there were 1 million divorces, same as 1970. In 1970, married Americans took up 70% of the population. Those who never married were about 15% of the population. The widowed population accounted for less than 10% of the population and the divorced population was even less. In 2000, the married population’s percentage dropped to a little less than 60%. The second highest percentage was still the group who never married, but its percentage increased to 20%. The widowed population in 2000 decreased a little, while the divorced population increased a little, but both not exceeding 10% of the population. C7 Test3The chart below shows information about changes in average house prices in five different cities between 1990 and 2002 compared with the average house prices in 1989. 6.5 The given pie charts give information regarding the electricity production by fuel source in Australia and France in 1980 and 2000 respectively. Overall, coal was the major fuel source in Australia in both 1980 and 2000, while nuclear power was the major fuel source in France in 2000. The electricity production in France in 1980 was roughly evenly distributed among four fuel types with hydro power being the only type that had a much smaller proportion. In Australia, the percentage taken up by coal increased a lot in 2000 where coal took up around 75% of all electricity production. Electricity produced by hydro power increased a little from 20 units in 1980 to 36 units in 2000. The percentage of natural gas and oil reduced dramatically to only 2 units. In France, coal, oil, and natural gas were the three main fuel sources in 1980. The smallest proportion was found in hydro power in 1980. In 2000, the proportions of natural gas and hydro power both shrank to 2 units. The percentage of coal and oil remain roughly the same at 25 units, while nuclear power increased dramatically to take up almost 75% of all electricity produced. C9 Test2The chart below shows the total number of minutes (in billions) of telephone calls in the UK, divided into three categories, from 1995—2002. 6.5 The chart gives information about the total time spend in billions of minutes on three different types of phone calls in the UK from 1995 to 2002. In general, local calls were the most popular and national and international calls came the second. However, while mobiles and national and international calls experienced a rapid and steady increase from 1995 to 2002, local calls decreased since 1999. The amount of local call was 70 billion minutes in 1995, which is almost doubled the amount of national and international call that was around 35 billion minutes only. The local calls hit its highest in 1999 by reaching 90 billion minutes, then decreased by 5 billion minutes in the next year and dropped to around 70 billion minutes in 2002. Though the number of minutes for national and international calls were only half of the number of local calls in 1995, it gradually increased by around 10 billion minutes within 2 years and climbed up to 60 billion minutes in 2002. The most significant change located in the rise of mobiles calls. It started with less than 5 billion minutes in 1995, increased gradually to around 15 billion minutes in 1999, then grow dramatically to 25 billion minutes in 2000. It almost doubled its amount in the year after and reached over 45 billion minutes in 2002. C10 Test3The charts below show what UK graduate and postgraduate students who did not go into full-time work did after leaving college in 2008. 6.5 The bar charts compare British graduate and postgraduate students with regard to their employment situation after leaving universities in 2008. Overall, it can be seen that most students from the two mentioned groups chose to study further after graduating. It is also noticeable that compared with graduate students, there were more undergraduates working part-timely. In terms of graduate students, a dominant part of them devoted themselves to further study, with a figure being 29,655, followed by those who decided to undertake part- time job and be unemployed (respectively 17,735 and 16,235), whereas merely 3500 of the UK graduates did voluntary work after leaving universities. When it comes to undergraduate students, those who went on studying after graduating was still the overwhelming part, reaching 2725 and nevertheless, the number of undergraduates choosing to do part-time work was only approximately 200 less than the figure of further study, namely 2535. Further, the volume of the students who did not possess a job and were volunteers were separately 1625 and 345. C12 Test1The bar chart below shows the percentage of Australian men and women in different age groups who did regular physical activity in 2010. 6.5 The bar chart given displays the information about the percentage of men and women in Australia who participated in physical activity regularly in 2010, and the subjects are divided into six age groups ranging from 15 to 65 years old and over. Generally, there were more Australian women who did physical activity regularly in 2010 than men across all age groups except for the age group that is people aged from 15 to 24. The highest difference in percentage occurred in the age group 35 to 44 - there were 13% more physically active people in the female population than in the male population, whilst there was only a minimal difference between men and women aged 65 and above. In the age group 35 to 44, there are 52.5% female population that did physical activity regularly but only 39.5% men who did the same. In the age group 65 and above, there are 46.7% men and 47.1% women who did physical activity regularly. There were significantly more women aged from 45 to 54 that did physical activity regularly than the men in the same age group, and the age group that ranged from 25 to 34 and the one ranged from 55 to 64 saw the same pattern as well. In addition, women aged from 45 to 54 were the most physically active female population - 53.3% of the subjects were physically active, where men aged from 15 to 24 were the most active with a percentage at 52.8%. The group of people aged from 15 to 24 were the only anomaly in the data, where men in this age group were a lot more physically active than their female counterparts. C12 Test3The chart below shows how frequently people in the USA ate in fast food restaurants between 2003 and 2013. 6.5 The given chart gives the information about the frequency of US people going to fast food restaurants from 2003 to 2013. The data is measured in percentage and is divided into three parts, which are those in the year of 2003, 2006, and 2013. Frequencies are described in six levels, which are every day, sacral times a week, once a week, once or twice a month, a few times a year and never. Overall, most people in the US went to fast food restaurants once a week or once or twice a month. The second highest percentage was seen in the group who went to fast food restaurant several times a week and the third highest was seen in the group who went to fast food restaurant a few times a year. People who had fast food every day had the least percentage, and people who never went to fast food restaurant ranked the second lowest among all groups. The layout of percentages was almost the same across the three recorded years but there were also some differences. For example, in 2003 and 2006, over 30% of the population frequented fast food restaurants once a week, but in 2013, this frequency held less percentage. In 2013, the highest percentage, also a little over 30%, was seen in the group who visited fast food restaurants once or twice a month. The group who went to fast food restaurants several times a week had a percentage that ranged from 15% to 20% over the given time period, with the highest percentage being in 2006. The group who went to fast food restaurants a few times a year had a slightly less percentage that ranged from around 13% to 15%. Both the groups that went to fast food restaurants every day and the group that never went to fast food restaurants had percentages less than 5%, except for the people in 2003 who never went to fast food restaurants which reached a percentage of 5%. C13 Test2The chart below shows the percentage of households in owned and rented accommodation in England and Wales between 1918 and 2011. 6.5 The given chart shows the percentage of owned and rented households in England and Wales from the year 1918 to 2011. Overall, there were significantly more rented accommodation than owned ones in England and Wales before 1971, and the trend reversed after 1971. In the year of 1971, the percentage of owned households equaled that of rented households. Before 1971, the percentage of owned households were steadily increasing from a little above 20% in the year of 1918 to over 40% in the year of 1961. By contrast, the percentage of rented households steadily decreased from 1918 to 1961, thereby reducing the gap between the percentage of owned and rented accommodation. At first, the percentage of rented households was about triple that of the owned ones, reaching near 80% while owned households were at a little over 20%. By 1961, the percentage of rented households were a little less than 60%, while that of owned households reached 40%. After 1971, the percentage of owned households increased slightly until 2011 when it saw a small decrease again. The trend for rented households was the exact opposite. The percentage of rented households started to decrease since 1981 and only in 2011 saw a slight increase. The percentage for rented households never exceeded 40% after 1971, whilst that for owned households never exceeded 70%. C13 Test3The bar chart below shows the top ten countries for the production and consumption of electricity in 2014. 6.5 The bar chart compares ten countries in terms of the electricity production and consumption (measured in billions of kilowatts per hour) in a selected year. Overall, it can be seen that in 2014, China was regarded as the biggest producer and consumer of electricity. It is also noticeable that apart from Germany, all the nations produced more electricity than they utilized. To be specific, China and USA produced and consumed much more electricity than their counterparts. Their electricity production were approximately 5400 billion kWh and their electricity consumption lied in round 4100 billion kWh. Additionally, Russian, Japan and India occupied the following positions, with production ranging from 871 to 1057 billion kWh and utilization from 698.8 to 1038 billion kWh. Canada, France, Brazil, Germany and Korean. Rep made up the last 5 places, among which Germany’s electricity usage exceeded its production, being at 582.5 billion kWh and 526.6 kWh respectively. C15 Test1The chart below shows the results of a survey about people’s coffee and tea buying and drinking habits in five Australian cities. 7 The given chart provides the results of a survey that asks about consumers’ coffee and tea buying and drinking habits from five Australian cities. Consumers’ habits are divided into three categories, which are those that purchased fresh coffee, those that purchased instant coffee, and those that went to a cafe for coffee or tea in the last four weeks. Overall, those went to a cafe to have tea or coffee comprise the majority of the surveyed population in all five cities, while those who bought fresh coffee in the last four weeks comprise the smallest proportion in all five cities. Sydney, Melbourne and Hobart have the most coffee and tea drinkers, whilst Brisbane and Adelaide have a relatively smaller percentage of coffee and tea consumers. In addition, there are significantly more people going to the cafe than those who purchased fresh coffee across all five cities. In terms of the group of people who consumed coffee or tea in a cafe, Melbourne has the highest proportion, with Hobart and Sydney having a slightly less percentage, all of which slightly above 60%. A similar pattern can be found with the number of people who bought fresh coffee in the last four weeks, but with Sydney having the highest percentage that is almost 45%, Melbourne and Hobart slightly lower than that. In contrast, Brisbane and Adelaide have lower percentages in regards to these two categories of coffee or drinkers. In terms of the category of consumer that purchased instant coffee in the last four weeks, Hobart and Brisbane have the highest percentages, around 53%. Adelaide and Melbourne’s percentage of instant coffee drinkers are slight lower, and Sydney has the lowest percentage of around 44%in this category. C17 Test3The chart below gives information about how families in one country spent their weekly income in 1968 and in 2018. 6.5 The bar chart compares 1968 and 2018 with regard to their average weekly spending by household in a selected country. Overall, it can be seen that citizens spent most on food in 1968, while 50 years later, leisure accounted for the largest proportion. It is also noticeable that the figure for household goods was the same in both years. In the year of 1968, families paid most for food and by contrast, this figure dropped dramatically from 35% to 17% in the following 50 years. Also, households reduced their spending on fuel and power, clothing and footware and personal goods in the mentioned period, respectively from 7% to 4%, 10% to 5 and 8% to 4%. Further, identical percentage, namely 8%, could be found for household goods in 1968 and 2018. Most money, with a percentage of 22%, was spent on leisure in the year of 2018, while it represented merely 9% 1968. Moreover, the proportion of money spent on housing and transport soared in the 50 years(separately by 9% and 6%). OG T1P1The chart below gives information on the percentage of British people giving money to charity by age range for the years 1990 and 2010. 7 The chart examines the levels of donation among people of different ages in Britain.Overall, a greater percentage of British people gave money to charity in 1990 than in 2010. However, across the two years, the pattern differs before and after the age of 50. In 1990.42% of the 36-50 age-group made charitable donations, and this figure is the highest on the chart.The 18-25s contributed the least at only 17%. By 2010, these figures had fallen significantly to 35% and 7% respectively. The level of donations from the 26-35 age-group also experienced a decrease in 2010 from 31% to 24%. While donations up to the age of 50 declined across the two years, they rose among the 51-65 age-group from 35% to nearly 40%, which was the highest percentage for 2010.The figure for the over 65s was lower than this, at 35%, but it was still a little higher than the 1990 figure of 32%. OG T4P1The chart below gives information about Southland’s main exports in 2000, *20.., and future projections for 2025. 7 This bar chart illustrates the performance of Southland’s primary exports in 2000 and 2013.It also indicates future projections for 2025.According to the data, it seems likely that international tourism will become the dominant industry,although dairy exports will remain strong. In 2000, we can see that tourism was the greatest exports earner of the three industries, with revenue standing at just over £8 billion.This figure has increased slightly, so that now, in 2013, it has reached almost £9 billion. It is estimated that international tourism will continue to grow, so that by 2025, it will be earning around £l0 billion for the country. In 2000, dairy exports were worth around £7 billion, but since then there has been a dramatic increase, and sales for this year are approximately £10 billion. Experts are predicting that exports in this area may fall slightly, so a figure of £9.5 billion is expected for 2025. Meat products are the third key industry in Southland, but sales have dropped since 2000 and now stand at £5.5 billion.It is expected that sales will continue to decrease in the future. OG T8P1The chart below shows the annual number of rentals and sales (in various formats) of films from a particular store between 2002 and 2011. 7 The number of rentals and sales in various formats of films,between 2002 and 2011 in a particular store has changed a lot. Sometimes it has been very low and sometimes very high.The number of rental since 2002.has been decreasing every year.Comparing the number of rentals in 2002 with 2011,it ‘s possible noticing that in 2002 it was about 180,000 rentals against approximately 55,000 in 2011. In regarding the number of VHS sales, comparing the period between 2002 and 2005,it has happened as well. In 2002 the number of VHS sales was about 85,000 sales, against 65,000 in 2003,40,000 in 2004 and about 10.000 sales in 2005.After that time, this store stopped to sale VHS.By another side, the number of DVD sales grew up between 2002 and 2007, from approximately 45,000 in 2002,more than 100,000 in 2003, to more than 200,000 in 2007.However,since 2008, it has been going down slightly.In 2011this number was less than 180,000. The number of Blu-Ray sales has started since 2007 and it has growing up slowly. In 2007 it was nowhere near as significant as DVD sales but I guess it will grow up drastically in a few years. Actually the number of DVD sales is still very higher than another products in that place.","link":"/2022/10/28/zh/english/ielts/writing/task_1/bar_chart/"},{"title":"Task 1 流程图","text":"C6 Test3The diagrams below show the life cycle of the silkworm and the stages in the production of silk cloth. 7 The charts shed light on the growth process of silkworms as well as the production procedures of silk cloth. Overall, it can be seen that the whole life cycle of silkworms consists of 4 stages and silkworms grow from eggs to moths. It is also noticeable that there are 6 main steps in the production of silk cloth, from the initial selecting to the eventual dying stage. In terms of the life cycle of silkworms, eggs are firstly laid by mature moths and after 10 days, the eggs turn into silkworm larvae that feed on mulberry leaves. The subsequent step lasts for 4 to 6 weeks until larvae hide themselves in cocoons by spiting a huge amount of silk thread around them. After a period of 16 days, larvae finally emerge from cocoons and enter the mature stage. When it comes to the production of silk clothing, the first step begins with selecting proper cocoons and boiling them with water. After that, around 300 to 900 meters of silk thread are unwound from cocoons which would be twisted and weaved in the following 2 stages to cloth and eventually, the weaved cloth is dyed with a variety of colors. C8 Test3The diagrams below show the stages and equipment used in the cement-making process, and how cement is used to produce concrete for building purposes. 6.5 The given diagrams illustrate the process and equipment of making cement, and how cement is turned into concrete that will be used for construction purposes. Overall, cement is made by limestone and clay. They go through a series of process to form cement. Concrete, on the other hand, consists of four ingredients that go into a mixer to form concrete. First, limestone and clay are crushed into powder which then goes into a mixer. The powder is then put into a rotating heater to be heated. The heated product then goes to a grinder and become the cement that we know of. The cement is finally bagged and goes on to be the ingredient of concrete. Concrete is formed by a mixture that is 15% cement, 10% water, 25% sand and 50% small stones. This mixture goes into the concrete mixer and after being thoroughly mixed becomes the concrete that will be used for construction. C10 Test4The diagrams below show the life cycle of a species of large fish called the salmon. 6.5The diagram sheds light on the growth process of salmon, a large marine fish. Overall, it can be seen that the whole life cycle consists of three stages, which last for approximately 10 years. It is also noticeable that the growing environment of salmon changes during the process. The salmon begins its life in the upper part of river, where the water flow is slow. Initially, salmon eggs are situated among reeds and small stones and hidden from their predators. Round 5 to 6 months later, fries with a length from 3 to 8 centimeters incubate from salmon eggs and swim to the lower part of the river, living in the fast current from around 4 years. 4 years later, those fries develop larger to the adolescent salmons, known as smolts, which are 12 to 15 centimeters long and live in the open sea for 5 years. Henceforth, smolts enter the mature stage and become adult salmon (from 70 to 76 centimeters long). Finally, they return to the upper river, laying eggs and thus continue their life cycle. C12 Test4The diagram below shows how geothermal energy is used to produce electricity. 6.5 The figure illustrates how electricity is being produced by geothermal energy. Overall, the process can be divided into five main stages: pumping down cold water, heating the water, pumping up the water to the ground surface, converting it into steam, utilizing the steam to power the turbine for electrical generation. To begin with, cold water is pumped down for 4.5 kilometers before it reaches the end of the injection well. It then enters the geothermal zone where the water will be heated by the hot rocks. The hot water will then be transferred to the production well and be pumped up to the condenser that is above the ground surface. The hot water will be converted into steam in the condenser and be passed to the turbine that is powered by steam. The energy created by the turbine will be transferred to the generator and used for producing electricity. C14 Test3The diagram below shows how electricity is generated in a hydroelectric power station. The diagram illustrates the process of generating electricity through the hydroelectric power station. Overall, electricity are ready to be generated in the daytime and prepared for the next generation at night. In day time, electricity is generated through the pressure created by the height differces. The water in the river first being gathered in high-level reservoir and passes through the narrow intake below the dam. The flow of water then goes through a pipe and reaches the power station. The electicity will be generated when the flow of water passes through the reversible turbines which operate as generator in day time. The generated electricity will be transfer from power lines to national grid. Meanwhile, the extra water will be collected in low-level reservoir. During night time, water from low-level reservoir will be pumped into high-level reservior for next generation. Water in low-level reservior first passes through the a pipe and reaches the reversible turbines that work as a pumper to pump water into high-level reservoir at night. During pumping, the water will flow upward to the high-level reservior. The closed intake during night time prevents water in the high-level reservior from flowing downwards. C15 Test3The diagram below shows how instant noodles are manufactured. 6.5 The diagram illustrates the manufacturing process for instant noodles. In general, the process can be divided into four main stages, starting with the storage of the raw material, assembling instant noodles, cooking and packaging. Instant noodles start in storage silos where the flour is stored. It is then transported alongside with water and oil into a mixer. When the materials are fully mixed, the dough will then pass the rollers and be compressed into dough sheets. Later, these sheets are cut into strips and formed into noodles discs that are ready for cooking. The discs will then be fried, left to dry and be assembled into separate cups with vegetables and spices. After that, the cups will pass through a factory machinery for labelling and sealing. After going through the stage of packaging, the instant noodles are prepared for future consumption. C16 Test2The diagram below shows the manufacturing process for making sugar from sugar cane. 7 The diagram sheds light on how sugar is manufactured from sugar canes. Overall, it can be seen that the whole process consists of 7 steps, from the initial growing stage to the eventual drying and cooling stage. The first step begins with growing sugar canes, which lasts for 12 to 18 months and is the longest stage in the whole process. Subsequently, the mature sugar canes are harvested in two means, either by hand or with the help of specialized vehicles and after that, these sugar canes are crushed into juice by certain professional machine. The fourth step involves the purification of the juice utilizing limestone filters. Afterwards the purified juice is evaporated thanks to the heat under the machine and converts into syrup. In the next stage, sugar crystals are separated from syrup, after which these crystals are dried and cooled and eventually, sugar is produced from sugar canes. C16 Test4The diagram below shows the process for recycling plastic bottles. 7 The diagram given shows the process of recycling plastic bottles. Overall, plastic bottles are collected in the bin for recycle and moved to the recycling site to undergo a series of processing that turn them from discarded plastic to reusable plastic, which allow them to become the raw material for product-making. First, plastic bottles are collected in the bin and put on a truck to be delivered to the recycling centre where they will be sorted. The ones that are wanted will be selected and the ones that are not will not go to the next stage to be recycled. The pile of wanted bottles are then compressed into blocks which are subsequently crushed into pieces. After which, the crushed pieces will be washed. Upon being washed, the plastic pieces are made into plastic pellets and go on to undergo a heating process to form raw material. This raw material is used to produce products like bags, pencils, bottles, and boxes et cetera. These products made from recycled plastic may be discarded in the future and go through the same recycling process.","link":"/2022/10/28/zh/english/ielts/writing/task_1/flow_chart/"},{"title":"Task 1 折线图","text":"C5 Test1The graph below shows the proportion of the population aged 65 and over between 1940 and 2040 in three different countries. 7 The line graph compares Japan, Sweden and the USA with regard to the rate of elderly people from 1940 to 2040. Overall, it can be seen that the percentage of older citizens in all the three countries are expected to rise in the 60 years. It is also noticeable that the figure for Japan will witness the sharpest increase. In the year of 1940, the Japan possessed the lowest proportion of the population aged 65 or over, representing merely 5%. Nevertheless, this figure is expected to climb to 10% in 2030 despite some fluctuation and it will increase more rapidly in the following 10 years to approximately 27% by 2040, being the highest among the three nations. When it comes to the rate of Sweden and the USA, the figure for the USA was slightly higher than that of Sweden in 1940, respectively standing at around 9% and 7.5%. Subsequently, the proportion of the two nations grew at distinctive speed and in 1995, the rate of Sweden surpassed the USA. In 2040, the rate of elderly citizens in Sweden and the USA is thought to be similar, separately 26% and 23%. C7 Test2The graph below shows the consumption of fish and some different kinds of meat in a European country between 1979 and 2004. 6.5 The line graph compares chicken, beef, lamb and fish with regard to their consumption in a selected European nation from 1979 to 2004. Overall, it can be seen that chicken was the only kind of fish and meat that witnessed an increase during the period. It is also noticeable that fish was the least popular among the four categories during the period. While in 1979, the average weekly consumption of beef was the highest, the figure for chicken ranked the first in 2004. The consumption of chicken showed an upward trend. In the year of 1979, it represented merely 140 grams per person per week, while after 25 years, it soared to 240 grams, although there existed certain fluctuation in this period. Similar patterns could be found for the consumption for beef and lamb, initially the rate of beef lied in 220 grams per person per week, approximately 70 grams higher than its counterpart. After some fluctuation, they separately dropped to 120 and 70 grams in 2004. By contrast, the figure for fish was relatively stable. In the year of 1979, a citizen in this country consumed around 70 grams of fish per week, and this rate declined slowly by 20 grams in the 25 years. C8 Test4The graph below shows the quantities of goods transported in the UK between 1974 and 2002 by four different modes of transport. 7 The line graph sheds light on the amount of freight delivered in Britain via four distinctive transporting methods from 1974 to 2002. Overall, it can be seen that road remained the dominant transporting mode in the 28 years. It is also noticeable that all modes of transport except rail showed an increase in the amount of goods ferried during the given period. In the year of 1974, the volume of good transported by road was the highest (approximately 70 million tones) and it climbed to around 95 million tones after 28 years despite short fluctuations in 1978 and 1992. By contrast, pipeline was regarded as the least popular transporting mode but it showed a steady increase in the freight amount, from 5 million tones in 1974 to four times the value in 2002. When it comes to the weight of goods transported by water and rail, their figures were similar in 1974, namely 40 million tones. Nevertheless, the quantities of goods by water rised by 23 million tones in the 28 years, whereas little modification could be found in the volume for railway after a series of fluctuations. C9 Test4The graph below gives information from a 2008 report about consumption of energy in the USA since 1980 with projections until 2030. 7 The given graph illustrates America’s energy consumption from 1980 to 2008 which was the time when the report was written, as well as predictions until 2030. Consumption is divided into six types of fuels, which are petrol and oil, coal, natural gas, nuclear, solar or wind, and hydropower. Units are measured in quadrillion units. Overall, the use of fossil fuels is predicted to rise considerably and dominate the US energy consumption in 2030, whereas alternative clean energy sources are expected to remain insignificant. The consumption of petrol and oil started off at 35 quadrillion units, fluctuated a little during 1980 and 1995 and then steadily increased afterwards. It is predicted to continue rising till 2030 until it almost reached 50 quadrillion units. The consumption of coal started off at a little over 15 quadrillion units. According to the report, its increase slowed down since 1995 and stagnated for about ten years but it is predicted to rise again after 2008. The consumption of natural gas fluctuated a lot during 1980 and 2010 but it was generally increasing. It is predicted to reach a plateau at around 25 quadrillion units after 2015. The consumption of three other types of fuel is much lower. All of them started off at lower than five quadrillion units. They all increased during the time period but only by a very small amount and are predicted to stay relatively unchanged after 2008, except for nuclear and solar or wind energy which will see a slight increase before 2030. C11 Test3The graph below shows average carbon dioxide(CO2) emissions per person in the United Kingdom, Sweden, Italy and Portugal between 1967 and 2007. 6.5 The line graph compares four countries, namely the United Kingdom, Sweden, Italy and Portugal with regard to their CO2 release per person from 1967 to 2007. Overall, it can be seen that the British greenhouse emission was significantly higher than other nations in the 40 years, and Portugal’s figure was the lowest all the time. It is also noticeable that the figure for Italy and Portugal witnessed an increase, while the rate for the UK and Sweden dropped. In 2007, Sweden’s average carbon emissons equaled Portugal’s. When it comes to Britain and Sweden, in 1967, their CO2 emission per individuas lied respectively in 11 and 9 metric tonnes. Although the figure for Sweden climbed to approximately 10.2 metric tonnes 10 years later, the greenhouse release for its counterpart decreased by 0.5 metric tonnes. Subsequently by 2007, the rate of Britain and Sweden fell separately by 1.5 and 4.7 metric tonnes. In terms of Italy and Portugal, their CO2 release per person represented respectively in 4.2 and 1.2 metric tonnes in the year of 1967. In the following 40 years, this two figures increased continuously and reached separately 7.6 and 5.5 metric tonnes in 2007. C15 Test2The graph below shows the number of tourists visiting a particular Caribbean island between 2010 and 2017. 6.5 The line graph sheds light on the volume of visitors travelling to a selected Caribbean island from 2010 to 2017. Overall, it can be seen that there were more and more travelers coming to the island during the 7 years. It is also noticeable that the volume of tourists staying on cruise ships surpassed the number of visitors staying on island in the selected period. In 2010, there were 1 Million sightseers visiting the Caribbean island and in following years this number rose continuously to 3.5 Million in 2017 despite a short stagnant time in 2015. In 2010, the volume of visitors staying on island was approximately 0.75 Million, 0.5 Million more than the number of those staying on cruise ships, after which both groups witnessed an increase although certain fluctuation could be found. In 2015, the number of visitors staying on cruise ships exceeded its counterparts and in 2017, the volume of sightseers on cruise ships and island lied respectively in 2 and 1.5 Million. C16 Test1The charts below show the changes in ownership of electrical appliances and amount of time spent doing housework in households in one country between 1920 and 2019. 6.5 From 1920 to 2019, we can see an overall positive trend in percentage of households with electric appliances and an overall negative trend in the number of hours spent doing house work.According to the statistics, the percentage of households owning refrigerators and vacuum cleaners increased more rapidly, from 0% and 30% to both 100% respectively. The percentage of washing machine ownership also increased, however not as much, only found in around 75% of the households in 2019. With the increasing amount of household appliances, in the same period we see a steady drop of hours spent doing housework per week. By 1920 the number amounted to 50 hours per week but by 2019 the number dropped down to around 10 hours per week. We also see that both the washing machine and fridge percentage rose most steeply around the period of 1920s to 1980s, which correlates to a period of relatively steeper decrease in hours spent on house work. In conclusion, between 1920s to 2019 the percentage of all appliance ownership increased, and almost every household in this country by 2019 has a Vacuum cleaner or a Refrigerator. The number of hours spent on housework decreased in this same period, from 50 hours down to only 10 hours, which correlates with the more common ownership of electric appliances that can speed up the process. C17 Test4The graph below shows the number of shops that closed and the number of new shops that opened in one country between 2011 and 2018. 6.5 The given graph gives information about the number of shops that closed and the number of shops that opened in one country from the year 2011 to 2018. Overall, the number of shop closures and openings both witnessed a downward trend. The number of shops closed was generally greater than the number of shops opened. The number of shop closures dropped from around 6,500 in 2011 to a little over 5,000 in 2018. The number of shops closed decreased a little from 2011 to 2012 and rose to over 7,000 in 2013. It then declined a little again in 2014. After that, the number of shops closed plummeted to below 1,000 in 2015 and it rose again to a little over 5,000 in 2016. The number fluctuated slightly in the remaining two years of the period. The number of shop openings dropped from about 8,500 in 2011 to 3,000 in 2018. The number of shops opened decreased dramatically from 2011 to 2012, then rose again in the next two years to a little over 6,000. It then reduced again to about 4000 in the year of 2015. The number remained unchanged in 2016 and it increased a little bit in 2017 and then declined to 3,000 in 2018. OG T6P1The chart below shows the changes that took place in three different areas of crime in Newport city centre from 2003-2012. 7 This graph illustrates how crime rates altered in Newport inner city during the period 2003-2012. We can see immediately that the greatest change occurred in the number of burglaries,while incidents of theft remained low but steady. In 2003, we can see that burglary was the most common crime,with approximately 3,400 reported cases. The figure rose to around 3,700 in 2004, but then there was a downward trend until 2008.At this point the figure stood at just over 1,000 incidents.This rose slightly in 2009, then continued to fluctuate for the remaining period. In 2003, the number of cars being stolen stood at around2.800 and followed a similar trend to burglary until 2006.At this point the number rose, standing at around 2,200 in 2007.There was a marginal decrease in the following year,but from then on, the trend was generally upwards.Finally, robbery has always been a fairly minor problem for Newport. The number of offences committed changed little over nine years. It is interesting to note that the figure of approximately 700 in 2003 is the same figure for 2012.","link":"/2022/10/28/zh/english/ielts/writing/task_1/line_chart/"},{"title":"Task 1 地图","text":"C5 Test3The map below is of the town of Garlsdon. A new supermarket (S) is planned for the town. The map shows two possible sites for the supermarket. 7 The map sheds light on two proposed locations (S1 and S2) for a new supermarket in the town of Garlsdon, whose population reaches 65,000. Overall, it can be seen that S2 is situated in the town center, while S1 is in the countryside. It is also noticeable that S1 is adjacent to the town of Hindon but S2 is near the town of Bransdon and Cransdon. In terns of S1, it is located in the northwestern rural area of Garlsdon, which consumers from Hindon and Garlsdon can easily have access to. Furthermore, it is close to the railway and thus shoppers from Cransdon, a town with a population of 29,000 can reach it with ease but it is relatively hard for citizens in Bransdon to get there. When it comes to S2, it lies in the town center surrounded by housing and industrial areas, making it convenient for dwellers there to go shopping. Moreover, although it is not accessible by the main road, the railway is available, which enables shoppers from Hindon and Cransdon to do some shopping there. C9 Test1The two maps below show an island, before and after the construction of some tourist facilities. 7 The given maps illustrate the changes an island underwent after the construction of various tourist facilities. Overall, the island has been transformed into a tourist resort with all sorts of facilities and accommodation. Before, it was very empty and there was nothing on the islands except some trees.15 cottages for accommodation have been built in the west and the middle parts of the island. Between the cottages there is a restaurant and a reception place. There is a vehicle track that connects the restaurant, the reception and the pier to the south of the island, and the track also goes around the reception. Footpaths connect all of the cottages with each other. The sea area just beyond the beach is now open for swimming. Some boats are parked around the pier. The east side of the island is still underdeveloped and empty as it was before, with nothing but trees. C12 Test2The maps below show the centre of a small town called Islip as it is now, and plans for its development. 7 The maps show the development plans for Islip town center. There will be quite a few noticeable changes, including the road in the town center, decrease in park size, more facilities built and more housing areas being developed. As of now, the Islip town center can be accessed via a main road that runs across it horizontally. Miscellaneous shops are situated on either side of the main road. The housing area and the local school are located to the south of the main road and the shops, and can only be accessed via a road branching south as of now. At the south eastern part of the town center, there is a park, connected by another branched off road from the main road. In the development plans, there will be quite a few noticeable changes to these current facilities. The most substantial would be the overhaul of the main road to the town center: It will be extended into a dual carriageway, encircling the entire town center and the road segment remaining inside the town center will be used exclusively by pedestrians. The northern row of the shops will be extended and repurposed, into a bus station, a shopping center and a car park. The park previously situated in the south east will notably shrink, and the housing areas located in the southern part of the town center will be expanded, with new housing built by the park, as well as in the north east part of the town center. Overall, the new town center will be able to provide more service and is more accessible. C13 Test1The two maps below show road access to a city hospital in 2007 and in 2010. 6.5 The two maps given display the road access to a city hospital in 2007 and in 2010 respectively.Overall, the layout of the roads that surround the city hospital are roughly the same in 2007 and 2010. The major changes around the city hospital in 2010 are the changes in the car parks and bus stations. Also there are two new roundabouts constructed within the surrounding roads. In 2007, the city hospital was surrounded by a ring road which connected to the Hospital Road to the south side of the hospital. Hospital Road continued to meet City Road in a crossroad down south, and there was a car park for both staff and public to the east side of Hospital Road. Also, Hospital Road had six bus stops on its sides in 2007. The main roads around the city hospital remain unchanged in 2010, but there are some new constructions and changes in car parks and bus stations. First, the original car park is now open to staff only, and there is a new public car park built on the east side of the city hospital. Two roundabouts have been added to two ends of Hospital Road, one is connected to the Ring Road that surrounds the hospital and the other one is connected to City Road. The bus stops on the sides of Hospital Road have been removed and there is a bus station on the west side of Hospital Road in 2010. C13 Test4The plans below show the layout of a university’s sports centre now, and how it will look after redevelopment. 7 The maps compare the current plan of a university’s sports center with its proposed layout after revamp. Overall, it can be seen that this sports center will be extended westward and eastward after the redevelopment. It is also noticeable that more facilities will be made with the purpose of satisfying users’ needs. To start with, the entrance is proposed to be extended after the revamp, with a new sports shop and a café separately situated in west and east side. Facilities in the center, including the 25m pool, seating and changing room will remain unchanged during the redevelopment, apart from the gym which would be extended to the east. Further, great modifications will be found in the place of the present outdoor courts. A new changing room plus a large leisure pool will replace the current west court. In terms of the east court, two dance studios, a sports hall and an extra changing room are planed to be constructed there. C14 Test4The plans below show a public park when it first opened in 1920 and the same park today. 6.5 The plans given display the maps of the same public park when it first opened in the year of 1920 and now. Overall, the parks have undergone some considerable changes. A majority of its features in 1920 have been removed and turned into something else. A small number of facilities remain till this day, and there are also some additional functions. The major facilities in the park have been changed. First, the fountain in the center of the park has been turned into a rose garden with seats around it. The stage for musicians was upgraded to an amphitheater for concerts. The pond for water plants in the right corner of the park is no longer there, and the place is now occupied by children’s play area. The glasshouse that was to the right of the entrance on Eldon Street in 1920 was removed, and the place is currently for water feature. Despite the amount of changes in the park, there is still one part of the park that remains unchanged, that is the rose garden just opposite the stage for musicians or today’s theatre. The seats that scattered on the sides of the park have been moved to surround the rose garden in the center. Today’s park also has a new feature which is an underground car park, the entrance to which is just beside the water feature. C17 Test1The maps below show an industrial area in the town of Norbiton, and planned future development of the site. 6.5 The maps compare the current plan of an industrial area in Norbiton with its proposed layout after redevelopment. Overall, it can be seen that the traffic system of this area will be extended northward and westward with more extensions added to the existing system. It is also noticeable that residential buildings with relative facilities will replace factories to satisfy citizens’ needs. To start with, a number of factories are located in the center of Norbiton, while after revamp, they are expected to make way for facilities including housing, playground, school, shops and medical center, which will be connected via an advanced road system. Further, a farmland can currently be found on the north side of a river that is situated in the north of the industrial area. However, the traffic system will extend northward across the river, thus letting the farmland to reducing its size to allow more space for residential constructions. OG T7P1The maps below show the village of Stokeford in 1930 and in 2010. 7 In 1930, the River Stoke crossed through the Stokeford from northeast corner to southwest corner and a bridge in the top was over this river for providing the path for the road in this map. It is obvious that there is nothing in the west side of the river. Moving to the east side of the river stoke, the primary school was right in the center of the maps well as next to the farmland. To the south side of the primary school was the gardens with a large house.Besides,along the road from north to south, several buildings, shops, post office and farmland were located in the west side of it. After 70 years, as can be seen from the map of 2010, there was no change happened in the west side of the river and about the post office, but all of the farmlands and shops had been demolished.Moreover, the primary school had been expanded with two buildings and to the south of which, the original gardens had been reduced and developed as the retirement home.Lastly, several branches of the road had been constructed with plenty of houses, which had been established along branches. OG T3P1The diagrams below show the changes that have taken place at West Park Secondary School since its construction in 1950. 7 The diagrams show west Park School at three different stages in its development: 1950, 1980 and 2010. In 1950, the school was built close to a main road and next to a number of houses. A large area behind the school was turned into a playground, while the area behind the houses was farmland. By 1980, the houses had been demolished in order to make way for a small car park and an additional school building, which became the science block. In addition to the existing playground, the school also gained the farmland and converted it into a sports field. In 2010, the school building remained unchanged but the car park was extended to cover the entire sports field. As a result of this, the original playground was divided into two so that it provided a smaller playground and a small sports field. During this period, the school has increased in size and a car park has been created and enlarged. The combined recreational areas, however, first expanded and were then reduced in size.","link":"/2022/10/28/zh/english/ielts/writing/task_1/map/"},{"title":"Task 1 混合图","text":"C4 Test4The charts below give information about travel to and from the UK, and about the most popular countries for UK residents to visit. 6.5 The diagrams separately shed light on the volume of travelers to and from Britain from 1979 to 1999 and the tourist destinations that enjoy great popularity among UK dwellers in 1999. Overall, it can be seen that the number of British individuals traveling abroad surpassed the number of sightseers visiting the UK. It is also noticeable that France was the most popular tourist target country for UK residents. In terms of the line graph, similar figures could be found for visitors to and from the UK, namely around 10 million in the year of 1979. In the following 20 years, the volume of sightseers coming from the UK increased significantly more rapidly than its counterpart. In 1999, approximately 54 million Britain citizens choosing to travel abroad, whereas merely 28 million travelers paid a visit there. When it comes to the bar graph, France was regarded as the most popular among UK citizens, with its figure being 11 million, followed by Spain, to which 9 million British traveled in 1999. By contrast, merely respectively 3, 2.5 and 2 million of Britain sightsees visiting USA, Greece and Turkey. C4 Test2The graph below shows the demand for electricity in England during typical days in winter and summer. The pie chart shows how electricity is used in an average English home. 7 The diagrams separately shed light on the British electricity demand in winter and summer and the electricity usage of an average British household. Overall, it can be seen that citizens in the UK need more electricity in winter than in summer. It is also noticeable that the British household overwhelmingly utilizes electricity for heating water and rooms. In terms of the line graph, the electricity demand in winter drops from around 40,000 unites at 3 o’clock to the bottom (30,000 unites) at 8 o’clock before it climbs to the peak at approximately 45,000 unites 14 hours later. By contrast, the electricity demand in summer is significantly lower with the highest rate at 20,000 unites at 14 o’clock, whereas in summer, individuals need the least electricity at 9 o’clock, which is merely 12 ,000 unites. When it comes to the pie chart, heating rooms and water is the main source of electricity usage for the English home, representing 52.5%, followed by ovens, kettles and washing machines that occupy 17.5%. Furthermore, the same figure, namely 15%, could be found for lighting, TV, radio and vacuum cleaners, food mixers, electric tool. C6 Test1The graph and table below give information about water use worldwide and water consumption in two different countries. 6.5 The infographics provided illustrate global water usage in different areas, as well as detailed water consumption data for Brazil and Congo. Overall, global water usage has increased immensely over the years, agriculture remains the leading water usage sector, and the more advanced a country is, the more water it uses. Looking at the global water use by sector graph it is evident that global water usage by 2000 has increased almost nine-folds since 1900. The largest sector of water usage was and is still Agriculture. At 1900, agriculture water usage was around 500 km3, but in year 2000 this number has increased to over 3000Km3. Industrial water usage and domestic usage has also increased immensely, from almost no usage at 1900 to 1000 km3 and around 400 km3 at 2000 respectively. The table provides some detailed statistics for Brazil and Congo. According to the data, Brazil has a population of 176 million people while Congo only 5.2 million. However, Brazil’s average water consumption per person is 359 m3 at year 2000, which is 40 times more than the number for Congo residents, suggesting a positive correlation between state development and citizen water consumption. C8 Test1The pie chart below shows the main reasons why agricultural land becomes less productive. The table shows how these causes affected three regions of the world during the 1990s. 6.5 The pie chart illustrates the major reasons for land degradation globally and the table shows how significance these factors were during the 1900s. Overall, overgrazing is the most obvious cause for land degradation and Europe is the most severely affected area. For the causes of worldwide land degradation, there were three main factors that contributed to around 30 percent of the cause respectively. Globally, 35 percent of the degradation was caused by over-gazing and 30 percent was resulted by deforestation. A further 28% was caused by over-cultivation of crops, and other factors only contributed to 7 percent in total. For the extent of damage, Europe was the worst affected area. Over 23% of its land was degraded where 9.8 percent was because of deforestation, 7.7 percent was due to over-cultivation and 5.5 percent was contributed by over-grazing. However, while over-gazing played a small role in European land degraded, it was the major cause for the land degradation in Oceania which contributed to 11.3 percent of the total land degraded. Besides, Oceania was not affected by over-cultivation and deforestation only resulted in 1.7 percent of its land degradation. Lastly, North America was the least affected region where the total land degraded was only 5 percent, where 3.3 percent was due to over-cultivation, 1.5 percent was due to over-grazing and the last 0.2 percent was due to deforestation. C11 Test4The table below show the number of visitors to Ashdown Museum during the year before and the year afterit was refurbished. The charts show the result of surveys asking visitors how satisfied they were with their visit, during the same two periods. 6.5 The table compares the figures of visitors who visited the Ashdown Museum before and after museum renovation, while the chart depicts the visitors satisfaction’s survey results. Overall, the refurbishment brings a positive result on both the total amount of visitors and the ratio of satisfaction. To begin with, the table shows a significant increase in the number of annual visitors after the refurbishment. The number of the annual visitors was 74,000 before the refurbishment and it jumped up to 92,000 in the year after the refurbishment. For the chart, there were 40 percent of the visitors who were not satisfied with the museum before the refurbishment. Besides, 10 percent of the tourists were very dissatisfiied with the museum. Only 30 percent of the visitors were satisfied, which doubled the ratio of those who were very satisfied. Meanwhile, the chart illustrates an outstanding increase in the ratio of visitors who were very satisfied in the year after refurbishment. A 20-percent increase can be found in the ratio of visitors who are very satisfied while another 40 percent of the visitors were satisfied with the museum. Though there were also 5 percent of visitors who did not response, the ratio of visitors who were very dissatisfied dropped from 10 percent to 5 percent after the refurbishment. C14 Test2The chart below shows the value of one country’s exports in various categories during 2015 and 2016. The table shows the percentage change in each category of exports in 2016 compared with 2015. 6.5 The given bar chart displays one country’s export earnings in five categories from 2015 to 2016, and unit used is billion dollar. The accompanying table gives information about the percentage change in each of the five categories in 2016 in comparison with the numbers in 2015. As it can be seen from the bar chart, the categories that accounted for the highest number of export earnings in both 2015 and 2016 are petroleum products and engineered goods. Textiles is the category that made the least money. The general layout of values continued in 2016. From the table, it can be noted that all categories have seen a rise in earnings in 2016 except gems and jewelry which fell by 5.18%. Both the export earnings for petroleum products and engineered goods saw a small increase in the given period, with both categories reaching $60 billion in 2016. Despite its lowest export value, earnings in textiles went up in 2016, exceeding $30 billion, and was the category that saw the biggest percentage increase, by 15.24%. In contrast, the change in agricultural products was minimal, rising only 0.81% according to the table. Gem and jewelry continued to be the middle one among all five categories in 2016, and its value even decreased by around 5%. C15 Test4The chart below shows what Anthropology graduates from one university did after finishing their undergraduate degree course. The table shows the salaries of the anthropologists in work after five years. 6.5 The given chart gives information about what types of work Anthropology graduates from one university undertook after graduating with their undergraduate degree course. There are five categories of work and one ‘unknown’ category. The table tells us the salaries of these Anthropology graduates in work after five years. Overall, over half of these Anthropology graduates got a full-time job after they left school and they were the biggest majority among all the graduates. Only 5% of these undergraduates engaged in part-time work plus postgraduate studies, which were the smallest percentage among the six categories. After five years of work, those who worked in the government and those who worked as freelance consultants generally did better than those who worked in private companies. Anthropologists in the government sector had the most people who earned over $100,000 after 5 years of work. 15% of the Anthropology graduates worked part-time, and 12% of them were unemployed. Those who engaged in full-time postgraduate study took up 8% of all, same with the unknown group.After 5 years of work, 40% of anthropologists who worked as freelance consultants earned $100,000 a year, and another 40% of them earned $75,000-99,999. 15% of these freelance consultants earned $50,000-74999, and only 5% of them earned between $25,000 to 49,999. The data for those who worked in government sector were the same regarding those who earned $25,000-49,999 and $50,000-74,999. 30% of the anthropologists working in the government sector earned $75,000-99,999 and 50% of them earned over $100,000. There were more people in the lower-income category among anthropologists working in private companies. 10% of them made $25,000-49,999. 35% of them earned $50,000-74,999. 25% of them earned $75,000-99,999, and 30% of them made over $100,000. C17 Test2The table and charts below give information on the police budget for 2017 and 2018 in one area of Britain. The table shows where the money came from and the charts show how it was distributed. 6.5 The given table shows the sources of the police budget in 2017 and 2018 in one area of Britain, and the given charts illustrate the distribution of the budget in these two years. Overall, the source that contributed the most to police budget in both years was National Government. Then local taxes’ contribution ranked the second and the least came from other sources. In both years, the money was mainly spent on salaries and the least percentage of the budget was spent on technology. In both years, the majority of the budget came from National Government. Up to 175.5 million came from National Government in 2017 and in 2018 the number rose to 177.8 million. Local taxes contributed 91.2 million to the budget in 2017 and 102.3 million in 2018. In both years, there was a contribution of around 38 million from other sources. The budget in 2017 was 304.7 million in total, and the budget in 2018 was 318.6 million in total. In both years, the same percentage of the budget was distributed to buildings and transport, which was 17% of the entire budget. More money were invested in technology in 2018 than in 2017. In 2017, only 8% of the budget was spent on technology but the percentage rose to 14% in 2018. Most of the budget went to officers and staff’s salaries. In 2017, salaries accounted for 75% of the budget. The percentage of budget spent on salaries dropped a little in 2018, which was 69%. OG T2P1The graph and table below show the average monthly temperatures and the average number of hours of sunshine per year in three major cities. 7 The data provides information on average temperatures and annual hours of sunshine in London, New York and Sydney. The temperature patterns for London and New York are similar, although New York has warmer summers and colder winters. In both cities, peaks occur in July/August,at 23° in London and 29° in New York. In contrast, Sydney’s hottest weather is in December/January when temperatures average 25°.During this period, New York’s temperatures dip to an average of around 5°, compared with 8° in London. On the other hand, Sydney’s lowest average temperatures in July are just over 15°. As far as hours of sunshine are concerned, New York and Sydney have similar averages of 2,535 and 2,473 hours respectively. London, however, has a much lower average of 1,180 hours.Clearly,London is the coldest city and has the fewest hours of sunshine.New York has the hottest summers, but Sydney enjoys the warmest overall climate.","link":"/2022/10/28/zh/english/ielts/writing/task_1/mixed_chart/"},{"title":"Task 1 饼图","text":"C8 Test2The three pie charts below show the changes in annual spending by a particular UK school in 1981, 1991 and 2001. 7 The three pie charts compare the year of 1981, 1991 and 2001 with regard to the modification in yearly expenditure of a selected British school. Overall, teachers’ salaries accounted for the largest proportion in the total spending in all three years. While the shares in yearly expenditure of teacher salaries, furniture and equipment, and insurance increased, those of other workers’ salaries and resources experienced a drop. In 1981, the overwhelming spending of this school went in teachers’ salaries, with the rate being 40% and this proportion climbed to 50% 10 years later, whereas in 2001, it decreased by 5%. By comparison, the cost of insurance of this school in 1981 represented merely 2%, which grew to 8% in 2001. This school spent 28% of the money on other workers’ salaries in 1981 and nevertheless, this figure continued falling to 22% in 1991 and only 15% in 2001. The rate of resources and furniture and equipment experienced fluctuation from 1981 to 2001, respectively from 15% to 9% and from 15% to 23%. C9 Test3The charts below give information on the ages of the populations of Yemen and Italy in 2000 and projections for 2050. 6.5 The Charts provided depict the current age distribution of Yemen and Italy’s population at 2000, as well as projections for the same nations in 50 years. Overall, Yemen’s population has a lower average age across both periods, while Italy’s elderly population, hence average age increased noticeably. Yemen in the Year 2000 has quite a high ratio of Children, just more than half at 50.1% of all. It has almost no elderly population, only 3.6% of all and the rest are working adults. We see this trend of high youthful population carry through to 2050, with more than half, at 57.3% of all population being working adults, 37% being children and just 5.7% being the elderly. The situation is completely different in Italy. In year 2000, although there is a high ration of working adults in Italy, at 61.6%, the proportion of the elderly population is also staggeringly high, at 24.1%, more than 7 times the proportion in Yemen. This trend of overwhelming elderly population in Italy carries over into 2050, where the percentage increased almost twice fold, to 42.3%. The proportion of working adults and children in the population has also both decreased, amount to only 46.2% and 11.5%, both much less than the proportions in Yemen, for children 3 times as much. C10 Test1The first chart below shows how energy is used in an average Australian household. The second chart shows the greenhouse gas emissions which result from this energy use. 6.5 The two pie charts separately shed light on the volume of energy use through different means in an average household in Australia and the amount of greenhouse gas emissions from the same sources. Overall, it can be seen that heating consumes more energy than its counterparts. It is also noticeable that water heating not only uses large amount of energy but also gives out the most detrimental gas. In terms of the first graph, 42% of the energy usage in an average Australian family goes in heating, followed by water heating and other appliances that occupy respectively 30% and 15%. Then the figures drop precipitously, with refrigeration, lighting and cooling consuming 7%, 4% and 2%. With regard to the second pie chart, heating emits merely 15% of the greenhouse gas despite the fact that it uses the most energy. As the second biggest energy consumer, water heating releases the largest amount of hazardous gas (32%). After that, other appliances and refrigeration separately give out 28% and 14% of the greenhouse gas and by contrast, lighting and cooling totally emit 11% of the gas. C11 Test1The charts below show the percentage of water used for different purposes in six areas of the world. 7 The pie charts provided show the percentage of water allocated for industrial, agricultural and domestic use. Overall, the more developed region of the world, namely North America and Europe allocates much more water for industrial use. In less developed or developing regions, such as Asia, South America and Africa however, much more water is diverted to agricultural use. In more developed regions of North America and Europe, we see a somewhat similar ration of water usage: Around 50% for industrial use. It is a completely different story for other regions of the world. Africa, central Asia and South East Asia use much less water for industrial purposes, with the most being 12% of all water consumed in South East Asia, and the least in Central Asia, at only 5% of all water consumed in the region. In contrast, these less developed or developing regions use much more water for agricultural purposes. Percentage of agricultural water usage amounts to more than 75%, save for south America at 71%. In central Asia, this percentage is the highest, at 88% of all water used. In Europe and North America, the percentage is much lower, at only 32% and 39% respectively. As for domestic water usage, developing regions’ use much less than developed regions. While 13% and 15% of North America and Europe’s water usage is domestic, in Africa and Asia the figure is much less, at only 9% and 7% respectively. A anomaly of the pattern is South America, since its domestic water usage amounts to 19% of all water consumed. C11 Test2The charts below show the proportions of British students at one university in England who were able to speak other languages in addition to English, in 2000 and 2010. 6.5 The pie charts compare 2000 and 2010 with regard to the rate of English students in a selected university who have a command of other languages apart from English. Overall, it can be seen that compared with 2000, a larger number of students could speak foreign languages in 2010. It is also noticeable that Spanish was the most popular second language for the students in this university. Most of the students in this selected university were able to speak merely one language in addition to English. In 2000, 30% of the students could only speak Spanish apart from English and this figure rose by 5% in the following 10 years. Further, respectively 15% and 10% of all the students in this university spoke French and German as their second languages in 2010. The proportion of German remained unchanged 10 years later, while the rate for French witnessed a reduction by 5%. Additionally, the figure for students mastering another language lied in 15% in 2000 and climbed to 20% in 2010. Also, there were students who had a command of two other languages and no other language apart from English in this university. Such students represented separately 10% and 20% in 2000 and by contrast, after 10 years these figures changed to 15% and 10%. C14 Test1The charts below show the average percentages in typical meals of three types of nutrients, all of which may be unhealthy if eaten too much. 6.5 The pie charts compare three types of nutrients, namely sodium, saturated fat and added sugar with regard to their average proportion in Americans’ meals. Overall, it can be seen that breakfast contains the lowest rate of all the three nutrients. It is also noticeable that dinner occupies the highest rate of both sodium and saturated fat, while snacks contain more added sugar than its counterparts. In terms of sodium and saturated fat, dinner makes up the highest percentage (43% and 37% respectively) and by contrast, the figure for breakfast remains the lowest being 14% and 16% separately. Apart from that, snacks also contain the lowest proportion of sodium as breakfast both representing 14% but its percentage of saturated fat reaches 21%. When it comes to added sugar, snacks make up the largest proportion of 42%, followed by dinner and lunch (23% and 19% for each). In breakfast, individuals in the USA take in the lowest amount of added sugar, accounting for only 16% among three meals and snacks. OG T5P1The pie charts below show the online shopping sales for retail sectors in New Zealand in 2003 and 2013. 7 The two pie charts compare the percentages of online sales across different retail sectors in New Zealand in the years 2003 and 2013. For three of the sectors, it is evident that over this time frame there was significant change in their proportion of online transactions. At 36% we can see that the travel sector accounted for the majority of online sales in 2003, but this percentage had dropped to 29% by 2013. Across the same ten-year period, as an increasing number of people chose to purchase films and music online, we can see that transactions went from just 21%to 33%, making it the retail sector with the highest over all share of the online market. In 2003, the clothing industry boasted an impressive 24% of total online sales in New Zealand. However, by 2013, the figure had fallen considerably to 16%. Interestingly, online sales of books eventually overtook sales of clothes, although books still represented only 22% of the market.","link":"/2022/10/28/zh/english/ielts/writing/task_1/pie_chart/"},{"title":"Task 1 表格","text":"C4 Test1The table below shows the proportion of different categories of families living in poverty in Australia in 1999. 6.5 The given table gives information of the percentage of different types of families living in poverty in Australia in 1999. Overall, families with sole parent had the largest proportion of people living in poverty and families with aged couple had the smallest proportion. 11% of all households lived in poverty, which was over 1 million people. Single families without children had the second highest proportion of people living in poverty, which was 19%, only 2% less than that of families with sole parent. The third highest percentage was found in families that were consisted of couples and children - 12% of these families lived in poverty. This category had the highest number of people living in poverty as well, up to 933,000 people. 7% of families that were couples with no children lived in poverty, but its number was close to that of families with sole parent, both over 200,000 people. Families that contained one single aged person had the second smallest proportion of people living in poverty, with a number at 54,000 people only. Families consisted of aged couple had even fewer, which were 48,000 people. C5 Test4The table below gives information about the underground railway systems in six cities. 6.5 The table provided shows information of six different countries’ underground rail system, about their opening dates, kilometers of route and passengers per year. Overall, London’s underground system opened the earliest with highest kilometers of route, however the Tokyo underground transports the most people per year. From the table, it is clear that London opened its underground system the earliest, as early as 1863. In comparison, Los Angeles opened its underground system the latest out of the 6 cities, only in 2001. When discussing the length of the routes however, London also takes the crown at 394 kilometers of underground railway opened. Kyoto in Japan’s underground system is the shortest, at only 11 km. There seems to be no correlation however, between the date of opening of the underground system, and the length of the underground system. When talking about passengers transported, that seems to be completely different story. Tokyo, with a seemingly middle of the road length of underground route at 155 km, transports 1927 millions of passengers per year. That is almost twice as much as London, which boasts the longest railroad route. The least busy underground is in Kyoto, which only transports 45 million people per year. One might conclude that no matter the opening date, bigger, busier cities like Tokyo and London tends to have a longer underground route and transports more passenger per year. C6 Test2The table below gives information about changes in modes of travel in England between 1985 and 2000. 6.5 The given table tells us about the changes in the way people traveled in England between 1985 and 2000. Overall, the total miles travelled by people increased by 2000. Almost all modes of travel saw an increase in miles except for bicycle and local bus. In both 1985 and 2000, the most popular mode of travel was by car. The average distance travelled by car per person per year in 1985 was 3,199 miles, while that of 2000 was 4,806 miles. The second most popular mode of travel in 1985 was “other” modes of travel, while that of 2000 was the train. Traveling on foot and by train were relatively popular, with the average distance traveled per person being around 250 miles. Other modes of travel such as bicycle, long distance bus, and taxi were a lot less popular, all of which had a two-digit average distance traveled per person per year. This feature remained the same in 2000, except for long distance bus which saw an increase in miles in 2000. Miles travelled by local bus decreased by a half in 2000 to 274 miles. Miles travelled by train increased a bit in 2000 to 366 miles. In both years, other modes of travel were the second most popular modes of travel - 450 miles in 1985 and 585 miles in 2000. C7 Test1The table below gives information on consumer spending on different items in five different countries in 2002. 6.5 The table compares 5 distinctive countries with regard to their citizens’ expenditure on Food/Drinks/Tobacco, Clothing/Footwear and Leisure/ Education in the year of 2002. Overall, it can be seen that consumers in the five nations spent more on Food/Drinks/Tobacco than the other categories. It is also noticeable that Leisure/ Education took up the least proportion in 2002. In terms of the expenditure on Food/Drinks/Tobacco, Turkish consumers ranked the first with a percentage of 32.14% in 2002, followed by individuals from Ireland (28.91%) and Spain (18.80%). By contrast, citizens in Italy and Sweden spent less money on this category, respectively 16.36% and 15.77%. When it comes to Clothing/Footwear, the figure for Italy was 9%, significantly higher than its counterparts, which represented merely around 6%. Moreover, the spending on Leisure/ Education accounted for the least percentage in these categories. The largest amount, namely 4.35% could be found for Turkey, which was more than twice as high as the figure for Spain(1.98%). The rate of Sweden, Italy and Ireland lied separately in 3.22%, 3.20% and 2.21%. C10 Test2The tables below give information about sales of Fairtrade*-labelled coffee and bananas in 1999 and 2004 in five European countries. 6.5 The table illustrates the sales of coffee and bananas with Fairtrade label attached to them in 1999 and 2004 respectively in five European countries. In general, most of the countries experienced an increase in the sales, where the UK and Switzerland had the most remarkable rise among the listed countries. For the sale of the coffee, the UK has the most rapid growth that increased from 1.5 million of euros in 1999 to 20 million of euro in 2004. Meanwhile, the sales in Sweden and Denmark only raised by 0.2 million and reach 1 million of euros and 2 million of euros in 2004 respectively, which is the least among these countries. In 2004, the sales in Switzerland had doubled its sales of 3 million of euros in the year 1999, and the sales in Belgium climbed from 1 million of euros in 1999 to 1.7 million of euros. For the sales of the banana, Sweden and Denmark are the only two countries that has a decline in its sales. While the sales in Sweden dropped from 1.8 million of euros to 1 million of euros in 2004, the sales in Denmark decreased by 1.1 million of euros in 2004 compared with 1999. Besides, only 15 million of euros’ worth of bananas was bought in 1999 in Switzerland, however, the amount climbed up to 47 million of euros in 2004. The sales in Belgium and the UK in 2004 also grew for around 4 million of euros compared with the sales in 1999.","link":"/2022/10/28/zh/english/ielts/writing/task_1/table/"},{"title":"Task 2 优缺点","text":"C4 Test1Compare the advantages and disadvantages of three of the following as media for communicating information. State which you consider to be the most effective. comics books radio television film theatre 7 There are numerous ways to convey a message these day, and each method has its advantages and disadvantages. This essay is going to evaluate the effectiveness of three ways to communicate information, which are books, radio, and television, and conclude that television is the most effective media. Books are best suited to communicate information that are complex and cannot be easily said in a few words, such as knowledge related to certain professions. The reason why books, being one of the oldest way of communicating ideas, survive till this day even when modern society is inundated with all types of technology that make communication fast and easy, is that knowledge is still best delivered in the format of a book, in detailed language and a chaptered structure. However, when it comes to information that isn’t so complex, other medias that have visuals or audios are preferred because it is time-consuming to read. Radio is a more convenient and straight-forward way to deliver information. Not only can people listen to the radio at home, they can also listen to it in the car and on their phones. They can also be doing other things while they are listening, whereas other methods like reading a book require people to concentrate in order to receive the information. One shortcoming of radio is that it is live and can’t be rewinded. Unlike reading a book, when you miss something said on the radio, it is difficult to go back. It is difficult to refer to information already delivered as well. Television is a great invention that makes communication easy and effective. It is visual and thus makes it easy for people to follow and digest information. Being visual in nature also has the effect of drawing people in, something a book full of words or radio that could easily be tuned out would not be able to do. It may not be able to illustrate complex and abstract ideas as effectively as books do, as there are limited space for words in a TV program and having too much words would put people off. Nevertheless, programs like documentaries are proof that television can deliver information that are dense and academic. In conclusion, television is the most effective media for communicating information among the three medias discussed. C5 Test2In some countries young people are encouraged to work or travel for a year between finishing high school and starting university studies. Discuss the advantages and disadvantages for young people who decide to do this. 7 Some people think that it is beneficial for students to take a gap year before entering university. While a gap year is a good opportunity for young people to find out what they like and explore the world before making major life decisions, doing so has its risks because there is no guarantee that young people will use this time wisely. One advantage of taking a gap year is that students can use this time to explore themselves and the world before committing to university studies and before entering society. They have already spent 18 years of their lives studying, and this year is a good opportunity for them to finally do something of their interest or try out different jobs. Doing so would give them valuable experience as well as insights into who they really are and what they really like, which would help them make more informed decisions when they later have to choose their major and their career. One disadvantage of taking a gap year is that it is not a guarantee that students this young will absolutely use the time wisely. If they are not strategic about how they are going to spend the year, what they would eventually end up doing is wasting a year on leisure activities that don’t really contribute to their personal development. Also, as the level of education they received by 18 is not enough for most jobs and one year is not long enough for companies to consider them stable, long-term employees, they would probably end up doing intern jobs where the space for growth is limited. In conclusion, taking a year to travel or work gives students opportunities to explore themselves and the world, but it can also be counterproductive when students don’t use the time wisely. C8 Test2Nowadays the way many people interact with each other has changed because of technology. In what ways has technology affected the types of relationships people make? Has this become a positive or negative development? 6.5 In contemporary society, there has been an uprising trend that owing to the advancement of technology, the mass is capable of commuting with others in a variety of ways and consequently witnesses changes in relationships, which will be explained below. As far as I am concerned, it is a conducive phenomenon. There is no denying that technology has an impact on the relationships of the general public. For one thing, the advent of numerous new digital devices yields benefits for citizens’ communication a great deal. To be more specific, the progress of technology contributes to a large number of modern inventions, from telephone, the Internet to the latest smartphone, which allows individuals to interact with others regardless of location and time. For another, social media enable the mass to develop friendships with various individuals due to the fact that we could currently share things regarding our daily life to platforms, such as Facebook and Instagram and that is why we are able to make friends with individuals from all walks of life. The mentioned development is overall advantageous for the general public. On one hand, it could boost the economy. Since individuals could interact with foreign citizens and companies, chances are that we possess more opportunities to do business with them, thus founding more transnational corporations and gaining more prosperity. On the other hand, this trend is capable of helping citizens broaden horizons and enlargen knowladge through talking with people from other cultures in online platforms. To recapitulate, modern technology has made it easier for individuals to contact even make friends with people from distinctive counties and different age groups and moreover, it is beneficial for us in terms of economic and cultural development. C9 Test1Some experts believe that it is better for children to begin learning a foreign language at primary school rather than secondary school. Do the advantages of this outweigh the disadvantages? 7 There is a belief among some experts that children should begin learning a foreign language at primary school rather than second school. Some people may disagree, saying that foreign language learning gives children too much pressure when they are still navigating their native language. However, the advantages of learning a foreign language in primary school outweigh the disadvantages because the younger children are, the faster and better they pick up new languages. A potential disadvantage of children learning a foreign language in primary school is that it may be too much of an academic burden for kids, especially when they are actually still learning about their own language in primary school. For example, a first-grade primary student in China is learning Pinyin at school. If he or she also has to learn English at the same time, it may be confusing for her to adopt two language systems that use the same alphabets. The end result might be that he of she cannot do well in neither. However, it is proven by science that the younger people are, the faster they learn a new language. Therefore, the best time for a person to learn a new language is as young as possible. Bilingual abilities of children with parents that speak different languages are proof that children can learn and master two languages at a time without getting lost in them. If you wait until a kid is in secondary school to teach them a foreign language, the language will seem much more “foreign” now that they have already built up a language system of their native tongue. In conclusion, the advantages of children learning a foreign language in primary school than secondary school outweigh the disadvantages because the younger children are, the faster they learn a language. C10 Test3Countries are becoming more and more similar because people are able to buy the same products anywhere in the world. Do you think this is a positive or negative development? 6.5 Recent era has witnessed a trend that citizens all over the world could purchase similar products thanks to the advancement of technology and transportation, which results in the increasing similarity of nations. As far as I am concerned, it is overall a detrimental development. To start with, unique cultures of distinctive countries are likely to disappear as a consequence of the mentioned trend. To be more specific, culture is of great significance for nations in that it could contribute to the unity and the sense of belonging of the mass. Provided that individuals around the world use and wear the same commodity, chances are that the general public may ignore its own traditional cultural. Moreover, it is possible that tourism would be affected. When travelers find all the places of interests are gaining similarity, they may lose the willingness to pay a visit or open their wallets in shops due to the fact that souvenirs could not represent the uniqueness anymore. Nevertheless, we ought to realize that this development could also yield benefits for the reason that citizens all over the world have more opportunities to communicate with each other. Using the same product is able to provide individuals with more chat topics. To exemplify, given that girls from different cultural backgrounds are using similar brands of makeup products, they could talk with each other regarding this, thus developing connection between each other. To recapitulate, although the increasing similarity of different nations possesses certain merits, I assert that it is overall a disadvantageous development because it has great influence on tourism and cultures. C10 Test4Many museums charge for admission while others are free. Do you think the advantages of charging people for admission to museums outweigh the disadvantages? 7 Recent era has witnessed a trend that museums enjoy increasing popularity among citizens and it has provoked a passionate discussion whether museums are supposed to ask travelers to pay for the tickets. From my point of view, there are more merits of this policy than its demerits. For one thing, charging for tickets could enable museums improve their management. To be more specific, provided that the general public is not able to enter museums for free, chances are that they would give it a second thought before going there. As a consequence, the flow of people in museums would decline, which is helpful for faculty in museums to provide visitors with better service. For another, earning money from tickets could help museums to better maintain their infrastructure. Museums ought to annually spend a great deal on their maintenance, since most exhibits there are invaluable and historically meaningful. When they are able to earn more money from charging for tickets, they could take advantage of this money to better protect their collections. Nevertheless, we should admit that charging for tickets is to some extent unfair for poor individuals due to the fact that visiting museums is educational. If the mass is asked to pay for it, it is possible that those from affluent families are not capable of affording it. To exemplify, unrich citizens may lose the opportunity to pay a visit to National Museum of China and know about Chinese history, provided that the museum charges for tickets. To recapitulate, although the mentioned policy of museums may not be fair for all the individuals, I assert that its virtues exceed shortcomings. C12 Test2At the present time, the population of some countries includes a relatively large number of young adults, compared with the number of older people. Do the advantages of this situation outweigh the disadvantages? 7 With more advanced medical technologies and reduced infant mortality, the number youthful population starts overtake the number of elderlies in some countries. However, is this a positive phenomenon? In my opinion, it is, and I will discuss both side of the argument in this essay. On one hand, with a large number of young adults, the country could create a secure chain of social security funds. Social security is a system designed to take care of the older population, after they retire. But as the number of elderly increases, the system starts to breakdown. It is a well-known fact now, that nations like China with lesser younger population ratio must divert a large amount of treasury funds towards social security, in order to make the system work, since the system depends on having many young adults support one elderly. With many young adults the system could favor more towards the elderly and hence becoming an incentive for immigration, for example. In addition, having more younger population has positive effects towards stimulating the economy. Elderly population tends to bank their income and savings away, while younger populations are more likely to spend their income and contribute positively towards the cycle of consumer goods and service. With younger adults, nations can achieve economic developments faster. On the other hand, one argument calling for increase in the elderly, is that without the elderly it is impossible to fill some specialist occupations. One example would be skilled workers. A lead electrician or scientist may require centuries of experience, in order for an individual to qualify for that position. Hence, having older population is essential, since their age comes with procured experience that cannot be simply replaced by any young adult. It could be argued however, that in the present day many jobs have simply disappeared, or requires new forms of knowledge such as computer engineering so that the older population are simply obsolete, instead of being invaluable assets because of their experiences. To conclude, based on my analysis, I believe that the advantages of nations having more younger population than older, fully out weights its disadvantages. The future belongs to the youth, and while it is true that older population has its edge, these utilities will eventually diminish and become obsolete. C15 Test1In some countries, owning a home rather than renting one is very important for people. Why might this be the case? Do you think this is a positive or negative situation? 7 In some countries, home ownership is considered highly important and superior to renting one. This is due to the status connotation behind home ownership and the sense of security it provides, but I think it is not a very positive situation since it gives young people too much stress and also hinders their development as a person to an extent. In some countries, owning a home is regarded as a significant feature that differentiates a rich person from a poor one. For example, in China, one of the commonest questions someone, especially a man, is asked on a date or before marriage is whether he owns a house. If he does, he is immediately considered a “golden bachelor” who is respectable and has good marriage prospects. Owning a house is associated with properties like wealth and independence. Home ownership is also tied with one’s sense of security. In contrast with renting a home, owning one means that you have a place of your own and a sanctuary that is entirely yours in this hectic and complicated world. It is sometimes crucial to building one’s sense of independence. However, as the importance of home ownership is continually emphasized nowadays, it puts more and more pressure on our society’s young people. As the ability to buy a house becomes something that defines one’s level of success, people are increasingly burdened and perhaps even blinded by one single goal in their life. In some areas where houses are extremely expensive, like Hong Kong, it would make a young person’s life very stressful. Also, if buying a house becomes the most important goal to achieve in one’s twenties or thirties, young adults will inevitably lose sight of other equally important things in life that they should search for, things like love, friendship, one’s meaning and purpose et cetera. Their whole existence is defined by a material object, which will leave them soul-empty and eventually lost in a pursuit of numbers. Furthermore, a society that asks its workers to work for materialistic achievement would fail to produce holistic and socially aware individuals, which would be a tragedy to watch. In conclusion, people who consider home ownership highly important are driven by a desire to elevate their social status and a sense of insecurity. This is not a very healthy situation because it not only gives young people unnecessary stress, it also make them succumb to materialistic values that forbid them to enjoy life, develop holistically and appreciate the wonders of life itself. C15 Test4In some cultures, children are often told that they can achieve anything if they try hard enough. What are the advantages and disadvantages of giving children this message? 7 Some cultures like to encourage children saying that anything can be achieved if they try hard enough. Saying so to children may make them unrealistic in making life decisions in the future, but it can also cultivate confidence and passion in them. The disadvantage of telling children that they can achieve anything as long as they work hard enough is that they may become unrealistic in life. They could get too fixated in something they are not good at and still believe that one day miracles would happen and dreams would come true. Success is not just about hard work, no matter how important hard work is. It is also about talent and is sometimes a matter of chance. If a kid grows up believing in and chasing after the wrong thing, it is a waste of time and energy which they can put into something else. However, it is a very powerful saying that can motivate children a lot, especially in their hard times. When they feel like giving up on life or on themselves, this belief would carry them through, give them hope that as long as they try harder and harder, things would change for the better. They would have a more positive outlook on life as a result. If children are educated by ideas that are too realistic, they may go on with life without even trying, since they don’t believe in the magic of hard work. That way, they actually forsake the possibility of success. In conclusion, the disadvantage of telling children that they can achieve anything as long as they try hard enough may lead to unrealistic life decisions being made, but the advantage is that children can be motivated, more positive and passionate about life. C16 Test2In their advertising, businesses nowadays usually emphasise that their products are new in some way. Why is this? Do you think it is a positive or negative development? 7 In contemporary society, there has been an uprising trend that companies have the penchant for stressing the novelty of their products in advertisements. There are some reasons for it which will be explained below and from my point of view, it is overall a detrimental development. To start with, new features could appeal more individuals to purchase products. To be more specific, creativity in some products is to some extent synonymous to the fact that they are distinctive from their counterparts, which is able to illustrate the unique taste of consumers and satisfy their curiosity. Food industry is a good case in point. Provided that manufacturers show the new taste of snacks, such as chips, in advertisements, it would become a selling point for them and thus the general public would be more willing to buy them out of curiosity. Despite the fact that this action of businesses makes sense, I am convinced that it would bring demerits due to the fact that it would lead to consumerism. Chances are that customers would purchase products because of its novel characteristics, however without considering whether they are pragmatic or not, which is sure to add to citizens’ financial burden. Additionally, buying more products would be adverse for the environment for the reason that it would produce more waste and greenhouse gas in the process of packing and delivery. To recapitulate, it is reasonable for enterprises to lay emphasis on new features in advertisements in that they are attractive to consumers. Nevertheless, I assert that this phenomenon would be disadvantageous for both citizens and the environment. C16 Test4In the future all cars,buses and trucks will be driverless. The only people traveling inside these vehicles will be passengers. Do you think the advantages of driverless vehicles outweigh the disadvantages? 7 In the future, there will no longer be buses and trucks driven by people, and there will only be passengers in these vehicles. In my opinion, this phenomenon will have more disadvantages than advantages. First, there is yet no guarantee that driverless cars will be accident-proof, so when accidents happen, the party to which responsibility should be placed is disputable. There might be a tendency to place the blame on the car company where the cars are designed and produced, but the malfunction of automatic vehicles that run on complicated technology and highly intelligent algorithm may not be entirely the fault of the engineers who designed them. Since these cars are predicted to make human drivers completely obsolete, they must be based on a highly sophisticated artificial intelligence that, if not surpass, be almost equivalent to a human brain. At this point, it is difficult to decide who shall be responsible for the accident that occurs. Second, the phenomenon implies that there will no longer be a need for human to learn how to drive a car, which leaves the human passengers vulnerable to an automatic machine that does not speak the language humans do. This means that the only humans who are capable of controlling the buses and trucks on the road are the engineers who designed them. When the only people riding these vehicles are passengers, these people are at the mercy of an artificially intelligent machine that could make life-threatening decisions or mistakes. If, for example, the car needs to be stopped or make turn and the technology is not quick enough or does not understand the situation like a human does, there will be no one on the car that can take charge of the situation and turn things around. As none of them can drive, all of their lives are thus depended on the vehicles they ride. This future would only leave humans vulnerable to something their counterparts created. In conclusion, a future where vehicles will be entirely driverless is a dangerous one. It not only makes it difficult to account responsibility when accidents occur, but also leaves human passengers ever more vulnerable as they no longer need to learn to drive. The possibility of phenomenon coming to existence is very probable, and these are the things visionaries should take into account before they endeavor in building technology that humans can’t control. C17 Test1It is important for people to take risks, both in their professional lives and their personal lives. Do you think the advantages of taking risks outweigh the disadvantages? 6.5 In contemporary society, it has provoked a passionate discussion whether citizens ought to attach significance to running risks both in their professional and personal lives. From my point of view, there are more demerits of this action than its merits. On the one hand, making a risky move may result in psychological burdens. To be more specific, it is possible for those who engage in risky behaviors to face failure. Provided that individuals encounter loss, chances are that they suffer from frustration and feel depressed and disappointed. They are even likely to lose the courage to make conducive attempts both at work and life in that they are afraid of being confronted with failure again. Moreover, taking risks could end up with a series of health problems. Generally speaking, risky actions are regarded as dangerous behaviors and thus may lead to accidents. To exemplify, when individuals do extreme sports or experienced athletes give challenging activities a try, it is likely for them to get injured and even become disabled, which would bring inconvenience to their daily lives. Nevertheless, there is no denying that running risks comes with certain strengths due to the fact that it could enable citizens to gain rewards. For instance, successful investments can help entrepreneurs earn good profits and wilderness hiking can let sightseers enjoy picturesque views, which are difficult for individuals who are reluctant to make risky actions to obtain. To recapitulate, although taking risks could help individuals reap the corresponding rewards, I assert that its shortcomings exceed its virtues for the reason that it may give rise to both emotional and health burdens. C17 Test4Nowadays, a growing number of people with health problems are trying alternative medicines and treatments instead of visiting their usual doctor. Do you think this is a positive or a negative development? 7 In modern society, more and more people are trying to solve their health problems with alternative medicines and treatments rather than going to visit their usual doctor. This is a negative development that makes people spend extra money on treatments that do not have a guaranteed effect. It not only gives people extra financial burden but could also make their health problems exacerbate. Alternative treatments are usually not covered by health insurance, so people have to pay extra money for these medicines and treatments. These would mean a staggering bill for people with chronic diseases who need constant treatment and doctor appointments. People would therefore be more financially strained when dealing with their health problems. Moreover, these alternative treatments and medicines do not always guarantee positive outcomes or effects. Patients’ physical conditions may deteriorate as they stop going to their usual doctor, and if their alternative medicines are not doing the trick that they are supposed to, they may be faced with a bigger problem than the one they already have. When patients leave their usual hospitals for alternative treatments, they might also miss the most appropriate time for treatment. In other words, they are likely to miss the best time they could be treated with scientifically proven remedies. In conclusion, the growing popularity of alternative medicines and treatments among people with health problems is not a positive phenomenon as it could place a bigger financial burden on people, and their health problems might also get worse. OG T2P2One of the consequences of improved medical care is that people are living longer and life expectancy is increasing. Do you think the advantages of this development outweigh the disadvantages? 7 Over the past 50 years, people have become used to the idea that they will probably live longer than their grandparents did. However, a longer life is only desirable if you can look after yourself and be independent, otherwise there can be disadvantages for everyone. If you walk into a hospital in my country, you are likely to see a lot more elderly people than you did in the past.In fact, this is causing significant problems as there is a shortage of beds. Medical treatment is keeping the elderly alive, but at what cost to others? On top of this, one of the biggest medical problems these days is dementia. Even if old people are still fit, they may not be able to look after themselves.They may have to live with their children or be cared for in a home, which can be expensive. Elderly people do not like to be a burden, but their children can feel obliged to care for them. Obviously, not all old people become ill, Those who remain healthy can enjoy a happy old age as long as they have saved enough money. People are much more active in their sixties and seventies than they used to be and this can only be a good thing.They have time to enjoy their retirement and do a range of activities that they could not do when they were at work. They can also help look after their grandchildren, which is a great benefit for working parents. To sum up, I believe that we should aim to keep people as healthy as possible so that they can enjoy their old age without having to rely on others. A longer life expectancy is obviously advantageous, but no one wants to live to be 100 if they only cause problems for their family and society. OG T5P2Nowadays technology is increasingly being used to monitor what people are saying and doing (for example, through cellphone tracking and security cameras). In many cases, the people being monitored are unaware that this is happening. Do you think the advantages of this development outweigh the disadvantages? 7 In recent years, advances in technology have allowed governments, the police and privately owned companies to keep the public under constant surveillance. In many major cities and towns, security cameras are recording the movements of ordinary citizens. Whenever a cellphone is used, the call is logged, so the service provider knows exactly when and where the user made the call. Invisible satellites orbit the Earth, watching us whether we like it or not. Is this, however, a development we should welcome? Certainly there are benefits. In areas where there is a high crime rate, the use of security -cameras may act as a deterrent to criminals: if they can see a camera, they may think twice about breaking into a building or stealing a car. If a crime is carried out, then a camera may provide useful evidence. The same is true for a cellphone; the police sometimes rely on call logs to help them trace the whereabouts of suspects or victims. On the other hand, there are a number of concerns.In countries where human rights are ignored, the use of security cameras or listening devices may be harmful to society. People should be able to hold meetings and express their opinions without their privacy being invaded. There is also a very different issue we should consider. Nowadays. many people upload personal information and photographs onto social networking sites; they often do not realise how easy it is for other people to view this information or for the site owners to use the data or photographs for their own financial gain.It seems inevitable that there will be more and more ways to monitor society in the future. However, it is our responsibility to evaluate new technology and decide whether it will do more harm than good. Surely our freedom is more valuable than technological progress?","link":"/2022/10/30/zh/english/ielts/writing/task_2/advantage_disadvantage/"},{"title":"Task 2 同意&#x2F;不同意","text":"C4 Test3Creative artists should always be given the freedom to express their own ideas (in words, pictures, music or film) in whichever way they wish. There should be no government restrictions on what they do. To what extent do you agree or disagree with this opinion? 7.5 Some people believe that artists should be allowed to express their ideas freely and should not be restricted by government regulations. This is dangerous because wrong ideas may be spread and normalized by such artistic freedom and influence young people, and it may lead to chaos in society if controversial ideas are allowed. Artistic freedom can be harmful if there are no restrictions on what artists’ content can be. A recent TV series about high-schoolers, Euphoria, is very popular among young audience. However, it contains large amount of scenes with violence and drug use that could be misleading for kids and teenagers. TV normalizes behaviors that are unacceptable in real life. Regardless of what the producers’ original intentions with these content might be, they could still give young people who don’t have good judgment the wrong idea, which could be dangerous once they get used to such content and maybe start imitating them in real life. Secondly, if there is no censorship on what artists can create and express, certain artists who hold controversial or provocative views may use this as an opportunity to cause chaos in our society. Art may be used as a medium to express poisonous and provocative ideas, like racist, sexist comments. They would disrupt the peace of society and if they happen to find people who agree with them, our society would be polarized into different groups that hold hostile ideas about each other. Government restrictions on art is necessary if we want to maintain a peaceful society. In conclusion, there should be government restrictions on artistic expression in order to protect young people from receiving misleading ideas and prevent extremists from disrupting the peace of our society. C5 Test1Universities should accept equal numbers of male and female students in every subject.To what extent do you agree or disagree? 7 In contemporary society, it has provoked a passionate discussion whether gender difference ought to exist in the enrollment of universities. Some individuals are convinced that universities should recruit the same volume of male and female students in every respect, with which I completely disagree. One reason for my disagreement lies in that male and female possess distinctive modes of thinking. To be more specific, male have the penchant for thinking more logically and rationally, whereas female tend to view things more emotionally. As a consequence, the number of male and female students is supposed to vary from subject to subject. To exemplify, due to different thinking ways, male students are more likely to have a taste for science subjects, such as Information Technology, based on which relative faculties in universities enroll should more male than its counterpart. Moreover, the different social responsibilities of male and female could account for my disapproval. Despite the fact that the society nowadays lays great emphasis on women’s right, female still plays a distinctive social role from male. The reason why it is the case is that female is regarded to be more considerate and compassionate than male, thus performing better in the fields, like education. In this respect, it is not advisable for educators to admit equal number of male and female students in every subject. To recapitulate, I hold the view that universities should enroll different numbers of male and female students in a variety of courses in that gender difference could be found in the modes of thinking and duties in our society. C6 Test1Today, the high sales of popular consumer goods reflect the power of advertising and not the real needs of the society in which they are sold. To what extent do you agree or disagree? 6.5 Commercial advertisements are everywhere in today’s world. Higher sales than ever on products may seem to suggest a higher demand for consumer products. However, some suggests that these high sales are caused not because of popular demand, but the power of advertisements. I would agree that the high sales does not always reflect the power of advertisement, and in this essay, I will explain my reasons. Advertisement has evolved over the years, from simple road side billboards, plaques by the streets to videos attached onto applications or webpages, they have come a long way. But while their styles changed immensely, their purpose has not. Through evolution they are now able to catch people’s attention better, convey their information faster and clearer, and present their product better. It is through these advertisements that more and more consumer products new and old are know to the wider public, which in turn increases sales of these products. On the other hand, the increase in consumer goods sale does somewhat reflect a real need for these items, created by a general increase of economic wellbeing across societies, generating new needs and wants for many. If there were no such increase of economic wellbeing, it would be impossible for many to pursue these luxuries and consumer goods, and no advertisement will be able to increase sales if consumers are unable to afford them. What’s more, many products need no advertisement and still see massive increase in sales, due to creation of real needs. Demands for masks, sanitizers and alcohol sprays has increased dramatically over the past few years due to the pandemic, but there are no ad campaigns related to them but are instead created by the recent pandemic, reflecting real needs. In conclusion, even though that advertisement nowadays is extremely effective in penetrating into its target audience, high sales in the real world largely owe to a general increase of wealth, generating new needs and current trends and events that create momentous demands. C8 Test3Increasing the price of petrol is the best way to solve growing traffic and pollution problems.To what extent do you agree or disagree? What other measures do you think might be effective? 7 Some people think that raising the price of petrol is the best way to resolve traffic and pollution problems, but I don’t agree with this statement because there are still people who are able to afford the higher prices and if people’s lifestyle doesn’t change the situation would probably remain the same. A better way to relieve traffic and pollution is to promote the use of electric cars. Raising the price of petrol would not solve traffic and pollution problems because there are still people who can easily afford the raised prices, especially in economically well-off areas. People who contribute to traffic and pollution problems in the society are mostly likely people in the middle class and are used to a lifestyle that relies heavily on traveling by car. They would not switch to public transport or other ways of transport easily just because the price of petrol goes up. Therefore, other methods should be used to deal with the growing pollution and traffic problems. One way to solve traffic and pollution problems is to promote the use of electric cars. For example, in some big cities in China, regular cars are only allowed to be on the road on certain days of the week according to their plate numbers while electric cars are allowed to be on the road any day of the week. This measure encourages people to purchase electric cars instead of regular ones and relieves the city’s traffic and pollution problems at the same time. It is a smart method because it does not require people to change their lifestyle fundamentally by switching to public transport of traveling on foot. In conclusion, raising the price of petrol isn’t the best way to solve a city’s traffic and pollution problems because majority of the people who contribute to said problems can still afford the higher price. A better way to solve these problems would be to encourage the use of electric cars like some cities in China do, because this way still allows people to keep their original lifestyle while effectively lowering pollution levels and relieving traffic. C9 Test2Some people believe that unpaid community service should be a compulsory part of high school programmes (for example working for a charity, improving the neighbourhood or teaching sports to younger children). To what extent do you agree or disagree? 6.5 The rapid growth in our society results in worsening equality caused by social reproduction. The rising amount of people in need raise many people’s concern on the quality issue and claim that it should be compulsory for unpaid community service to be included in high school programmes. As far as I am concerned, I strongly disagree with this view. To begin with, forcing students to care about others may be a waste of time for both the school and the participants. If these caring events are voluntary, only teenagers who devote themselves to social welfare will participate in them with great passion. However, once providing voluntary service become a mandatory task where all the pupils need to join, participants who are not interested in this area may feel reluctant and spend their time doing nothing. For example, pupils may walk around when they are supposed to chat with the elderly. Therefore, making charity events compulsory may lead to a situation where youngsters are spending the time in certain events but doing nothing. Secondly, it might be hard to ensure the service provided by the programme. Since not all the students are altruistic, it seems risky to put those immature young adults into community work. For instance, they may be rude to those people who live in poverty. However, since there might be many young adults in the programme, it may impossible for teachers to scrutinize each of them carefully. In this way, the quality provided by the students may be in a judgement call. In conclusion, though it seems like making voluntary community work into mandatory programmes for youngsters can provide more help to society, the use of time and the quality of the services may not be as good as it has been expected. Therefore, it might be better for schools to leave the altruistic event to those volunteers who are interested in it instead. C9 Test4Every year several languages die out. Some people think that this is not important because life will be easier if there are fewer languages in the world. To what extent do you agree or disagree with this opinion? 7 Every year a couple of languages go extinct. Some people consider the extinction of languages unimportant because life will be easier if there are fewer languages in the world. I agree with this statement because it will make trading and cultural exchange a lot easier, and that the reason why languages can die out is because they are out of use, which means that they are not needed in the modern world anymore. If people around the globe can communicate with each other in only a handful of languages, it will save us a lot of money, time and manpower to translate in trading, cultural and academic exchanges. Right now, a lot of the world’s important and precious knowledge and findings are not accessible to certain populations because of language barriers, and some exotic places have knowledge and cultures that they cannot share with a bigger audience also because they don’t speak a mainstream language. If the world functions in fewer languages, it will be beneficial to commercial, cultural and academic exchanges as people can communicate more freely. Also, the fact that certain languages die out is the evidence that they may not be that important in the first place. Languages that die out are either too complicated or irrelevant to the modern world, therefore their extinction is not that important because we actually didn’t lose anything too important or precious. They die out because they are outdated, out of use and possibly replaceable. In conclusion, the extinction of languages is not an important issue because first, if there are fewer languages in the world, trading, cultural and academic exchanges can be much easier; and second, languages die out because they are not needed in the modern world anymore, and thus should not be a concern. C10 Test1It is important for children to learn the difference between right and wrong at an early age. Punishment is necessary to help them learn this distinction. To what extent do you agree or disagree with this opinion? What sort of punishment should parents and teachers be allowed to use to teach good behaviour to children? 7 There is no denying that educators are supposed to lay great emphasis on teaching the younger generation to distinguish the right from the wrong when they are still kids. Some hold the view that punishment plays a significant role in this process, with which I partly agree. On one hand, I agree that punishing children is a crucial way for parents and teachers to cultivate the ability to tell right from wrong, since it could serve as a deterrent. On the other hand, I argue that they should be flexible while applying this approach. To be more specific, characters and mindset vary from child to child, which consequently asks educators to change their teaching methods according to children’s personality and ages. Those in their puberty is a good case in point. As is known to all, adolescents in this period tend to be rebellious because of hormone and that is why parents’ and teachers’ excessive punishment is likely to have the opposite effect. In this respect, it is advisable for educators to adopt proper and moderate punishment. Making the punishment fit the crime is a conducive way due to the fact it would not only tell children the inadequacies of their behaviors but also lead to better deeds in years to come. To exemplify, provided that a kid drops rubbish in the street, parents and teachers should let he or she pick up it and also apologize to those they he or she may interrupt, which would also be helpful in developing children’s responsibilities. To recapitulate, I do not deny that punishing children is a beneficial teaching method and nevertheless, I assert that it ought to be flexible and modest. Personally speaking, making the punishment according to the crime would yield benefits for younger adults. C11 Test1Governments should spend money on railways rather than roads. To what extent do you agree or disagree with this statement? 7 With modern innovations such as high-speed rail and bullet train, some argue that roads are becoming irrelevant and funds should be diverted elsewhere. However, in my opinion, I think that roads are still worth spending money on. In this essay I will explain my reasonings. One argument for spending on roads, is that they are a lot cheaper to build. While it might be true, that once a railroad is built its upkeep is less than freeways, initialization cost of heavy railways, high speed railways are significantly more expensive than building freeways and roads. The discrepancy becomes even more apparent, when we consider constructing transport to challenging terrains, such as mountainous areas where tunnels need to be constructed for railways. What’s more, roads are more versatile than railways. It is common knowledge that in order to build railways, it requires a large space to be cleared in order for smooth operation, as well as a long time for constructing the actual railway. For roads however, they can squeeze into tighter spaces, require little to no destruction of structures, and can be paved or hardened overnight. This provides roads a unique edge over railways, since its versatility makes it more suitable in semi-permanent scenarios, as well as in emergencies when one needs to connect 2 locations quickly. There are certainly evidences suggesting that railways are much better than roads. For example, railways are much more efficient at transporting people. It is shown that a railway line can transport almost 3 times more people from one location to another, than using highways. Railway carriages also provide a more comfortable experience, in addition to capable of reaching a much faster speed than cars. However, the clear limitations for railway construction hinders these advantages, bounding railway usage within specialized contexts. In conclusion, I think that even though railways are very advantageous, they fall short in certain areas, such as versatility and economics. Therefore, I think that funds for road building should not simply be diverted towards railway construction, since both types of transport serves a purpose, that cannot simply be substituted by one-another. C11 Test2Some people claim that not enough of the waste from homes is recycled. They say that the only way to increase recycling is for governments to make it a legal requirement. To what extent do you think laws are needed to make people recycle more of their waste? 6.5 In contemporary society, some citizens attach increasing significance to the recycling of the waste from home and they are convinced that only the enaction of relevant laws could help this situation, with which I partly agree. On one hand, there is no denying that laws could enable the general public to recycle more of the waste. Firstly, the advent of relevant rules could serve as a reminder for individuals due to the fact that a number of citizens do not recycle because in their daily life, they are not aware of the importance of doing so or they do not have time to think about this issue. In this respect, enacting laws is helpful for them to cultivate this conducive behavior. Additionally, the appearance of laws makes the recycling of the waste a must for the general public and is regarded as a deterrent, since the mass know that once they do not abide by this law, they would be punished. On the other hand, I assert that apart from laws, the action of schools and the media could also make contributions. To be more specific, through covering more news regarding the recycling of waste and making more non-profit advertisements about it, the media is able to increase individuals’ awareness. Furthermore, teachers could educate the meaning of recycling to the younger generation, letting more individuals be willing to do so in years to come. To recapitulate, although I admit that making laws is critical to increase recycling, I hold the view that we are not supposed to ignore the efforts of others, such as journalists and educators. C13 Test1Living in a country where you have to speak a foreign language can cause serious social problems, as well as practical problems. To what extent do you agree or disagree with this statement? 6.5 There is a saying that living in a foreign country where a foreign language is spoken can lead to severe social and practical problems. I do not agree with this statement because while it is reasonable to predict that issues would arise when different cultures meet, the actual situation won’t be that difficult as long as people on each party interact with respect and an eagerness to understand each other, not to mention there are plenty of tools that can help us communicate with foreigners. Living in a foreign country and having to interact with people that speak a different language does pose certain challenges. A person may accidentally offend the local people if there are language barriers between them, and he can also face a lot of difficulties in daily life trying to survive in an environment where he does not how to communicate properly and effectively. For example, there has been a case where a Chinese person said “that” involuntarily in Chinese in America, and the Chinese word “that” sounds a lot like the English word “nigga”. The word “nigga”, being a highly politically incorrect and offensive word in an American context, naturally caused chaos and even outrage in the society. Likewise, practical problems arise when a person does not know how to speak the local language. For example, he or she may have to spend an unnecessarily large amount of time just to get the groceries they need in the supermarket. Asking for directions becomes a challenge too, if one does not how to communicate his needs to the local people. If you get lost in a foreign country, it would be very difficult and troublesome to explain to a passerby or a police officer. Therefore, not knowing the local language can present a considerable amount of trouble to a person living in a foreign country.However, as much as the troubles that might befall us in a foreign country are difficult to solve, it does not mean that they are unsolvable. In fact, tools like sign language, body language, drawings and modern translation apps can come in handy in the aforementioned situations. Again, imagine one getting lost in a foreign country and does not how to find his way home or not knowing how to find a particular item in the shops, they can draw out what they are trying to say on a piece of paper or their phones, and you would be surprised how much some simple sketches and body language can tell. Translation apps are also getting more and more advanced nowadays where people can simply type in their questions and give it to the local people in order to communicate effectively with each other. What is more, understanding and respect matter when two cultures meet. Despite our differences with each other, we are ultimately humans and we have the ability to understand and forgive. When language and cultural barriers put us apart, we can welcome the differences and try to understand the other party with respect. If a person speaks offensive language because he does not know the language well, like the Chinthe other party can tell them and educate them in peace and with understanding. Living in a foreign country is hard, but what we can do is to have faith in mankind and believe the best in people, whether we are the visitor or the host, so that no matter how great and unsurmountable our differences are, we can resolve them and maybe even achieve friendship in so doing. In conclusion, there are a number of social and practical problems when a person lives in a foreign country that speaks a different language, but those problems can be resolved by tools like drawings, sign language and body language, and technology like translation apps, and also by mutual understanding and respect. It is immature to assume that people that speak different languages cannot communicate, because communication does not only happen in words, they can also happen in ways beyond mere speaking and in the fact that we are humans with the ability to understand and respect. C13 Test2Some people believe that nowadays we have too many choices. To what extent do you agree or disagree with this statement? 7 Some people think that we have too many choices nowadays. The modern society is, indeed, saturated with myriads of options and choices but that should not be considered as a bad thing. I would argue that choices are good because they guarantee diversity and possibilities in a society, both are good for people’s growth and a society’s development. First, the abundance of choices in a society means that this society welcomes and encourages diversity which can lead to a higher quality of life for its citizens. For example, if a supermarket provides products from all around the world instead of providing local products solely, customers can benefit from the opportunity to enjoy all ranges of products, from exotic food and beverages to novel appliances designed by the world’s best minds. If we settle for only one way a product is done, we would lose the opportunity to see how things can be done better, and thus never get to see what a better version of the world that we would be living in could be. The various choices we have now also mean that the modern world is filled with creativity and possibilities. The choices in question not only include the ones we make when we go shopping, but also those we make regarding our lives. Modern society provides with us infinite ways to be successful. The development of social media and technology and a lot of other modern-day businesses mean that a young person can build a career of his own in ways we couldn’t even imagine before. Choices like these mean that one is not bounded by one way of living, that going to college is not the only way to be a successful and respectable person. Not to mention the possibilities women now have as society offers more and more choices to them - a good marriage is no longer the only way of living for a woman. Therefore, the more choices people are given in a society, the more possibilities and freedom they have in life, which would add to not only individuals’ but also a society’s wholesome development. In conclusion, choices are good for individuals and society because first, they promote diversity and encourage healthy competition in industries so that people can have better and better quality of life; second, choices mean that there are more possibilities for people, meaning that they are free to explore life in all kinds of creative ways, to define success and pursue dreams in an environment that welcomes and celebrates diversity and creativity. A society full of choices is one that can grow and allows for individual growth. C14 Test3Some people say that music is a good way of bringing people of different cultures and ages together. To what extent do you agree or disagree with this opinion? 6.5 The revoluntion in music results in a more diverse genres in contemporary life. Recently, the debate on whether music is a good way of bringing people of different cultures and ages together has been heated. As far as I am concerned, I agree with the idea that music can bring people together to a large extent. This essay will outline both sides of the view and elaborate on them. To begin with, music helps break geographical barriers and the differences between ages. The develpment of technology and globalisation expose people to a wider range of music around the world and have a more convenient access to communicate with each other. For example, people who enjoy K-Pop in the US can share their appreciation with someone in Japan through social platforms like Youtube no matter what their ages are. Moreover, since there is no any restriction on cultures or ages to join the fans club for certain types of music, people can become friends easily once they find someone who share the same interest as theirs. However, if people are too exclusive to embrace other genres besides their preference, arguments between different genres may be created which can drive people apart. For example, rap lovers may feel sick of listening to countryside music. In order to show their loyalty towards the music they like, they might judge other melodies by leaving bad comments on media sites. Since people who share the same culture may also have distinct taste on music, fights may be caught easily once people start despiting other’s flavor. In general, music is a good way of bring people of different cultures and ages together as it helps break geographical barrieres and the age differences for those who share the same taste in music. Nevertheless, it could also seperate people apart once they are being too exclusive. Since most people focus on their own interest only, music helps connect people from diverse backgrounds most of the time. C15 Test2In the future, nobody will buy printed newspapers or books because they will be able to read everything they want online without paying. To what extent do you agree or disagree with this statement? 6.5 In contemporary society, there has been an uprising trend that individuals have the penchant for acquiring information via Internet instead of via newspapers or book. Consequently, some citizens are convinced that people won’t purchase printed newspapers or book, with which I completely disagree. For one thing, it’s unrealistic that nobody will purchase printed books or newspapers. To be more specific, compared with consuming books, it can be a burden for the families from a wide range of developing countries to buy computers due to the imbalanced economic development. Furthermore, there are plenty of people who are simply fond of the experience of holding a book or newspaper, which can enable them to calm down in comparison with looking at the screen of computers or cell phones. For another, reading everything online can lead to several negative consequences. To start with, conventional printing industry has created a number of job opportunities for the public and thus once nobody purchases newspapers or books in print, many citizens, such as those working in the publishing houses or journalists are likely to be unemployed. In addition, spending too much time staring at screens can trigger a series of health problems. Provided that individuals lead a sedentary lifestyle, they may suffer from obesity. When young adults look at computers to read for a long time, chances are that their eyesight would decrease. To recapitulate, I assert that despite the popularity of reading online, conventional reading mode would still be indispensable for the reason that it is both unrealistic and disadvantageous for the general public to abandon it. C16 Test3Many manufactured food and drink products contain high levels of sugar; which causes many health problems. Sugary products should be made more expensive to encourage people to consume less sugar. Do you agree or disagree? 6.5 In contemporary society, there has been an uprising trend that the overconsumption of sugar could be found in both food and beverage industry, which would trigger a series of health problems, such as tooth decay and diabetes. As a consequence, some assert that raising the prices of sugary products could tackle this dilemma, with which I completely agree. For one thing, making sugary products more costly could prevent citizens from buying them due to the fact that prices play a significant role in consumers’ choice during purchase process. Therefore, provided that the general public is required to spend more money on sugary products, they are likely to find these products not valuable for their prices and then turn to purchase other commodities. In this respect, higher prices of sugary products could reduce individuals’ dependence of sugar and help them lead healthier lives. For another, increasing prices of sugary products enables manufacturers to produce more health-conducive food and drink. To be more specific, if higher prices of sugary products incentivize citizens to buy alternative food and beverages, chances are that this modification in consuming behaviors would urge companies to develop other products to satisfy consumers’ taste. Coca Cola is a good case in point. When the general public is reluctant to buy those expensive and high-sugar drinks, this corporation would sell more zero-cola which contain no sugar and enjoy great popularity among consumers. To recapitulate, I hold the view that higher prices of sugary products could not only encourage individuals to intake less sugar but also urge food and beverage industry to accordingly change its products, making contributions to the public’s health problems. OG T4P2In some countries an increasing number of people are suffering from health problems as a result of eating too much fast food. It is therefore necessary for governments to impose a higher tax on this kind of food. To what extent do you agree or disagree with this opinion? 7 The growth of the fast food industry has, without doubt, impacted on the eating habits and the health of many societies around the world. Diabetes, high cholesterol, heart and respiratory problems are all on the rise due to fatty and sugar rich food. However, the question is whether higher tax would improve this situation or not. From an economic point of view, higher tax might seem sensible. In countries such as the USA. Australia and Britain, the healthcare system spends a large part of its budget on people with diet-related health problems. It could be argued that these people have caused their own illnesses because of their choice of food. In this case, why should they expect the state to pay for their treatment? The tax could help fund the healthcare system. However, we also need to consider which socio-economic group consumes fast food as the main part of their diet. Statistics indicate that lower income groups eat more of this food than wealthier people. One possible reason for this is that fast food is far cheaper than fresh produce. This is because many governments offer large subsidies to farmers who provide products for the fast food industry, such as corn, wheat and beef. Fruit and vegetables, on the other hand, are not subsidised. Research suggests that many families simply cannot afford to buy healthy food or pay higher taxes on fast food.For them, fast food is not a choice but a necessity. In conclusion, imposing a higher tax on fast food does not seem to be the answer. If the government chose to do this, it would only lead to greater poverty and families facing further hardship. OG T7P2The continued rise in the world’s population is the greatest problem faced by humanity at the present time. What are the causes of this continued rise? Do you agree that it is the greatest problem faced by humanity? 7 As members in the metropolis,most of us have had enough of the troubles that caused by the continued rise in the world’ population. What factors lead to these phenomena and what impacts it may bring have become a concern to many people.From my point of view, the following reasons should be taken into considerations. To begin with, the current stable economic circumstance is a great influential factor.Social and economic circumstance has a dramatic effect on people’s living condition. According to an international survey, more than 50 percent couples in the world are able and willing to raise more children, which will probably lead to a new wave of population explosion. Of equal importance is the rapidly developing national medical care system. Development of modern technology has always been amazing.Certain diseases such as tuberculosis and dysentery are now easy to remedy with low expense, but in the past, they are all probably lethal. It is hard to imagine that an individual who lived in the past might even die of a toothache. Dental technology seems developed little except its exorbitantly charged bill, however, to our surprise, the simplest technique contributes to people’s longevity most. Doubtlessly, the population problem can be regarded as one of the most serious issues faced by humanity. It may bring about many unexpected crises, like the employment problem and the aging problem, which are not only the stumbling blocks for the future development of the society, but also the pressures for resources carrying capacity. All in all, although the problem of increasing population may seem difficult to eliminate, there are concrete steps that can be taken to control that worldwide.The negative effects from this problem is too great to ignore.","link":"/2022/10/30/zh/english/ielts/writing/task_2/agree_disagree/"},{"title":"Task 2 讨论观点","text":"C5 Test3Some people think that a sense of competition in children should be encouraged. Others believe that children who are taught to co-operate rather than compete become more useful adults. Discuss both these views and give your own opinion. 7 Recent era has witnessed a passionate discussion regarding children’s education. While some parents lay emphasis on children’s sense of competition, others are convinced that collaboration is of greater value to kids’ development. I agree with the former point of view. On one hand, those who attach significance to the sense of competition hold the view that it could help children adapt to society in years to come. There is no denying that in modern society, the public encounters fierce competition and stress from both their colleagues and supervisors. Consequently, provided that kids could learn to compete with others, they are more likely to face hardships bravely in the future, thus gaining an edge over others. To exemplify, when leaders assign a challenging task in the workplace, those with higher sense of competition is more able to be motivated and set a clear goal to overcome it. On the other hand, some individuals regard cooperation as crucial in that it could equip kids with better interpersonal relationships. To be more specific, citizens currently depend on each other a great deal in terms of study and work, based on which individuals could develop closer connections, if they know how to interact with others and are more willing to collaborate with them. In this respect, it is less likely for them to suffer from loneliness in daily lives. To recapitulate, although cooperation is capable of enabling children to develop friendships, I assert that the sense of competition plays a more important role for the reason that it could adjust them to the future stressful society. C6 Test2Successful sports professionals can earn a great deal more money than people in other important professions. Some people think this is fully justified while others think it is unfair. Discuss both these views and give your own opinion. 7 Some people think that successful sports professionals’ high salaries are justified, while others think it is unfair. While it should be acknowledged that sports professionals’ success is the result of years of hardship and hard work, there are other professions that are not as well paid but should be, like doctors. On one hand, it is understandable that successful sports professionals receive high salaries since their success is the result of incredible talent and hard work. Not a lot of people can endure the hardship needed to train for success, so those who are able to pass the test and become champions should be heavily rewarded. However, when you think of other professions who played a vital role in the development of society and humanity and how little they are paid compared to sports stars, it doesn’t seem all that fair. Doctors, for example, are an important profession that no society could live without. In comparison, sports stars are less important as they are basically entertainment to people, while doctors’ job deals with life-or-death matters. In this light, doctors should be paid as well as, if not better than, sports professionals. In conclusion, sports stars’ high salaries are not justified and there are other more important professions that deserve a higher income such as doctors. Although the talent and hard work of successful sports professionals should be acknowledged and rewarded, they are still part of the entertainment industry which is not a necessity to people’s life, unlike medical professionals whose job is to cure diseases and save lives. C6 Test3Some people believe that visitors to other countries should follow local customs and behaviour. Others disagree and think that the host country should welcome cultural differences. Discuss both these views and give your own opinion. 7 Recent era has witnessed a rapid advancement of tourism and it has provoked a passionate discussion whether visitors are supposed to adopt local customs and behaviors when travelling. While some support this point of view, some argue that host countries ought to possess an open mind to this issue. I agree with the latter point of view. On one hand, those asserting that sightseers should behave themselves as citizens in host countries do are convinced that it could avoid unnecessary disputes. To be more specific, customs and behaviors are to some extent closely connected to local individuals’ religious belief. Consequently, when travelers fail to follow local customs, chances are that their behaviors would be regarded as disrespectful or even provocative by local residents, thus leading to conflicts. To exemplify, if sightseers in middle eastern countries wear revealing clothing such as short skirts, the locals would feel discontented and quarrel with them. On the other hand, some individuals hold the view that host countries need to accept cultural shock due to the fact that it could appeal to more tourists from other culture backgrounds and as a result, contribute to economic growth. To cite those relatively conservative nations as an instance, when the host countries are able to accept the behavior of showing affection in public, such as men and women holding hands or kissing, they are sure to attract more travelers from western countries. To recapitulate, although accepting tourists’ distinctive behaviors may result in certain conflicts, I believe that it is advisable for host countries to be open to this for the reason that it could help them gain more prosperity. C6 Test4Some people prefer to spend their lives doing the same things and avoiding change. Others, however, think that change is always a good thing. Discuss both these views and give your own opinion. 7 Some people among us prefer change to continuity, while others consider change to be something undesirable. The latter would argue that you could only master something by focusing on it for a long period of time, but the former contends that change is what brings new possibilities, innovation and improvement. This essay discusses both of these views and decides that change is a good thing. Doing the same things over and over is what leads to perfection. Those who master certain skills, such as world-famous pianists and cooks, get to where they are by practicing the same skill day and night for decades. If they diverge to other things during those years just to experience new and fresh things, they would not be as successful and professional as they are now. Doing the same thing over and over again indicates dedication which is a key part of success. However, change is also desirable in situations where innovation is needed. Those who are responsible for some of the most important inventions and revolutionary changes in modern society embody the beauty and greatness of change. For example, the founders of Facebook and Taobao revolutionized the way people socialize and shop respectively, bringing immense change as well as convenience to the world while becoming one of the richest people in the world themselves. Their success are partly a result of their innovative thinking and willingness to bring about changes. Although we do need professionals who have practiced their profession for a long time and are good at what they do, the world’s progress depends on people who can bring change. In conclusion, though doing the same things and avoiding change could perhaps lead to success, being welcome to changes and being able to bring about change are what lead to progress. Therefore, change is preferred to continuity. C7 Test1It is generally believed that some people are born with certain talents, for instance for sport or music, and others are not. However, it is sometimes claimed that any child can be taught to become a good sports person or musician. Discuss both these views and give your own opinion. 6.5 Recent era has witnessed a passionate discussion regarding the factors contributing to the success of an outstanding athlete or musician. While some are convinced that innate talents are of significance, some argue that citizens ought to attach more importance to education. I agree with the latter point of view. On one hand, those regarding inborn virtues as crucial believe that there exist some individuals with inborn talents that can help them become would-be winners. To be more specific, it is genes that serve as the overwhelming reason for individuals’ success, and without it, there is little likelihood to become elites in certain fields. That is why an increasing number of parents make efforts to observe the innate virtues of their kids and cultivate them. On the other hand, some citizens hold the view that every kid is able to succeed with the help of trainings due to the fact that education could equip children with adequate knowledge and proper methods in certain areas and also motivate them from time to time. As an old saying goes, genius is one percent of inspiration and 99 percent of perspiration. To exemplify, numerous world champions attribute their success to their coaches’ guide and their arduous trainings when they are interviewed after games. To recapitulate, despite the fact that some individuals are born with certain innate talents, I assert that we should by no means be ignorant of the value of teaching in that it could endow children with basic skills as well as encouragement. C7 Test2Some people believe that there should be fixed punishments for each type of crime. Others, however, argue that the circumstances of an individual crime, and the motivation for committing it, should always be taken into account when deciding on the punishment. Discuss both these views and give your own opinion. 6.5 With the advancement of our society, recent era has witnessed a passionate discussion regarding punishments for crimes. While some citizens regard fixed punishments for each crime as proper, some are convinced that punishments ought to vary according to circumstances and the motivation of crimes. I agree with the latter point of view. On one hand, those arguing that there ought to be fixed punishments hold the view that this policy could better deter citizens from committing crimes. To be more specific, provided that individuals know they would face certain punishment once they behave themselves illegally, they are more likely to give it a second thought before acting. Imprisonment as a fixed punishment is a good case in point. Likelihood of losing freedom in prisons can most effectively prevent citizens with an inclination to crime from doing harms to society. On the other hand, other people are convinced that it would be fairer to have flexible punishments. This is because reasons for crimes may differ from case to case, and numerous crimes with the purpose of self-defense could be found in society. By no means could they be treated equally with other malicious crimes. Additionally, the authority should take the difference of various criminals into account. To exemplify, it is not humane to punish the elderly criminals in the same way with others in that they have worse health conditions. To recapitulate, although fixed punishments could serve as deterrent, I assert that punishments are supposed to be more flexible for the reason that it would be more humanisitc. C8 Test1Some people think that parents should teach children how to be good members of society. Others, however, believe that school is the place to learn this. Discuss both these views and give your own opinion. 6.5 Recently, the debate on whether parents or schools should teach students how to be well-behaved in society has been heated. While some people argue that it is parents’ duty, others claim that it should be learnt at school. As far as I am concerned, theories might be easier for parents to teach at home while school may provide insight into their behaviour. To begin with, parents are the best teachers for those good traits that contribute to a good member of society. As young kids spend most of their time with parents before getting into kindergarten, they will learn a lot from their parents during the time. For example, children can learn how to be polite in their daily lives. As a result, family members are playing an important role in letting their kids know what behaviours are good. However, schools may be a better place to see whether students are applying decent behaviour in their lives. Since some kids may not have many siblings at home, attending school seems like sending them into a small society. For example, they need to learn how to make friends and how to share in kindergarten. Therefore, these interactions with each other allow teachers to see whether a kid is misbehaving or not. In conclusion, since family and school are two different institutions with separate roles, it seems most effective in building young people’s behaviour with family members teaching them theoretically and teachers in schools help examine whether students are following their guardians’ words. C9 Test3Some people say that the best way to improve public health is by increasing the number of sports facilities. Others, however, say that this would have little effect on public health and that other measures are required. Discuss both these views and give your own opinion. 6.5 Coming technological advancement has led to a more sedimentary lifestyle for many. Numerous proposals has been made to improve public health, and one such suggestion is to increase the number of sports facilities. I believe however this is not the optimal solution and other methods, such as health advertisement would be more effective. Firstly, building new sport facilities would increase stress on public expenditure. Modernized and technology intensive fitness facilities are not cheap to set up, and will take extensive funds to build these sport facilities. It is a significant cost, and some other solutions that might be equally effective in improving public health, such as creating healthy living advertisements and leaflets are much cheaper. In addition, it is inevitable that many will simply refuse to go to these facilities. For many people, the problem is usually not that they cannot find a sport facility to exercise, but rather they are too busy, or lazy to go to these facilities. Since we cannot force people to go to these sport facilities, it is unlikely by creating these facilities we can attract this portion of people to exercise, hence improve overall public health. On the other hand, these new sports facilities will be appealing to the public, since they will be brand new and will likely be able to allow more people exercising at the same time. But again, this will only be effective for people willing to exercise, but not for those less willing to exercise and hence will have little impact on overall public health. In conclusion, I think that increasing the number of sport facilities will not be able to improve overall public health, and is more disadvantageous than advantageous. Even though increasing facilities allows more to exercise at the same time, it is costly, and does not address the populations that are less willing to exercise. Creating advertisement campaigns and leaflets for healthy eating and life style would be a cheaper, yet more effective method overall. C10 Test2Some people think that all university students should study whatever they like. Others believe that they should only be allowed to study subjects that will be useful in the future, such as those related to science and technology. Discuss both these views and give your own opinion. 6.5 Some people argue that students should learn what they are interested in, while others think that only useful subjects should be taught in college. As far as I am concerned, as the definition for useful is debatable, a more interest-based study should be more beneficial for students’ studies. This essay with examine both sides and elaborate on my view. To begin with, having compulsory subjects may force students to discover their talents in science and technology. As many people consider the ability in solving tangible issues are more practical than having inspiring thoughts, they may think acquiring these skills may lead to a more promising future. For example, people who work in the IT industry may have a higher salary than writers. Therefore, these critics who value potential income than interest may want universities to narrow down the curriculum and only pass on the practical knowledge. However, universities tend to symbolize diversity instead of competition for others. If every higher institution is providing the same programme, the labour supply will sharply increase and lead to a surplus despite its potential. Besides, by allowing students to learn what they are interested in, they can flourish in different areas other than science and technology. For instance, students may find out their talents in arts or history. In this way, providing more choice seems more advantageous for both the universities’ social contribution and graduates’ personal development. In conclusion, since society needs both science and humanities for its development, graduates should be exposed to as many choices as there can be for their college choices. Even though limiting the variety of the courses in the university may explore students’ talent, it might be disputable for the school to decide which subjects are potentially useful as well. C11 Test3Some people say that the only reason for learning a foreign language is in order to travel to or work in a foreign country. Others say that these are not the only reasons why someone should learn a foreign language. Discuss both these views and give your own opinion. 6.5 Recent era has witnessed an uprising trend of learning a foreign language among the general public. While some are convinced that its purpose is merely to work or travel abroad, others assert that there exist more reasons for the mentioned development. I agree with the latter point of view. On one hand, those who regard working or travelling in other nations as the only intention of learning foreign languages hold the view that there is no point in mastering a foreign language unless individuals are actually going to use it. To be more specific, individuals are currently residing in an increasingly globalized world, where we could expect to found more transnational corporations and even find jobs in other countries. Furthermore, owing to the advancement of tourism, the mass has more opportunities to pay a visit to other countries. In this respect, the capability to speak a foreign language fluently could undoubtedly contribute to our communication with local dwellers, and nevertheless it would become a waste of time, if we rarely utilize foreign languages in daily lives. On the other hand, some citizens emphasize that more factors could account for the trend due to the fact that mastering other languages is helpful for us to broaden horizons. Provided that citizens could speaking other languages well, they could have more access to foreign films and TV series, thus coming to know distinctive modes of thinking. In addition, the general public is able to obtain friendships with foreigners through interacting with them in platforms, such as Whatsapp, when they are capable of speaking foreign languages. To recapitulate, although there is no denying that learning foreign languages is conducive for individuals to work or travel abroad, I believe the mass could also use them to approach the outside world. C11 Test4Many governments think that economic progress is their most important goal. Some people, however, think that other types of progress are equally important for a country. Discuss both these views and give your own opinion. 6.5 Recently, the debate on whether economic progress is the most important goal for a country has been heated. As far as I am concerned, whether a country should proritise its economic growth over other developments depends on its developing states. In this essay, I will outline both sides and elaborate on my view. To begin with, economic expansion is one of the most effective instruments in poverty reduction. For example, for developing countries like Cambodia, development in economy exposes its citizens to more job opportunities which result in a rapid growth in its finance. In this way, the progress in their economy may lead to an increase in people’s quality of life. Meanwhile, if a large population of the country are under poverty, the enhancement in education or environment may not be effective as people may not even be able to survive under high level of poverty. Therefore, economic progress seems more crucial for developing countries as it may help curb poverty. On the other hand, other developments like educational process may be more advantageous for developed countries to sharpen their competitive edges in the long run. As providing more educational resources to the public can enhance a country’s soft power. For countries like the UK, providing mandatory schooling policy that covers all of its school-aged children allows it to have more efficient labour force and become more productive in the future. Therefore, educational progress may be another crucial factor for a country’s development which tend to be equivalent to economic progress. In conclusion, whether economic progress should be the most important goal for governments depends on the developing environment of the country. Prioritising economic expansion can help developing countries to narrow down the poverty gap efficiently while other developments like education seem more favourable for developed countries in the long term. C12 Test1Some people believe that it is good to share as much information as possible in scientific research,business and the academic world.Others believe that some information is too important or too valuable to be shared freely. Discuss both views and give your own opinion. 6.5 Some people think that it is agreeable to share information as much as possible in fields like scientific research, business and the academic world, while others contend that some information should not be shared freely due to their special importance and value. This essay would argue that although some information should be preserved as they might lead to chaos or danger once they fall in the wrong hands, it is for the betterment and advancement of knowledge and society that information should be shared as freely as possible. The contention that information in the world of scientific research, business and academics should not be shared freely is understandable because some advanced knowledge in these fields could be misused if people with bad intentions get hold of them. Knowledge like the methods to make deadly weapons and produce narcotics, for example, should be withheld from the public to prevent horrible situations from happening, like bio-hazardous weapons being made by terrorists or illegal drugs being produced and traded by drug dealers. It is highly important to limit the access to such knowledge lest people like anarchists and terrorists would use them against mankind. However, there are plenty of knowledge in scientific research, business and the academic world that should be spread and learned by more people to push forward the development in these fields. For instance, more cost-effective ways of production could be shared in the business world to reduce the waste of human resource, time, energy and materials. Fordist ideologies and the Scientific Method are still being learned by business students till this day, and they can move on to contribute to the society and their country by practicing knowledge shared by their predecessors. It is for the general development of society that valuable knowledge should be shared freely. In conclusion, information in the scientific research, business and the academic world should be shared as much and as freely as possible, except the ones that are hazardous in nature and which upon sharing, might lead to accidents or catastrophes that threaten the peace and safety of the public. C12 Test3In a number of countries, some people think it is necessary to spend large sums of money on constructing new railway lines for very fast trains between cities. Others believe the money should be spent on improving existing public transport. Discuss both these views and give your own opinion. 6.5 Some people think that investing in new railway lines for high-speed trains should be a priority of the government, while others think that the money should be spent on improving the country’s existing public transport. On the one hand, high-speed trains would benefit a country’s economic development and therefore should be invested upon, but that does not mean improving the current transportation should be neglected because public transport like buses are also important in citizen’s daily life. The construction of high-speed trains is necessary because it would benefit the country’s economic development. Goods and people can be transported across the country more efficiently, saving money and time for both enterprises and individuals. For instance, China which have developed a sophisticated system of railway lines across the country makes Chinese citizens’ life a lot more convenient. People can travel from one city to another in a lot less time, which promotes tourism and also allow those who work in the city travel back home more easily. The development of China’s railways benefited both its citizens and the society’s development. Therefore, the construction of new railway lines would be a very worthwhile investment to a country. However, other public transport like buses and metro are also important to citizen’s daily life and should also be improved, but improving these transportation methods shall not cost as much as the inter-city trains. On one hand, improving the bus and metro service could make people’s life more convenient. With better local public transport, people can go to work in a cheaper, greener, and also time-efficient way. However, these services do not cost as much as the construction of a new and better railway system across the country. Therefore, the majority of the government’s budget should go to the development of a railway system while the improvement of other transportation should be considered a second priority. In conclusion, both new railway lines and existing public transport are important to a country and its citizens, but as the former would cost a lot more than the latter, the government should put more money into the investment of the former. C12 Test4Some people believe that allowing children to make their own choices on everyday matters (such as food, clothes and entertainment) is likely to result in a society of individuals who only think about their own wishes. Other people believe that it is important for children to make decisions about matters that affect them. Discuss both these views and give your own opinion. 6.5 Some people claim that autonomy may lead to egoist, however, others argue that it is crucial for one’s growth. As far as I am concerned, children should have their own decisions with guidance teaching the desirable value. This essay will examine both sides and elaborate on my view. To begin with, making their own decisions is necessary for kids to be responsible. Through making choices, youngsters will know that they need to bear the consequence of their own decision. For example, if a child prefers not to have lunch, the kid needs to suffer from hunger after. As it is inevitable to have undesirable outcomes, children are forced to be more conscious of their choices. Consequently, instead of being abounded with egoists, society should be filled with people who are more considerable for themselves as well as the community. Nevertheless, it is also crucial for the parents to guide their offspring when they are learning to pick their own choices. Since the cognitive development of the younger generation is immature, children might need their parents to teach them what is favourable and what is not. For instance, if a kid always makes decisions irrespective of others’ wellbeing, they might become egocentric if their parents do not take any action to interrupt it. Therefore, these spoiled youngsters may become selfish in the future. In conclusion, young people should be provided with some free wishes under their parents’ guidance. Since family is not the only factor that affects one’s characteristics, kids may also learn how to care about each other when they are in school before getting into society. As a result, the concern that autonomy may lead to a selfish individual may not prevail in humanity. C13 Test3Some people say History is one of the most important school subjects. Other people think that, in today’s world, subjects like Science and Technology are more important than History. Discuss both these views and give your own opinion. 6.5 In contemporary society, the significance of distinctive academic subjects has provoked a passionate discussion. Some are convinced that history is still of great value, while in others’ eyes, a wide range of novel subjects are more important. I agree with the latter point of view. On one hand, those attaching great significance to history assert that history is a crucial part of a country’s culture. To be more specific, history is the record of a country’s vital events and achievements, which could showcase the invaluable wisdom and knowledge of our ancestors. In this respect, learning about history could not only equip us with a profound understanding of our country, but also enable us to gain a sense of belonging. On the other hand, a number of citizens regard subjects like science and technology as important due to the fact that compared with history, these subjects could add to our employment competitiveness. In modern age, with the rapid development of technology, individuals’ lives are closely connected to science, such as artificial intelligence. The occupation programmer is a good case in point. Provided that students spend longer time learning subjects, such as mathematics and coding, it would be easier for them to find jobs in the future. To recapitulate, both sides possess their reasonable arguments. Although history is able to let students be well-informed about their countries, I hold the view that learning subjects like science and technology is more crucial for the reason that in modern context, these subjects could provide them with better job opportunities. C14 Test1Some people believe that it is best to accept a bad situation, such as an unsatisfactory job or shortage of money. Others argue that it is better to try and improve such situations. Disccuss both these views and give your own opinion. 6.5 There is no denying that citizens would encounter a number of barriers in daily life. Some are convinced that accepting the situation is a proper choice, while in others’ eyes, individuals are supposed to make efforts to tackle it. I agree with the latter point of view. On one hand, those who are inclined to keep the status quo assert that it is their destiny to suffer from these difficulties, which dedication could not make a difference to. To exemplify, people from African countries are likely to believe the imbalanced economic development and adverse geographical conditions are to blame for their poverty. As a consequent, they find their personal efforts useless and tend to accept this disadvantageous situation. On the other hand, some tend to confront difficulties for the reason that they are able to develop a wide range of abilities in the process. To be more specific, when individuals try to address dilemmas, it is not only possible for them to obtain problem-solving competency, but also citizens could gain an optimistic mindset and strong willpower, which is conducive to them in the long run. Starting up businesses is a good case in point. In the situation of joblessness, trying to improve the status quo through it could help individuals to develop leadership and innovation. To recapitulate, both sides assert their reasonable arguments. From my point of view, although some problems are hard to reverse, it is not advisable for the general public to surrender to them. Instead, fighting with detrimental situations could showcase our backbone and persistence and is also beneficial for us to obtain various capabilities. C14 Test2Some people say that the main environmental problem of our time is the loss of particular species of plants and animals. Others say that there are more important environmental problems. Discuss both these views and give your own opinion. 6.5 Some people contend that the major environmental issue in today’s world is the extinction of particular animals and plants, while others think that there are more important environmental issues. It is understandable to consider the lives of animals and plants an important issue, but I think that there are bigger and more imminent issues that we should think about, like the problem of climate change which can be life-threatening for animals and humans alike. The loss of certain species of animals and plants is important because it threatens the planet’s biodiversity. When a certain location’s biodiversity is compromised as certain animals and plants go extinct, the ecosystem of that location is damaged and may lead to further catastrophes. However, other environmental issues such as climate change are more life-threatening than a less biodiverse environment. Climate change brings extreme weather like floods and hurricanes that could directly lead to the loss of property and human life. A number of islands that do not live high enough above the sea level are predicted to be wiped out by the ever-increasing sea level that is the result of global warming. Hence, climate change is a phenomenon that has more direct adverse impacts on human beings. In conclusion, people may consider the loss of some species of animals and plants and important environmental problem because it does harm to our planet’s biodiversity and the ecosystem inhabited by certain animals, but this issue is far less important than that of climate change, as the latter directly threatens the survival of human habitats and humans. C15 Test3Some people say that advertising is extremely successful at persuading us to buy things. Other people think that advertising is so common that we no longer pay attention to it.Discuss both these views and give your own opinion. 6.5 Recently, the debate on whether advertisements will be influencing has been heated. While some people argue that it can persuade us to purchase, others claimed that it is too common to be noticed in our daily life. As far as I am concerned, the effectiveness of commercials should be judged by their impacts on their target audiences. This essay will discuss both sides and elaborate on my view. To begin with, advertisements may increase the credibility of the brand. As the rise in diverse brands may create struggles and confusion for consumers, targeting endorsements may intrigue their audience to buy something as the trial. For example, cosmetic brands use advertising to cajole their target audiences to purchase their products by highlighting the effectiveness of the product and their advantage compared to their substitutes. Once customers are satisfied with their first consumption, they may be easier to be persuaded by the advertisements from the same brand. However, being bombarded by numerous advertisements may also create mental fatigue in watching them, especially for those audiences who are not targeted by the advertisement. For instance, students in universities may not be interested in child caring products. Since many brands are conducting mass advertising that whoever use that certain social platform can see, the advertisement may be less convincing for those who already lacked interest in that area. In this way, people may immune the amount of the advertisement and stop paying attention to it in the future. In conclusion, since each brand has its own target audience, the strength in persuading the audience to purchase may be more outstanding for their target audiences in comparison with the general public. Nevertheless, since big data is collecting every user’s preference and providing direct advertisements, the effectiveness of advertisements in the future may be more favourable. C17 Test3Some people believe that professionals, such as doctors and engineers, should be required to work in the country where they did their training. Others believe they should be free to work in another country if they wish. Discuss both these views and give your own opinion. 7 Recent era has witnessed an uprising trend of globalization and it has provoked a passionate discussion whether professionals ought to remain where they received training. While some agree with this opinion, in others’ eyes, it is advisable for them to have the freedom to decide where they want to work. I am in accordance with the latter point of view. On the one hand, those who are inclined to keep the status quo argue that professionals have gained familiarity with local residents and lifestyle. Cultures vary from country to country, which leads to the fact that specialists need to spend time getting accustomed, provided that they modify their country of working. To be more specific, professionals who did training in China do not need to waste time getting used to Chinese lifestyle in that they have mastered Chinese and developed social network there, which could help them save a large amount of time. On the other hand, some are convinced that specialists should be free to work where they want for the reason that income levels are not equal around the world. To exemplify, programmers in the US are generally paid more than in Russia. In this respect, professionals are capable of earning more money, if they choose to work abroad. Moreover, specialists may encounter a better chance of self-development when they are free to work overseas. There is no denying that developed countries possess a higher level of technology and research, thus enabling professionals to enrich expertise in their professionalism if they are allowed to work in another nation. To recapitulate, both sides assert reasonable arguments. As far as I am concerned, although working in the place of training can help specialists stay in their comfort zone, being free to choose workplaces can let professionals lead a better life and gain expertise.","link":"/2022/10/30/zh/english/ielts/writing/task_2/discuss_both_views/"},{"title":"Task 2 正反影响","text":"C4 Test2Happiness is considered very important.in life. Why is it difficult to define? What factors are important in achieving happiness? 7 There is no denying that happiness is of great significance in our daily lives and recent era has witnessed a passionate discussion regarding it. As far as I am concerned, it is hard for us to define happiness and a number of factors could contribute to happiness, which will be explained below. The reason why the general public regards it as challenging to give happiness a definition is that everyone possesses different view towards it. To be more specific, literacy levels and life situations vary greatly from individual to individual, which results in the fact that everyone has his or her particular passion from which he or she takes pleasure. To exemplify, those from relatively impoverished backgrounds consider sufficient money and food as joyance, whereas entrepreneurs may equal happiness with more free time. Despite the fact that it is difficult to define happiness precisely, there are several preconditions in obtaining it. To start with, in terms of enjoyment, the public attaches great importance to a decent job in that employments play a crucial role in satisfying citizens’ basic survival needs. Moreover, the mass would find it hard to feel joyful unless they are accompanied by their family members and close friends, with whom we share similar interests and values. As is known to all, nowadays we depend on interpersonal relationships to acquire information and gain recreation through communicating with each other. To recapitulate, citizens reckon it difficult to define joyance, since they tend to view it in distinctive ways and nevertheless, satisfactory jobs and the accompaniment of family members and friends are the main contributors of happiness. C4 Test4In many countries schools have severe problems with students behaviour. What do you think are the causes of this? What solutions can you suggest? 6.5 In contemporary society, there has been an uprising trend that the younger generation behaves themselves increasingly inappropriately at schools. From my point of view, there are some reasons behind the phenomena, which will be explained below and some measures can be helpful to tackle it. To start with, the development of the media could account for the mentioned situation. Nowadays, a great number of bloody and violent images could be found in TV programs and computer games. As is known to all, younger adults have the penchant for imitating other’s deeds and sayings, since they are still immature and that is why these programs are thought to be responsible for children’s bad behaviors. Moreover, the modification in family structures is to blame. Because of the lower birth rate and birth policies in some countries, households are becoming smaller with fewer kids. Consequently, parents tend to care too much about their children and even spoil them, which leads to the fact that kids are becoming selfish and unable to put themselves into others’ shoes. In this respect, students are more and more unwilling to abide by rules and respect teachers at schools. Nevertheless, this situation can be improved by the following steps. It is advisable for the authority to ban detrimental TV programs and console games for the younger generation and meanwhile set educational channels for them. Furthermore, parents classes can make contributions, where parents could learn how to restrain their kids’ behaviors and educate them in a proper way. To recapitulate, students’ unacceptable behaviors are due to the advancement of the media and the changing demographic structures and however, the phenomena is still not out of hand in that the efforts of governments and parents can be conducive. C5 Test4Research indicates that the characteristics we are born with have much more influence on our personality and development than any experiences we may have in our life. Which do you consider to be the major influence? 7 Our characteristics and personalities all differ greatly, but what is the cause behind this divgerence? Recent research indicates that born characteristics have major impact on our personalities and development. Despite that, I would argue that environmental influences shape one’s personality more. It is undeniable that nature, or inborn characteristics have a major impact on one’s identity. Studies have repeated shown that genetics play a part in deciding one’s personality. In research and studies focusing on the heritability of traits such as Autism, reading disability and personality in identical twins, it is found that in most of the case genetic influence, or born characteristics have around or more than 50% of influence of these traits, suggesting that characteristics that we are born with certainly plays a part in deciding one’s personality. However, genetics does not offer the whole picture. Studies have also repeated shown that if one raise identical twins with same genes in different families, it is very likely that they will have different personalities, affirming the effect of environment and life experiences in shaping one’s personalities. With more positive encouragement one may grow up to be a more cheerful person, while abuse and scorning might have adverse effects and making children more introvertive. Some key life experience might also play a part, such as being bullied at school or making a life long friend. What one might conclude from these examples is that even though genetics play a part in deciding the initial form of an individual’s personality, further experiences in life molds and influences that form, finally crafting it into a unique individual, and in this light one might conclude the environment and experiences is the major influence, in deciding one’s personality and development. To conclude, I will argue that one’s experience in life and environment is the major influence, in deciding an individual’s personality and eventual development. C7 Test3As most people spend a major part of their adult life at work, job satisfaction is an important element of individual wellbeing. What factors contribute to job satisfaction? How realistic is the expectation of job satisfaction for all workers? 7 As society progresses, people start to diverse their attention from material needs to spiritual ones. In the workplace, this manifests in people’s emphasis on the important of job satisfaction. Job satisfaction is determined mainly by the sense of accomplishment that can be derived from the job and the interpersonal relationships at work. Although it is an essential part of individual wellbeing, for some workers it is not something easy to get, especially for workers who work at manual and monotonous jobs. One factor that contributes to job satisfaction is whether people can get a sense of accomplishment out of the job. This determines whether people think that their work has meaning. For example, a job at a trading company mainly involves doing businesses with its clients. If one thinks that service is more meaningful, a job that only deals with business and trades products may be deemed less satisfying than a teaching job, for example. Teachers can have a great sense of accomplishment seeing progress in their students, and this would contribute to the sense of job satisfaction they have. Another factor that contributes to job satisfaction is the interpersonal relations at the workplace. If one’s relationship with their coworkers is impersonal and business-like rather than friendly and close, one’s job satisfaction may be lower because the workplace is rather “cold” in terms of interpersonal relations. However important job satisfaction is, there are types of jobs where job satisfaction is harder to get than at others. Monotonous and manual jobs like streamline manufacturing is generally considered boring and therefore not satisfying. Jobs where creativity is not needed is also prone to be less satisfying than those where creativity is demanded. Although job satisfaction partly depends on the nature of the work itself, workers can also turn something boring into something interesting if they have the right mindset and a positive attitude. Therefore, how realistic is the expectation of job satisfaction for workers depends on both the job and how people choose to view their jobs. In conclusion, two factors that contribute to job satisfaction are the sense of accomplishment people get out of their job and the interpersonal relations at work. Although it is harder for some workers to be satisfied by their jobs than others, job satisfaction sometimes comes from the way people choose to adapt to and accept their jobs. C7 Test4Some people think that universities should provide graduates with the knowledge and skills needed in the workplace. Others think that the true function of a university should be to give access to knowledge for its own sake, regardless of whether the course is useful to an employer. What, in your opinion, should be the main function of a university? 6.5 There is a controversy regarding what universities’ main function should be. Some think that they should provide work-related knowledge and skills to students, while others think that the way university curriculum is designed should not take into account what is needed in the workplace. In my opinion, universities should focus on knowledge itself because students can choose to go to schools that teach technical skills to train for the workplace and it would hinder the development of academia if universities start diverting their objectives to cultivate good employees. First, there are schools that teach technical skills directly related to certain jobs, and if students wish to join a specific workforce after college, they can choose to enroll in these schools instead of regular universities. These schools offer courses that get students ready to be a cook, a nurse, or a worker in any specific field et cetera. This way, only students who want to pursue an academic journey would go to universities. The main function of universities should be training enthusiastic young people to be a good academic for the development of specific academic fields. The development of science, for example, needs candidates who have gone through a rigorous training solely dedicated to the relevant knowledge itself. If universities start making courses that aim to provide the society with able, obedient employees, they are actually taking away resources that should have been given to train, for example, good scientists or good doctors. Though they may one day become part of the workforce as well, their jobs require them to be adequately professional and knowledgeable and becoming so should be the main aim of their university education. In conclusion, the main function of a university should be to give access to knowledge instead of train employees for the workplace because there are other schools designed to do so, and workplace training would take away resources that should be dedicated to academic training and research which are crucial to the development of fields like medicine or science. C8 Test4In some countries the average weight of people is increasing and their levels of health and fitness are decreasing. What do you think are the causes of these problems and what measures could be taken to solve them? 7 Recent era has witnessed an uprising trend that citizens have the penchant for gaining weight, which would lead to a series of health problems. From my point of view, there are several reasons for this worrying development and some methods could help to tackle it. To start with, the modification in individuals’ lifestyle could account for the mentioned phenomenon. Due to the advancement of modern technology, the general public is more willing to let off steam through watching TV or playing console games instead of approaching nature. That is why citizens are developing a sedentary lifestyle and consequently suffer from obesity. Moreover, the changing eating habit is to blame. To be more specific, in modern times, the mass may live under considerable stress from both their colleagues and supervisors, which urges them to devote a large amount of time to their work. As a result, chances are that they prefer to go for the less health-conducive fast food, such as cola and hamburger, thus taking in more oil and sugar. However, this situation can be improved by the following steps. It is advisable for the authority to build more sports facilities with the purpose of encouraging the public to do more exercises in their leisure time. Furthermore, the media could make contributions to raising citizens’ awareness of strengthening their bodies. To cite non-profit advertisements as an example, the media could educate the mass the detrimental outcomes of getting fat through it. To recapitulate, citizens’ increasing weight is due to changes in lifestyle and eating habits and nevertheless, this situation is still not out of hand in that the efforts of governments and media could be beneficial. C13 Test4In spite of the advances made in agriculture, many people around the world still go hungry. Why is this the case? What can be done about this problem? 7 Recent era has witnessed great progress in the field of agriculture and nevertheless, it is still a dilemma that a large number of citizens are suffering from hunger. There are some reasons for this which would be explained below and some of steps could help tackle it. In terms of the causes of the mentioned problem, for one thing, frequent extreme weather is to blame. As is known to all, there is rapid environmental change taking place all over the world because of the increasingly severe global pollution and greenhouse effect, which would put threat into yielding crops in many areas. To exemplify, drought in Africa is likely to impede the process of food production, thus letting local residents go hungry. For another, food prices are still high in many countries due to the fact that many intermediary businesses, such as retailors and transporters would make profits before food reach consumers. However, this problem is still not out of hand. To be more specific, governments are supposed to regulate food prices, making it affordable for the general public. Legislation is a good case in point. Through enacting relevant laws, the authority is capable of intervening in the pricing process and excessive profits could be curtained. Furthermore, the media ought to raise the mass’s awareness of protecting the environment by making related documentaries or non-profit advertisements, which would be helpful for reducing extreme weather. To recapitulate, frequent climate changes and high food prices are able to account for famine in many areas and this problem could be addressed with the efforts of both governments and the media. C14 Test4Nowadays many people choose to be self-employed, rather than to work for a company or organisation. Why might this be the case? What could be the disadvantages of being self-employed? 6.5 In today’s world, more and more people choose to be self-employed instead of working for a company or organization. This is a result of the increasing popularity and commercialization of the internet and social media, as well as people’s increasing longing for freedom. Despite the obvious freedom that attracts people to be self-employed, there are also disadvantages with this mode of employment, which is its uncertainty and higher risks. Firstly, The rapid development and soaring popularity of social media give birth to a significant population of self-employed people. The jobs they can do include but are not limited to bloggers, instagram poets, instagram models, influencers and so on. The internet provides content creators with a platform where they can share and reach audience all around the world, and thus makes it unnecessary for individuals to rely on a company for resources. The rise of social media like tiktok and Instagram also creates an ever greater demand for content, which gives ordinary people an opportunity to become famous from the grassroots. Secondly, freedom is also a major point of attraction that draws people to engage in self-employed jobs. Working for a corporation usually means that there are a set of rules one has to follow, from a specific work schedule, limited number of holidays to corporate etiquettes. All of these do not exist with self-employment. Being your own boss does not only mean that you can rest at anytime you what, it also allows for greater space for creativity if one’s career or visions are creative or inventive in nature. For example, it would mean that there are far less restrictions when a comedian writes his own jokes and makes videos on YouTube, than if he works for Saturday Night Live. It gives artists greater artistic freedom if they can dictate what content to be made and how they are delivered, decisions that are not usually made by them if they are working for a corporation with its own guidelines and creative framework. Nevertheless, there are some disadvantages to being self-employed. Some obvious ones are the risks and uncertainty with not being protected and guided by a company. A job in an established company is more or less securer than working by oneself. They usually have an established way of doing things and more people in the same industry that can help each other out with their specialist knowledge or insights. Self-employment lacks that kind of resources that could make things easier. In conclusion, the trend of self-employment is a result of the development of the internet and social media as well as people’s growing longing for freedom. Despite what self-employment seems to offer, it has some obvious disadvantages which are its uncertainty and risks. C16 Test1In some countries, more and more people are becoming interested in finding out about the history of the house or building they live in. What are the reasons for this? How can people research this? 6.5 With a general increase of city populations, housing and issues it brings along has started to attract more and more attention. One of such problem is the history of the house or building, they intend to purchase or currently live in. I think the main reason behind this is that, as our city start to age the structural integrity and quality of the buildings will start to wane, possibly incurring risks for its residents, hence attracting attention. Another reason might be that they have some other concerns, that could mark their house as uninhabitable. Firstly, one may be concerned about the durability of their residence. Buildings do not last forever and when they exist past a certain point, they are considered dangerous to live in and later even unsuitable to live in. This might alarm some people since they can find that the building they are currently living in has a long construction history and is only considered safe for just a few more months, therefore with this information they may decide to move out. Moreover, some specific history of the building might disturb residents and prompt them to leave. In China for example a house where a murder has happened before is considered bad omens, and one should not visit and definitely not live in it. Consequently, this piece of historic information alone may be able to convince people to move out. Regardless of the reason, there are many ways one can find out historic information about the building they live in. The easiest way might be simply to ask around. For example, the previous owners, your neighbors, and so on. Perhaps they will know something of your current household. Another idea is to research on the internet. On governmental websites one can usually download pdfs and spreadsheets of data, about your specific building. In addition, one can use historic news reports to find out whether something terrible has happened in your apartment or not. In conclusion, there are many reasons why someone might want to research the history of their own household. One of the main reasons is that they might want to verify their safety of their residence by researching its construction history, or they could be concerned about other factors such as previous events happening in their own house. Whichever reason it is they have plenty of ways to find out the information, either by asking people around them, or research on the internet. C17 Test2Some children spend hours every day on their smartphones. Why is this the case? Do you think this is a positive or a negative development? 7 Nowadays, some children spend a lot of their time on smartphones every day. This is because of the rapid development of technology and social media which has made smartphones an irresistible attraction to children who lack self-control. This is definitely a negative development as this not only hinders children’s academic performance but also harms their mental health. Today’s smartphones are devices which you can use to play games and contact friends, and these are very interesting and addictive activities to children. Children naturally lack the kind of self-control that adults possess, and so they easily fall prey to the apps that are developed to catch and hold users’ attention. Not to mention the amount of information they can access through the internet, which makes the smartphones even more enticing. The addiction to smartphones is a negative phenomenon, which is detrimental to children’s academic development and mental health. Smartphones can be a serious distraction when they do school work because kids can be easily attracted by things like new notifications or messages from friends. They might even rely on the internet for answers to homework, thus negating the meaning of their education. They might get dependent on the internet and stop makingt effort to do their own work. What’s more, it has been proven that spending too much time on social media could cause depression among teenagers, as they are constantly exposed to others’ ‘perfect’ lives posted on social media. Distorted values and unrealistic aesthetic standards are just some of the things that they can learn from the internet. Children’s mental health is at risk if they spend too much time on the virtual world instead of connecting with people in real life. In conclusion, it is the development of technology and social media that has made smartphones a major part of children’s life, as they can easily contact friends and play games on their devices. This growing addiction is not a positive development as spending too much time on smartphones could hinder children’s academic development and even do harm to their mental health. OG T3P2Car ownership has increased so rapidly over the past thirty years that many cities in the world are now ‘one big traffic jam’. How true do you think this statement is? What measures can governments take to discourage people from using their cars? 7 Most people would agree that car ownership has increased in recent years and is causing a range of problems, particularly in built-up areas. I think there are a number of ways that governments can aim to deal with this. Many big cities in the world have traffic problems but these problems vary. For example, it is reasonably easy to drive around my city after 10 am and before 5 pm.However, outside these hours, you have to allow double the usual time to reach your destination. In some other cities, traffic is congested at all times, and there is the continual sound of car horns as people try to get wherever they want to go. One of the best approaches governments can take in busy cities is to encourage the use of public transport. This means the transport facilities have to be well run and people must be able to afford them. Buses, trams and trains are good ways of getting around, and if they are cheap and reliable, people will use them. Another approach is to discourage people from actually entering the city by building car parks and shopping centres on the outskirts. Many cities around the world do this quite successfully and offer passengers bus transport into the centre,if they need it. At peak travel periods, governments can also run campaigns to encourage people to be less dependent on their cars. Apparently, a lot of car trips involve very short journeys to. say,the supermarket or local school.These are often unnecessary, but we automatically get in our cars without thinking. Clearly we all have a responsibility to look after our cities.Governments can do a lot to improve the situation and part of what they do should involve encouraging individuals to consider alternatives to driving. OG T6P2In the past, when students did a university degree, they tended to study in their own country.Nowadays, they have more opportunity to study abroad. What are the advantages and disadvantages of this development? You should use your own ideas, knowledge and experience and support your arguments with examples and relevant evidence. 7 The pursuit of knowledge is a concept that is valued by most cultures. In the 21st century, we now have many more options regarding how and where to find that knowledge. If you are a French national, you can apply to do an economics degree in the USA, and likewise an American citizen can take a course in linguistics in France. Indeed, most universities across the world now have a good proportion of foreign students enrolled in their programmes. Certainly, there are numerous advantages of studying in a different country. Many students choose to do this because they know that a particular university, for instance Stanford Business school, has an excellent reputation. Graduating from here, they believe, will increase their chances of securing a decent position in a company back home. Students studying abroad also have the opportunity to form friendships with people of various nationalities: in time, these may develop into useful professional networks. Furthermore, living far from family and friends can enable young people to become more independent and self-sufficient. Unfortunately, the experience of studying abroad is not always a positive one. Research suggests that a small percentage of young people struggle to adapt to their new environment and suffer from severe culture shock. The situation can become worse if the student is not mature enough to cope by themselves. Different approaches to teaching and learning may also come as an unwelcome surprise to some students.In essence, the key to a good experience at a foreign university is an open mind.If a student is presented with this opportunity, they should certainly seize it. OG T8P2Some people get into debt by buying things they don’t need and can’t afford. What are the reasons for this behaviour? What action can be taken to prevent people from having this problem? 7 Nowadays we are living in a society based on consuming. As a result, some people have problems in dealing with this budget and they get into debt by buying things they don’t need and can’t afford. This kind of behavior is encountered quite often in our present days, mainly because of the possibility of buying goods in leasing. Hence, people buy most of the goods using the credit card without having a clear idea on how much money they possess or they owe. Also, another cause for this behavior could be psychological. The advertisement and the subliminal messages one encounters in a regular day in a big city has an enormous impact on one’s brain. The main problem is the lack of awareness of the serious effects that advertisement can have on people. In order to prevent people from adopting this dangerous behavior, measures should be taken so as to raise awareness among people. Also, one must learn how to manage his budget in order to get a balance between necessity and pleasure. Keeping a record on income and monthly spending would be very helpful and would give to the consumer an overall image on how his budget should be spent. All summed up, the chances of becoming a victim of the consumer’s society are high nowadays due to the surrounding temptations but this problem could be easily avoid by being aware of this dangers and having a rational attitude when dealing with money.","link":"/2022/10/30/zh/english/ielts/writing/task_2/positive_negative_development/"},{"title":"Bash游戏","text":"Bash游戏http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1066 有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。 例如N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行2个数N，K。中间用空格分隔。（1 &lt;= N,K &lt;= 10^9) Output 共T行，如果A获胜输出A，如果B获胜输出B。 Input示例 43 24 27 38 3 Output示例 BAAB 分析： N % (K + 1) == 0 时，先手必输。 12345678910111213141516171819202122232425262728293031import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int T = (int) in.nval; int[] N = new int[T], K = new int[T]; for (int i = 0; i &lt; T; i++) { in.nextToken(); N[i] = (int) in.nval; in.nextToken(); K[i] = (int) in.nval; } for (int i = 0; i &lt; T; i++) { if (N[i] % (K[i] + 1) == 0) { out.println(&quot;B&quot;); } else { out.println(&quot;A&quot;); } } out.flush(); }} Bash游戏 V2http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1067 有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。 例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9) Output 共T行，如果A获胜输出A，如果B获胜输出B。 Input示例 3234 Output示例 BAA 分析： 想不出来的话，可以通过 SG 函数打表发现规律： 1234567891011121314151617181920212223242526272829import java.util.Arrays;public class Main { static int MAXN = 105; static int N = 3; static int[] f = { 1, 3, 4 }; static boolean[] isVisit = new boolean[MAXN]; static int[] SG = new int[MAXN]; public static void main(String[] args) { getSG(100); } static void getSG(int n) { for (int i = 1; i &lt; n; i++) { Arrays.fill(isVisit, false); for (int j = 0; j &lt; N &amp;&amp; f[j] &lt;= i; j++) { isVisit[SG[i - f[j]]] = true; } for (int j = 0;; j++) { if (!isVisit[j]) { SG[i] = j; break; } } System.out.println(i + &quot; &quot; + SG[i]); } }} 可以发现只有 mod 7 = 0、mod 7 = 2 必败。 12345678910111213141516171819202122232425import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int T = (int) in.nval; int[] a = new int[T]; for (int i = 0; i &lt; T; i++) { in.nextToken(); a[i] = (int) in.nval; } for (int i = 0; i &lt; T; i++) { out.println(a[i] % 7 == 0 || a[i] % 7 == 2 ? &quot;B&quot; : &quot;A&quot;); } out.flush(); }} Bash游戏 V3http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1068 有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量只能是2的正整数次幂，比如(1,2,4,8,16….)，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。 例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。（输入的N可能为大数） Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^1000) Output 共T行，如果A获胜输出A，如果B获胜输出B。 Input示例 3234 Output示例 ABA 分析： 同样可以通过 SG 函数打表发现规律： 1234567891011121314151617181920212223242526272829303132import java.util.Arrays;public class Main { static int MAXN = 105; static int N = 20; static int[] f = new int[N]; static boolean[] isVisit = new boolean[MAXN]; static int[] SG = new int[MAXN]; public static void main(String[] args) throws IOException { for (int i = 0; i &lt; N; i++) { f[i] = (int) Math.pow(2, i); } getSG(100); } static void getSG(int n) { for (int i = 1; i &lt; n; i++) { Arrays.fill(isVisit, false); for (int j = 0; j &lt; N &amp;&amp; f[j] &lt;= i; j++) { isVisit[SG[i - f[j]]] = true; } for (int j = 0;; j++) { if (!isVisit[j]) { SG[i] = j; break; } } System.out.println(i + &quot; &quot; + SG[i]); } }} mod 3 = 0 必败。 123456789101112131415161718192021import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;import java.math.BigInteger;public class Main { public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); int T = Integer.parseInt(in.readLine()); BigInteger three = BigInteger.valueOf(3); for (int i = 0; i &lt; T; i++) { BigInteger N = new BigInteger(in.readLine()); out.println(N.mod(three).intValue() == 0 ? &quot;B&quot; : &quot;A&quot;); } out.flush(); }} Bash游戏 V4http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1070 有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量最少1个，最多不超过对手上一次拿的数量的2倍（A第1次拿时要求不能全拿走）。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。 例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9) Output 共T行，如果A获胜输出A，如果B获胜输出B。 Input示例 3234 Output示例 BBA 分析： 当石头数为斐波那契数时，必败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { static int N = 50; static int[] f = new int[N]; public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); getFibonacci(); in.nextToken(); int T = (int) in.nval; for (int i = 0; i &lt; T; i++) { in.nextToken(); int n = (int) in.nval; if (isFibonacci(n)) { out.println(&quot;B&quot;); } else { out.println(&quot;A&quot;); } } out.flush(); } static void getFibonacci() { f[0] = f[1] = 1; for (int i = 2; i &lt; N; i++) { f[i] = f[i - 1] + f[i - 2]; } } static boolean isFibonacci(int n) { for (int j = 1; j &lt; N; j++) { if (n == f[j]) { return true; } } return false; }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/bash_game/"},{"title":"构造回文","text":"https://www.nowcoder.com/test/question/28c1dc06bc9b4afd957b01acdf046e69?pid=1725829&amp;tid=14425231 给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 输入描述:输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述:对于每组数据，输出一个整数，代表最少需要删除的字符个数。 输入例子1:abcdagoogle 输出例子1:22 分析： 回文翻转后和原来是一样的，这样就是求两个字符串中的最长公共子序列了，不要求子串连续。比如：abcda 翻转后 -&gt; adcba，明显只有 aba 是最长的回文，而且是最长的公共子序列。 123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { String s1 = in.sval; StringBuffer tmp = new StringBuffer(s1); String s2 = tmp.reverse().toString(); out.println(s1.length() - LCS(s1, s2)); } out.flush(); } static int LCS(String s1, String s2) { int s1Length = s1.length(), s2Length = s2.length(); int[][] dp = new int[s1Length + 1][s2Length + 1]; for (int i = 1; i &lt;= s1Length; i++) { for (int j = 1; j &lt;= s2Length; j++) { if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[s1Length][s2Length]; }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/construct_palindrome/"},{"title":"欧拉函数","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1136 对正整数n，欧拉函数是少于或等于n的数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为Euler’s totient function、φ函数、欧拉商数等。例如：φ(8) = 4（Phi(8) = 4），因为1,3,5,7均和8互质。 Input 输入一个数N。(2 &lt;= N &lt;= 10^9) Output 输出Phi(n)。 Input示例 8 Output示例 4 分析： 欧拉函数：就是求出在区间[1, n-1]中有m个数与n互质，求出m的值 欧拉函数的求法：如果a1,a2,a3……是n的质因子数，那么 m = n * (1 - 1/a1) * (1- 1/a2) * (1- 1/a3)…… 互质：2个数之间只有1是他们的公约数 123456789101112131415161718192021222324252627282930313233import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int n = (int) in.nval; out.println(euler(n)); out.flush(); } static int euler(int n) { int res = n; for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) { res = res / i * (i - 1); while (n % i == 0) { n = n / i; } } } if (n != 1) { res = res * (n - 1) / n; } return res; }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/euler_function/"},{"title":"数塔取数问题","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1002 一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。 1234 5 8 4 3 6 97 2 9 5 例子中的最优方案是：5 + 8 + 6 + 9 = 28 Input 第1行：N，N为数塔的高度。(2 &lt;= N &lt;= 500)第2 - N + 1行：每行包括1层数塔的数字，第2行1个数，第3行2个数……第k+1行k个数。数与数之间用空格分隔（0 &lt;= A[i] &lt;= 10^5) 。 Output 输出最大值 Input示例 458 43 6 97 2 9 5 Output示例 28 分析：坑……由示例推断是贪心，结果后面一半的测试样例都错了，看到题解才发现是由下往上更新的动态规划。 123456789101112131415161718192021222324252627282930import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int n = (int) in.nval; long[][] array = new long[n][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= i; j++) { in.nextToken(); array[i][j] = (long) in.nval; } } for (int i = n - 1; i &gt;= 1; i--) { for (int j = 0; j &lt;= i; j++) { array[i - 1][j] += Math.max(array[i][j], array[i][j + 1]); } } out.println(array[0][0]); out.flush(); }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/get_number_from_tower/"},{"title":"最长回文子串","text":"最长回文子串http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1088 回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。输入一个字符串Str，输出Str里最长回文子串的长度。 Input 输入Str（Str的长度 &lt;= 1000) Output 输出最长回文子串的长度L。 Input示例 daabaac Output示例 5 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { String s1 = in.sval; out.println(Manacher(s1)); } out.flush(); } static int Manacher(String str) { String s = &quot;$#&quot;; for (int i = 0; i &lt; str.length(); i++) { s += str.charAt(i) + &quot;#&quot;; } int max = 0; int id = 0; int[] p = new int[s.length()]; for (int i = 0; i &lt; s.length(); i++) { int maxLen = p[id] + id; if (maxLen &gt; i) { p[i] = Math.min(p[2 * id - i], maxLen - i); } while (i + p[i] &lt; s.length() &amp;&amp; i - p[i] &gt;= 0 &amp;&amp; s.charAt(i - p[i]) == s.charAt(i + p[i])) { p[i]++; } if (maxLen &lt; i + p[i]) { id = i; } max = Math.max(max, p[i]); } return max - 1; }} 最长回文子串 V2http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1089 回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。输入一个字符串Str，输出Str里最长回文子串的长度。 Input 输入Str（Str的长度 &lt;= 100000) Output 输出最长回文子串的长度L。 Input示例 daabaac Output示例 5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); String s1 = in.readLine(); out.println(Manacher(s1)); out.flush(); } static int Manacher(String str) { StringBuilder newStr = new StringBuilder(); newStr.append('#'); for (int i = 0; i &lt; str.length(); i++) { newStr.append(str.charAt(i)); newStr.append('#'); } int[] rad = new int[newStr.length()]; int right = -1; int id = -1; for (int i = 0; i &lt; newStr.length(); i++) { int r = 1; if (i &lt;= right) { r = Math.min(rad[id] - i + id, rad[2 * id - i]); } while (i - r &gt;= 0 &amp;&amp; i + r &lt; newStr.length() &amp;&amp; newStr.charAt(i - r) == newStr.charAt(i + r)) { r++; } if (i + r - 1 &gt; right) { right = i + r - 1; id = i; } rad[i] = r; } int maxLength = 0; for (int r : rad) { maxLength = Math.max(r, maxLength); } return maxLength - 1; }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/longest_palindromic_substring/"},{"title":"Nim游戏","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1069 有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。 例如：3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。 Input 第1行：一个数N，表示有N堆石子。（1 &lt;= N &lt;= 1000)第2 - N + 1行：N堆石子的数量。(1 &lt;= A[i] &lt;= 10^9) Output 如果A获胜输出A，如果B获胜输出B。 Input示例 3111 Output示例 A 123456789101112131415161718192021222324252627282930import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int N = (int) in.nval; int[] A = new int[N]; for (int i = 0; i &lt; N; i++) { in.nextToken(); A[i] = (int) in.nval; } for (int i = 1; i &lt; N; i++) { A[i] ^= A[i - 1]; } if (A[N - 1] == 0) { out.println(&quot;B&quot;); } else { out.println(&quot;A&quot;); } out.flush(); }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/nim_game/"},{"title":"数组中和等于K的数对","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1001 给出一个整数K和一个无序数组A，A的元素为N个互不相同的整数，找出数组A中所有和等于K的数对。例如K = 8，数组A：{-1,6,5,3,4,2,9,0,8}，所有和等于8的数对包括(-1,9)，(0,8)，(2,6)，(3,5)。 Input 第1行：用空格隔开的2个数，K N，N为A数组的长度。(2 &lt;= N &lt;= 50000，-10^9 &lt;= K &lt;= 10^9)第2 - N + 1行：A数组的N个元素。（-10^9 &lt;= A[i] &lt;= 10^9) Output 第1 - M行：每行2个数，要求较小的数在前面，并且这M个数对按照较小的数升序排列。如果不存在任何一组解则输出：No Solution。 Input示例 8 9-165342908 Output示例 -1 90 82 63 5 分析：先排序，再用双指针，一个头一个尾，向中间扫 双指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;import java.util.Arrays;import java.util.LinkedHashSet;public class Main { static class Pair { long a, b; public Pair(long a, long b) { this.a = a; this.b = b; } } public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); long k = (long) in.nval; in.nextToken(); int n = (int) in.nval; long[] array = new long[n]; for (int i = 0; i &lt; n; i++) { in.nextToken(); array[i] = (long) in.nval; } Arrays.sort(array); int front = 0, end = n - 1; LinkedHashSet&lt;Pair&gt; set = new LinkedHashSet&lt;&gt;(); while (front &lt; end) { if (array[front] + array[end] == k) { set.add(new Pair(array[front], array[end])); front++; end--; } else if (array[front] + array[end] &gt; k) { end--; } else { front++; } } if (set.size() == 0) { out.println(&quot;No Solution&quot;); } else { for (Pair pair : set) { out.println(pair.a + &quot; &quot; + pair.b); } } out.flush(); }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/pairs_in_an_array_whose_sum_equals_k/"},{"title":"质数检测 V2","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1186 给出1个正整数N，检测N是否为质数。如果是，输出”Yes”，否则输出”No”。 Input 输入一个数N(2 &lt;= N &lt;= 10^30) Output 如果N为质数，输出”Yes”，否则输出”No”。 Input示例 17 Output示例 Yes 分析：我才发现 BigInteger 有 isProbablePrime 这种方法，已经实现好了的 Rabin Miller 算法，简直就是作弊…… 1234567891011121314151617181920import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.math.BigInteger;public class Main { public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); BigInteger n = new BigInteger(in.readLine()); if (n.isProbablePrime(9)) { out.println(&quot;Yes&quot;); } else { out.println(&quot;No&quot;); } out.flush(); }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/prime_number_detection_v2/"},{"title":"原根","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1135 设m是正整数，a是整数，若a模m的阶等于φ(m)，则称a为模m的一个原根。（其中φ(m)表示m的欧拉函数）给出1个质数P，找出P最小的原根。 Input 输入1个质数P(3 &lt;= P &lt;= 10^9) Output 输出P最小的原根。 Input示例 3 Output示例 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.io.StreamTokenizer;import java.util.ArrayList;public class Main { static ArrayList&lt;Integer&gt; prime = getPrime(1000000); static ArrayList&lt;Integer&gt; sprime = new ArrayList&lt;&gt;();// 存储P-1的素因子 public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(System.out); in.nextToken(); int p = (int) in.nval; divide(p - 1); for (int g = 2; g &lt; p; g++) { boolean flag = true; for (int i = 0; i &lt; sprime.size(); i++) { int t = (p - 1) / sprime.get(i); if (quickPowerMod(g, t, p) == 1) { flag = false; break; } } if (flag) { out.println(g); break;// 去掉break的话是求所有的原根，加上break是求最小的原根、 } } out.flush(); } static void divide(int n) { // 将n分解为素因子 int t = (int) Math.sqrt(n); for (int i = 0; prime.get(i) &lt;= t; i++) { if (n % prime.get(i) == 0) { sprime.add(prime.get(i)); // 因为有可能有多个prime[i] while (n % prime.get(i) == 0) { n /= prime.get(i); } } } if (n &gt; 1) { sprime.add(n);// 可能只有自己一个素因子 } } static long quickPowerMod(long x, long n, long mod) { long result = 1; while (n &gt; 0) { x = x % mod; if ((n &amp; 1) != 0) result = result * x % mod; x = x * x % mod; n &gt;&gt;= 1; } return result; } static ArrayList&lt;Integer&gt; getPrime(int n) { boolean[] notPrime = new boolean[n + 1]; int sqrtN = (int) Math.sqrt(n); for (int i = 2; i &lt;= sqrtN; i++) { if (notPrime[i]) continue; for (int j = i * i; j &lt;= n; j += i) { // j是i的倍数，即不是素数 notPrime[j] = true; } } ArrayList&lt;Integer&gt; prime = new ArrayList&lt;&gt;(); if (n &gt; 1) prime.add(2); for (int i = 3; i &lt;= n; i += 2) { if (notPrime[i]) continue; prime.add(i); } return prime; }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/root/"},{"title":"子段求和","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1081 给出一个长度为N的数组，进行Q次查询，查询从第i个元素开始长度为l的子段所有元素之和。例如，1 3 7 9 -1，查询第2个元素开始长度为3的子段和，1 {3 7 9} -1。3 + 7 + 9 = 19，输出19。 Input 第1行：一个数N，N为数组的长度(2 &lt;= N &lt;= 50000)。第2 至 N + 1行：数组的N个元素。(-10^9 &lt;= N[i] &lt;= 10^9)第N + 2行：1个数Q，Q为查询的数量。第N + 3 至 N + Q + 2行：每行2个数，i，l（1 &lt;= i &lt;= N，i + l &lt;= N) Output 共Q行，对应Q次查询的计算结果。 Input示例 51379-141 22 23 21 5 Output示例 4101619 分析： 树状数组模版题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int N = (int) in.nval; BinaryIndexedTree tree = new BinaryIndexedTree(N); for (int i = 1; i &lt;= N + 1; i++) { in.nextToken(); int a = (int) in.nval; tree.put(i, a); } int Q = (int) in.nval; for (int i = 0; i &lt; Q; i++) { in.nextToken(); int k = (int) in.nval; in.nextToken(); int l = (int) in.nval; out.println(tree.sum(k + l - 1) - tree.sum(k - 1)); } out.flush(); } static class BinaryIndexedTree { int length; long[] tree; BinaryIndexedTree(int length) { this.length = length; tree = new long[length + 1]; } void put(int index, int value) { while (index &lt;= length) { tree[index] += value; index += lowBit(index); } } static int lowBit(int k) { return k &amp; -k; } long sum(int index) { long sum = 0; while (index &gt; 0) { sum += tree[index]; index -= lowBit(index); } return sum; } }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/subsection_summation/"},{"title":"最大子段和","text":"http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1049 N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。 Input 第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)第2 - N + 1行：N个整数（-10^9 &lt;= A[i] &lt;= 10^9） Output 输出最大子段和。 Input示例 6-211-413-5-2 Output示例 20 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;public class Main { static BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); public static void main(String[] args) throws IOException { int n = Integer.parseInt(in.readLine()); long[] array = new long[n]; int k = 0; for (int i = 0; i &lt; n; i++) { array[i] = Long.parseLong(in.readLine()); if (array[i] &lt; 0) { k++; } } if (k == n) { out.println(0); out.flush(); return; } // 当前最大子列和以及最大子列和 long currentSum = 0; long max = array[0]; for (int i = 0; i &lt; n; i++) { // 如果当前最大子列和是正数，继续加 if (currentSum &gt; 0) { currentSum += array[i]; } else { // 负数则丢弃，因为只会让和变小 currentSum = array[i]; } // 如果当前子列和更大，更新 if (currentSum &gt; max) { max = currentSum; } } out.println(max); out.flush(); }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/sum_of_the_largest_subsections/"},{"title":"威佐夫游戏","text":"威佐夫游戏http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1072 有2堆石子，A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。 例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 2000000) Output 共T行，如果A获胜输出A，如果B获胜输出B。 Input示例 33 53 41 9 Output示例 BAA 分析： 当 k = bk - ak，当 ak == [φ * k] 时，先手输。黄金比例 φ = 1.618033（不知道为什么不能用，只能用 (Math.sqrt(5) + 1) / 2.0 代替） 123456789101112131415161718192021222324252627282930313233343536373839import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int T = (int) in.nval; int[] a = new int[T]; int[] b = new int[T]; for (int i = 0; i &lt; T; i++) { in.nextToken(); a[i] = (int) in.nval; in.nextToken(); b[i] = (int) in.nval; } for (int i = 0; i &lt; T; i++) { if (a[i] &gt; b[i]) { swap(a, b, i); } int k = b[i] - a[i]; int t = (int) (k * (Math.sqrt(5) + 1) / 2.0); out.println(a[i] == t ? &quot;B&quot; : &quot;A&quot;); } out.flush(); } static void swap(int[] a, int[] b, int i) { int t = a[i]; a[i] = b[i]; b[i] = t; }} 威佐夫游戏 V2http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1185 有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。 例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 10^18) Output 共T行，如果A获胜输出A，如果B获胜输出B。 Input示例 33 53 41 9 Output示例 BAA 分析： 输入数据变大，精度要求更高了，可以通过 windows 自带的计算机求出这个黄金比例。 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;import java.math.BigDecimal;import java.math.BigInteger;public class Main { public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); BigDecimal g = new BigDecimal(&quot;1.6180339887498948482045868343656&quot;); int T = Integer.parseInt(in.readLine()); long[] a = new long[T]; long[] b = new long[T]; for (int i = 0; i &lt; T; i++) { String[] tmp = in.readLine().split(&quot; &quot;); a[i] = Long.parseLong(tmp[0]); b[i] = Long.parseLong(tmp[1]); } for (int i = 0; i &lt; T; i++) { if (a[i] &gt; b[i]) { swap(a, b, i); } long k = new BigDecimal(b[i] - a[i]).multiply(g).longValue(); out.println(a[i] == k ? &quot;B&quot; : &quot;A&quot;); } out.flush(); } static void swap(long[] a, long[] b, int i) { long t = a[i]; a[i] = b[i]; b[i] = t; }}","link":"/2018/03/14/zh/programing/basis/algorithm/51nod/wyzhov_game/"},{"title":"回溯法","text":"基本概念类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 设想把你放在一个迷宫里，想要走出迷宫，最直接的办法是什么呢？没错，试。先选一条路走起，走不通就往回退尝试别的路，走不通继续往回退，直到找到出口或所有路都试过走不出去为止。 回顾深度优先搜索左图是一个无向图，从点1开始的DFS过程可能是下图右的情况，其中实线表示搜索时的路径，虚线表示返回时的路径： 基本思想与策略在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，先判断该结点是否包含问题的解： 包含：从该结点出发继续探索下去。 不包含：逐层向其祖先结点回溯。 回溯法就是对隐式图的深度优先搜索算法。 求问题的所有解时，要回溯到根，且根结点的所有可行的子树都已被搜索遍才结束。 求任一个解时，只要搜索到问题的一个解就可以结束。 求解的基本步骤 针对所给问题，定义问题的解空间； 确定易于搜索的解空间结构； 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 子集树与排列树下面的两棵解空间树是回溯法解题时常遇到的两类典型的解空间树。 （1）从n个元素的集合S中找出满足某种性质的子集（相应的解空间树称为子集树）。 如：0-1背包问题(如上图)所相应的解空间树就是子集树，这类子集树通常有$2^n$个叶结点，其结点总个数为$2^n+1 -1$。遍历子集树的算法需时间O($2^n$)。 （2）确定n个元素满足某种性质的排列（相应的解空间树称为排列树）。 如：旅行售货员问题： 某售货员要到4个城市去推销商品，已知各城市之间的路程，请问他应该如何选定一条从城市1出发，经过每个城市一遍，最后回到城市1的路线，使得总的周游路程最小？ 该题的解空间树就是排列树，这类排列树通常有n!个叶结点。遍历子集树的算法需时间O(n!)。 基本框架12345678910111213141516171819202122232425262728293031323334353637class BackTrack { // 原空间 public static int[] originalCurrentAnswer; public BackTrack(int[] originalCurrentAnswer) { BackTrack.originalCurrentAnswer = originalCurrentAnswer; } /* * 回溯法 * @param currentAnswer 当前解空间 * @param currentDepth 当前搜索深度 * @param args 其他参数 */ public static void backTrack(int[] currentAnswer, int currentDepth, String[] args) { // 判断当前的部分解向量 // currentAnswer[1...currentDepth]是否是一个符合条件的解 if (isAnswer(currentAnswer, currentDepth, args)) { // 对于符合条件的解进行处理，通常是输出、计数等 dealAnswer(currentAnswer, currentDepth, args); } else { // 根据当前状态，构造这一步可能的答案 int[] possibleAnswer = buildPossibleAnswer(currentAnswer, currentDepth, args); int possibleAnswerLength = possibleAnswer.length; for (int i = 0; i &lt; possibleAnswerLength; i++) { currentAnswer[currentDepth] = possibleAnswer[i]; // 前者将采取的选择更新到原始数据结构上，后者把这一行为撤销。 make(currentAnswer, currentDepth, args); // 剪枝 if (pruning(currentAnswer, currentDepth, args)) { backTrack(currentAnswer, currentDepth + 1, args); } unmake(currentAnswer, currentDepth, args); } } }} 经典题型求集合的所有子集 对于每个元素都有选和不选两种路径（1选，0不选）解空间就是集合选与不选的状态，这里初始是｛0，0，0｝，也是问题的一个解，空集。这里没有剪枝（具体问题具体加），直接就是深度搜索，直到当前深度等于集合的大小，就可以输出了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class BackTrack { public static int[] originalCurrentAnswer; public BackTrack(int[] originalCurrentAnswer) { BackTrack.originalCurrentAnswer = originalCurrentAnswer; } public static void backTrack(int[] currentAnswer, int currentDepth) { if (isAnswer(currentAnswer, currentDepth)) { dealAnswer(currentAnswer, currentDepth); } else { int[] possibleAnswer = buildPossibleAnswer(currentAnswer, currentDepth); int possibleAnswerLength = possibleAnswer.length; for (int i = 0; i &lt; possibleAnswerLength; i++) { currentAnswer[currentDepth] = possibleAnswer[i]; backTrack(currentAnswer, currentDepth + 1); } } } private static boolean isAnswer(int[] currentAnswer, int currentDepth) { // 当前搜索深度已达到原空间的深度 return currentDepth == originalCurrentAnswer.length; } /* * 按位对应 * 如集合A={a,b} * 对于任意一个元素，在每个子集中，要么存在，要么不存在 * 映射为子集： * (1,1)-&gt;(a,b) (1,0)-&gt;(a) (0,1)-&gt;(b) (0,0)-&gt;空集 */ private static int[] buildPossibleAnswer(int[] currentAnswer, int currentDepth) { // 选or不选即 1, 0 int[] isChosen = { 1, 0 }; return isChosen; } private static void dealAnswer(int[] currentAnswer, int currentDepth) { for (int i = 0; i &lt; currentDepth; i++) { // 如果选，则输出 if (currentAnswer[i] == 1) { System.out.print(originalCurrentAnswer[i] + &quot; &quot;); } } System.out.println(); }} 求全排列 交换两个位置的值，然后进入下一个深度，直到当前深度达到序列的长度。 1234567891011121314151617181920212223242526public static void backTrack(char[] currentAnswer, int currentDepth, int length) { if (currentDepth == length) { System.out.println(new String(currentAnswer)); } else { for (int i = currentDepth; i &lt; length; i++) { if (isUnique(currentAnswer, currentDepth, i)) { // 剪枝（去重） swap(currentAnswer, currentDepth, i); // 交换元素 backTrack(currentAnswer, currentDepth + 1, length); swap(currentAnswer, currentDepth, i); // 还原 } } }}private static boolean isUnique(char[] currentAnswer, int currentDepth, int k) { for (int i = currentDepth; i &lt; length; i++) if (currentAnswer[i] == currentAnswer[k]) return false; return true;}private static void swap(char[] currentAnswer, int m, int n) { char tmp = currentAnswer[n]; currentAnswer[n] = currentAnswer[m]; currentAnswer[m] = tmp;} 八皇后问题将八个皇后摆在一张8*8的国际象棋棋盘上，使每个皇后都无法吃掉别的皇后，一共有多少种摆法？ 在国际象棋中，皇后是最强大的一枚棋子，可以吃掉与其在同行、同列和同斜线的敌方棋子 一种可能的情况： 从空棋盘起，逐行放置棋子。 每在一个布局中放下一个棋子，即推演到下一个新的布局。 如果当前行上没有可合法放置棋子的位置，则回溯到上一行，重新布放上一行的棋子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BackTrack { public static int count = 0; public static int DIM; public BackTrack(int DIM) { BackTrack.DIM = DIM; } public static void backTrack(int[][] chess, int row, int[] isColumnCollision) { if (isAnswer(row)) { dealAnswer(chess); } else { for (int i = 0; i &lt; DIM; i++) { // 同列存在皇后 // 或同对角线存在皇后 // 因为每次都是新的一行，所以不用检查行是否存在皇后 if (isColumnCollision[i] == 1 || isDiagonalCollision(chess, row, i)) continue; chess[row][i] = 1; isColumnCollision[i] = 1; backTrack(chess, row + 1, isColumnCollision); chess[row][i] = 0; isColumnCollision[i] = 0; } } } // 同对角线是否冲突 private static boolean isDiagonalCollision(int[][] chess, int x, int y) { // 以当前皇后坐标为起点，到左上角的对角线 for (int i = x - 1, j = y - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) if (chess[i][j] == 1) return true; // 到右上角的对角线 for (int i = x - 1, j = y + 1; i &gt;= 0 &amp;&amp; j &lt; DIM; i--, j++) if (chess[i][j] == 1) return true; return false; } private static boolean isAnswer(int row) { return row == DIM; } private static void dealAnswer(int[][] chess) { count += 1; for (int i = 0; i &lt; DIM; i++) { for (int j = 0; j &lt; DIM; j++) { System.out.print(chess[i][j] + &quot; &quot;); } System.out.println(); } System.out.println(); }} 参考回溯法与八皇后问题 火力网问题在一个n*n的网格里，每个网格可能为“墙壁”（用x表示）和“街道”（用o表示）。现在在街道放置碉堡，每个碉堡可以向上下左右四个方向开火，子弹射程无限远。墙壁可以阻挡子弹。问最多能放置多少个碉堡，使它们彼此不会互相摧毁。 如下图，墙壁用黑正方形表示，街道用空白正方形表示，圆球就代表碉堡。 1、2、3可行，4、5不可行。因为4、5的两个碉堡同行、同列，他们会互相攻击。 类似八皇后问题 参考回溯算法（解火力网问题）","link":"/2018/02/21/zh/programing/basis/algorithm/5_basic_algorithms/backtracking/"},{"title":"分支限界法","text":"基本概念类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 （1）分支搜索算法所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式： FIFO搜索 LIFO搜索 优先队列式搜索 （2）分支限界搜索算法 基本思想与策略由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。 支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。 在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。 回溯法和分支限界法的一些区别有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？ 回溯法和分支限界法的一些区别： 方法对解空间树的搜索方式存储结点的常用数据结构结点存储特性常用应用 回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解 分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解 经典题型","link":"/2018/02/21/zh/programing/basis/algorithm/5_basic_algorithms/branch_and_bound_method/"},{"title":"分治法","text":"基本概念字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。 例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。 基本思想与策略将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 策略：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。 如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 适用情况分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。 第1条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；第2条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；第3条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。第4条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。 求解的基本步骤实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。 先找到最小问题规模时的求解方法 然后考虑随着问题规模增大时的求解方法 找到求解的递归函数式后（各种规模或因子），设计递归程序即可。 分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题； 合并：将各个子问题的解合并为原问题的解。 Divide-and-Conquer(P) if |P|≤n0 then return(ADHOC(P)) 将P分解为较小的子问题 P1 ,P2 ,…,Pk for i←1 to k do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi T ← MERGE(y1,y2,…,yk) △ 合并子问题 return(T) 其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。 ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。 算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。 经典题型 二分搜索 大整数乘法 Strassen矩阵乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔","link":"/2018/02/21/zh/programing/basis/algorithm/5_basic_algorithms/divide_and_conquer/"},{"title":"动态规划","text":"基本概念过程：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 基本思想与策略基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用的情况能采用动态规划求解的问题的一般要具有3个性质： 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响当前状态。 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。 动态规划的设计都有着一定的模式，一般要经历以下几个步骤： 初始状态 → │决策１│ → │决策２│ → … → │决策ｎ│ → 结束状态 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计： 分析最优解的性质，并刻画其结构特征。 递归的定义最优解。 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 根据计算最优值时得到的信息，构造问题的最优解 算法实现的说明动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： 问题的阶段 每个阶段的状态 从前一个阶段转化到后一个阶段之间的递推关系 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。dp(n, m) = max{ dp(n-1, m), dp(n-1, m-w[n]) + P(n, m) } 经典题型背包问题0-1背包：每种物品只有一个，只有两种状态：拿或不拿，即0或1。完全背包：每种物品无限个。多重背包：每种物品有限个num[i]。 0-1背包问题描述：有n个物品，它们有各自的重量和价值，给定一个容量固定的背包，如何装才能让背包里装的物品价值总和最大？ 分析： 二维表dp[i][capacity]：面对第i个物品，且背包容量为capacity时，在做决策后所能获得的最大价值。 决策：为使背包中物品价值总和最大化，第i个物品应该装进去吗？ 当capacity &lt; weight[i]时，背包容量不足以放下第i个物品，不能装。dp[i][capacity] = dp[i-1][capacity]，表示和上一次状态一样。 当capacity &gt;= weight[i]时，背包能放下第i个物品，这时候要考虑装下该物品时能否获得更大价值。若不装：dp[i][capacity] = dp[i-1][capacity]若装：dp[i][capacity] = dp[i-1][capacity-weight[i]] + value[i]，其中dp[i-1][capacity-weight[i]]表示：在上一次面对第i-1个物品，背包容量为capacity-weight[i]时做出决策后的最大价值。 装不装，就取决于这两个情况下，哪种获得的价值最大。 由上即得状态转移方程：dp[i][capacity] = max{ dp[i-1][capacity], dp[i-1][capacity-weight[i]] + value[i] }; 例题：山洞里共有a, b, c, d, e这5个宝物，重量分别是2, 2, 6, 5, 4，价值分别是6, 3, 5, 4, 6，你有容量为10的背包，怎样装才能带走最多的财富？ 物品 a b c d e 重量 2 2 6 5 4 价值 6 3 5 4 6 二维表dp[6][11]，根据状态转移方程，依次填好表格。行：5个物品列：背包容量 0 1 2 3 4 5 6 7 8 9 10 a 0 6 6 6 6 6 6 6 6 6 b 0 6 6 9 9 9 9 9 9 9 c 0 6 6 9 9 9 9 11 11 14 d 0 6 6 9 9 9 10 11 13 14 e 0 6 6 9 9 12 12 15 15 15 填写过程： 容量 决策过程 1 都放不下，故都为0。 …… …… 4 面对a时，因为容量4&gt;重量2，且是第1个物品，所以装入a。面对b时，4&gt;2，找到面对a时容量4-2=2时的背包最大价值6，若装：6+3=9；若不装：6。而9&gt;6，所以装入b。面对……。 …… …… 8 面对……。面对e时，8&gt;4，找到面对d时容量8-4=4时的背包最大价值9，若装：9+6=15；若不装：11。而15&gt;11，所以装入e。 二维数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Main { // 背包容量 private static int capacity = 10; private static String[] items = new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; }; private static int[] weight = new int[] { 2, 2, 6, 5, 4 }; private static int[] value = new int[] { 6, 3, 5, 4, 6 }; // 决策表 private static int[][] dp = new int[items.length][capacity + 1]; public static void main(String[] args) { decide(); outPutMaxValue(); outPutChosenItems(); } private static void decide() { for (int j = 1; j &lt;= capacity; j++) { for (int i = 0; i &lt; items.length; i++) { if (j &gt;= weight[i]) { if (i == 0) { dp[i][j] = value[i]; continue; } dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } else { if (i == 0) { dp[i][j] = 0; continue; } dp[i][j] = dp[i - 1][j]; } } } } private static void outPutChosenItems() { int[] isChosen = new int[items.length]; for (int i = items.length - 1, c = capacity; i &gt; 0; i--) { if (dp[i][c] == dp[i - 1][c]) { isChosen[i] = 0; } else { isChosen[i] = 1; c -= weight[i]; } if (i - 1 == 0) { isChosen[0] = dp[0][c] &gt; 0 ? 1 : 0; } } for (int i = 0; i &lt; items.length; i++) { if (isChosen[i] == 1) { System.out.print(items[i] + &quot; &quot;); } } System.out.println(); } private static void outPutMaxValue() { System.out.println(dp[items.length - 1][capacity]); }} 一维数组123456789101112131415161718192021222324252627282930313233343536373839public class Main { private static int capacity = 10; private static String[] items = new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; }; private static int[] weight = new int[] { 2, 2, 6, 5, 4 }; private static int[] value = new int[] { 6, 3, 5, 4, 6 }; private static int[] dp = new int[capacity + 1]; private static int[][] path = new int[items.length][capacity]; public static void main(String[] args) { decide(); outPutMaxValue(); outPutChosenItems(); } private static void decide() { for (int i = 0; i &lt; items.length; i++) { for (int j = capacity; j &gt;= weight[i]; j--) { if (dp[j] &lt; dp[j - weight[i]] + value[i]) { dp[j] = dp[j - weight[i]] + value[i]; path[i][j] = 1; } } } } private static void outPutChosenItems() { for (int i = items.length - 1, c = capacity; i &gt;= 0 &amp;&amp; c &gt;= 0; i--) { if (path[i][c] == 1) { System.out.print(items[i] + &quot; &quot;); c -= weight[i]; } } System.out.println(); } private static void outPutMaxValue() { System.out.println(dp[capacity]); }} HDU2456：饭卡如果购买一个商品前，卡上剩余金额&gt;=5元，就一定可以购买成功（即使购买后卡上余额为负）；否则无法购买（即使金额足够）。某天，饭堂有n种菜出售，每种菜可购买一次。已知菜的价格和卡上余额，问最少可使卡上余额为多少？ 输入：第一行为整数n，表示菜的数量（n&lt;=1000）第二行包括n个正整数，表示每种菜的价格（不超过50）第三行为正整数m，表示卡上的余额（m&lt;=1000） 输出：卡上最小余额 样例输入1：1505 样例输出1：-45 样例输入2：101 2 3 2 1 1 2 3 2 150 样例输出2：32 分析：每种菜只有买和不买2种情况，并且前面买了菜后剩余的钱影响后面的决策，所以是动态规划，而且是0-1背包。什么时候余额最少呢？应该是余额最接近5时，选最贵的菜，余额最少。比如只有5块钱，类似样例输入1那样买最贵的50块，这样就变最少了。 因为只有余额&gt;=5块钱才能用，所以5块钱要保留下来。更进一步地转化为0-1背包：保留余额中的5块钱，而另一部分钱（背包容量）就尽可能花到剩下最少（最贵的菜还不能买），最后再去买最贵的菜。 比如：有3种菜，价格分别是2, 3, 1，卡上余额为7。保留5块钱，为了尽可能花完剩下的7-5=2块钱，就买了第1个菜，2块钱就花完了，最后用5块钱买最贵的那个3块钱的菜，这样最少余额为2。 一维数组 AC1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.BufferedInputStream;import java.util.Arrays;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(new BufferedInputStream(System.in)); while (true) { int n = scanner.nextInt(); if (n == 0) { break; } int[] need = new int[n]; for (int i = 0; i &lt; n; i++) { need[i] = scanner.nextInt(); } int card = scanner.nextInt(); // 如果卡余额不足5块钱，买不了菜 if (card &lt; 5) { System.out.println(card); continue; } // 方便后面选最贵菜 Arrays.sort(need); if (card == 5 || n == 1) { System.out.println(card - need[n - 1]); } else { // 分成5块钱和另外剩下的一部分钱 int rest = card - 5; int[] dp = new int[rest + 1]; // 最贵的菜要留到最后买，所以这里不买最贵的菜，故 n-1 for (int i = 0; i &lt; n - 1; i++) { for (int j = rest; j &gt;= need[i]; j--) { dp[j] = Math.max(dp[j], dp[j - need[i]] + need[i]); } } System.out.println(card - dp[rest] - need[n - 1]); } } }} HDU1171：Big Event in HDUNowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don’t know that Computer College had ever been split into Computer College and Software College in 2002.The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too. All facilities must go halves. First, all facilities are assessed, and two facilities are thought to be same if they have the same value. It is assumed that there is N (0&lt;N&lt;1000) kinds of facilities (different value, different kinds). 输出：Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 50 – the total number of different facilities). The next N lines contain an integer V (0&lt;V&lt;=50 –value of facility) and an integer M (0&lt;M&lt;=100 –corresponding number of the facilities) each. You can assume that all V are different.A test case starting with a negative integer terminates input and this test case is not to be processed. 输出：For each case, print one line containing two integers A and B which denote the value of Computer College and Software College will get respectively. A and B should be as equal as possible. At the same time, you should guarantee that A is not less than B. 样例输入：210 120 1310 120 230 1-1 样例输出：20 1040 40 大意：A，B学院平分所有的设施装置，假设有N种装置（0&lt;N&lt;1000），不同装置不同价值（如果有2个价值一样的装置，那就把它们看成一样的），要求平分后的价值差不多，如果不相等，A得到的价值应该大于B的。 分析：多重背包，价值和重量一样。 将所有装置价值总和/2后当成背包大小，这个背包就相当于学院B，然后去拿装置，拿剩的就是另一个学院A的。比如样例1：10 120 1背包大小就是15，学院B只能拿10，而学院A就拿剩下的20。 注意：n&lt;0才退出输入。 AC12345678910111213141516171819202122232425262728293031import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); public static void main(String[] args) { int n = scanner.nextInt(); while (n &gt; 0) { int sum = 0; int[] value = new int[n]; int[] num = new int[n]; for (int i = 0; i &lt; n; i++) { value[i] = scanner.nextInt(); num[i] = scanner.nextInt(); sum += value[i] * num[i]; } int capacity = sum &gt;&gt; 1; int[] dp = new int[capacity + 1]; for (int i = 0; i &lt; n; i++) { for (int k = 0; k &lt; num[i]; k++) { for (int j = capacity; j &gt;= value[i]; j--) { dp[j] = Math.max(dp[j], dp[j - value[i]] + value[i]); } } } System.out.println((sum - dp[capacity]) + &quot; &quot; + dp[capacity]); n = scanner.nextInt(); } }} HDU2602：Bone Collector裸0-1背包 输入：第一行为整数T，表示测试样例个数，每个样例三行第二行包括两个整数N，V，分别表示骨头数量和背包体积(N&lt;=1000，V&lt;=1000)第三行包括N个整数，表示每根骨头的价值第四行包括N个整数，表示每根骨头的体积 输出：最大价值 样例输入：15 101 2 3 4 55 4 3 2 1 样例输出：14 AC123456789101112131415161718192021222324252627282930import java.io.BufferedInputStream;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(new BufferedInputStream(System.in)); int n = scanner.nextInt(); if (n == 0) { return; } for (; n &gt; 0; n--) { int nums = scanner.nextInt(); int bag = scanner.nextInt(); int[] value = new int[nums]; int[] volume = new int[nums]; for (int i = 0; i &lt; nums; i++) { value[i] = scanner.nextInt(); } for (int i = 0; i &lt; nums; i++) { volume[i] = scanner.nextInt(); } int[] dp = new int[bag + 1]; for (int i = 0; i &lt; nums; i++) { for (int j = bag; j &gt;= volume[i]; j--) { dp[j] = Math.max(dp[j], dp[j - volume[i]] + value[i]); } } System.out.println(dp[bag]); } }} HDU2639：Bone Collector IIToday we are not desiring the maximum value of bones,but the K-th maximum value of the bones.NOTICE that,we considerate two ways that get the same value of bones are the same.That means,it will be a strictly decreasing sequence from the 1st maximum , 2nd maximum .. to the K-th maximum. If the total number of different values is less than K,just ouput 0. 输入：The first line contain a integer T , the number of cases.Followed by T cases , each case three lines , the first line contain two integer N , V, K(N &lt;= 100 , V &lt;= 1000 , K &lt;= 30)representing the number of bones and the volume of his bag and the K we need. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone. 输出：One integer per line representing the K-th maximum of the total value (this number will be less than 231). 样例输入：35 10 21 2 3 4 55 4 3 2 15 10 121 2 3 4 55 4 3 2 15 10 161 2 3 4 55 4 3 2 1 样例输出：1220 分析：这次是找第K个最优解，上一题是第1个最优。 第K个最优解：在0-1背包中，状态数组是f[c]，表示在容量为c时的最优决策，而不是最优的并没有保存下来。比如：f[c] = max{1, 2}中，最优f[c] = 2，而1被舍弃了。 而现在，我不仅想知道最优决策，我还想知道稍微差一点的决策，即第2决策、第3决策……排个名。f[c]我们可以看做是f[c][1]这样的二维数组，它的第二维只有一个元素，也就是最优决策。现在我们增大第二维，比如：f[c][3]，表示不仅保留了最优解1，次解2，3也保留下来了。 即在决策过程中，不把前一个状态的最优解扔掉，而是保存下来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedInputStream;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(new BufferedInputStream(System.in)); int n = scanner.nextInt(); if (n == 0) { return; } for (; n &gt; 0; n--) { int nums = scanner.nextInt(); int bag = scanner.nextInt(); int k = scanner.nextInt(); int[] value = new int[nums]; int[] volume = new int[nums]; for (int i = 0; i &lt; nums; i++) { value[i] = scanner.nextInt(); } for (int i = 0; i &lt; nums; i++) { volume[i] = scanner.nextInt(); } int[][] dp = new int[bag + 1][31]; int[] a = new int[31], b = new int[31]; for (int i = 0; i &lt; nums; i++) { for (int j = bag; j &gt;= volume[i]; j--) { for (int t = 1; t &lt;= k; t++) { // 把解都保存起来 a[t] = dp[j][t]; b[t] = dp[j - volume[i]][t] + value[i]; } a[k + 1] = b[k + 1] = -1; int t = 1, ai = 1, bi = 1; // 下面的循环相当于求a和b并集，也就是所有的可能解 while (t &lt;= k &amp;&amp; (a[ai] &lt;=k || b[bi] &lt;=k)) { if (a[ai] &gt; b[bi]) { dp[j][t] = a[ai]; ai++; } else { dp[j][t] = b[bi]; bi++; } if (dp[j][t] != dp[j][t - 1]) { t++; } } } System.out.println(dp[bag][k]); } }} 完全背包一维数组123456789101112131415161718192021222324public class Main { private static int capacity = 10; private static String[] items = new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; }; private static int[] weight = new int[] { 2, 2, 6, 5, 4 }; private static int[] value = new int[] { 6, 3, 5, 4, 6 }; private static int[] dp = new int[capacity + 1]; public static void main(String[] args) { decide(); outPutMaxValue(); } private static void decide() { for (int i = 0; i &lt; items.length; i++) { for (int j = weight[i]; j &lt;= capacity; j++) { dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } } } private static void outPutMaxValue() { System.out.println(dp[capacity]); }} 多重背包模版123456789101112131415161718192021222324252627public class Main { private static int capacity = 10; private static String[] items = new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; }; private static int[] weight = new int[] { 2, 2, 6, 5, 4 }; private static int[] value = new int[] { 6, 3, 5, 4, 6 }; private static int[] num = new int[] { 2, 3, 1, 4, 2 }; private static int[] dp = new int[capacity + 1]; public static void main(String[] args) { decide(); outPutMaxValue(); } private static void decide() { for (int i = 0; i &lt; items.length; i++) { for (int k = 0; k &lt; num[i]; k++) { for (int j = capacity; j &gt;= weight[i]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } } } } private static void outPutMaxValue() { System.out.println(dp[capacity]); }} 例子HDU2159：FATE最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？ 输入：输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个) 输出：输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。 样例输入：10 10 1 101 110 10 1 91 19 10 2 101 12 2 样例输出：0-11 1","link":"/2018/02/21/zh/programing/basis/algorithm/5_basic_algorithms/dynamic_programming/"},{"title":"贪心法","text":"基本概念所谓贪心是指：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。 贪心法没有固定的算法框架，算法设计的关键是贪心策略的选择。 注意： 贪心算法不是对所有问题都能得到整体最优解。 选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。 所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 求解的基本步骤 建立数学模型来描述问题。 把求解的问题分成若干个子问题。 对每个子问题求解，得到子问题的局部最优解。 把子问题的局部最优解合成原来解问题的一个解。 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。 基本框架1234567从问题的某一初始解出发；while (能朝给定总目标前进一步) { 利用可行的决策，求出可行解的一个解元素；}由所有解元素组合成问题的一个可行解； 例题分析下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。 [0-1背包]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。物品 A B C D E F G重量 35 30 60 50 40 10 25价值 10 40 30 50 35 40 30 分析：目标函数： ∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) 根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ 每次挑选所占重量最小的物品装入是否能得到最优解？ 每次选取单位重量价值最大的物品，成为解本题的策略。 值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。 贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。 可惜的是，它需要证明后才能真正运用到题目的算法中。 一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。 对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下： （1）贪心策略：选取价值最大者。反例：W=30物品：A B C重量：28 12 12价值：30 20 20根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 （3）贪心策略：选取单位重量价值最大的物品。反例：W=30物品：A B C重量：28 20 10价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 经典题型","link":"/2018/02/21/zh/programing/basis/algorithm/5_basic_algorithms/greedy_algorithm/"},{"title":"蓝桥杯2015年第5届Java-B组省赛","text":"正则表达式有的时候，恰当地使用正则，可以让我们的工作事半功倍！ 如下代码用来检验一个四则运算式中数据项的数目，请填写划线部分缺少的代码。 注意：只填写缺少代码，不要写任何多余内容，例如，已有的双引号。 1234567891011121314public class A{ public static int f(String s) { //return s.split(&quot;________________&quot;).length; //填空 return s.split(&quot;\\\\p{Punct}&quot;).length; } public static void main(String[] args) { System.out.println(f(&quot;12+35*5-2*18/9-3&quot;)); //7 System.out.println(f(&quot;354*12+3-14/7*6&quot;)); //6 }} 调和级数1/1 + 1/2 + 1/3 + 1/4 + … 在数学上称为调和级数。 它是发散的，也就是说，只要加上足够多的项，就可以得到任意大的数字。 但是，它发散的很慢：前1项和达到 1.0前4项和才超过 2.0前83项的和才超过 5.0 那么，请你计算一下，要加多少项，才能使得和达到或超过 15.0 呢？ 请填写这个整数。 1835421 暴力123456789101112public class Main { public static void main(String[] args) { double sum = 0; for (int i = 1; i &lt; Integer.MAX_VALUE; i++) { sum += 1.0 / i; if (sum &gt;= 15.0) { System.out.println(i); break; } } }} 近似值如果x的x次幂结果为10，你能计算出x的近似值吗？ 显然，这个值是介于2和3之间的一个数字。 请把x的值计算到小数后6位（四舍五入），并填写这个小数值。 2.506184 注意：只填写一个小数，不要写任何多余的符号或说明。 二分1234567891011121314151617public class Main { public static void main(String[] args) { double start = 2.0, end = 3.0; while (true) { double middle = (start + end) / 2; double result = Math.pow(middle, middle); if (result == 10.0) { System.out.println(middle); break; } else if (result &gt; 10.0) { end = middle; } else { start = middle; } } }} 勾股定理勾股定理，西方称为毕达哥拉斯定理，它所对应的三角形现在称为：直角三角形。 已知直角三角形的斜边是某个整数，并且要求另外两条边也必须是整数。 求满足这个条件的不同直角三角形的个数。 数据格式：输入一个整数 n (0&lt;n&lt;10000000) 表示直角三角形斜边的长度。要求输出一个整数，表示满足条件的直角三角形个数。 样例输入1：5输出：1 样例输入2：100输出：2 样例输入3：3输出：0 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 暴力123456789101112131415161718import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int solution = 0; for (int i = 1; i &lt; n; i++) { // 利用开方和取整减少一层循环去猜测第3条边 int b = (int) Math.sqrt(n * n - i * i); if (b != 0 &amp;&amp; i * i + b * b == n * n) { solution++; } } System.out.println(solution / 2); }} 数独如图，玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个同色九宫内的数字均含1-9，不重复。 数独的答案都是唯一的，所以，多个解也称为无解。 本图的数字据说是芬兰数学家花了3个月的时间设计出来的较难的题目。但对会使用计算机编程的你来说，恐怕易如反掌了。 本题的要求就是输入数独题目，程序输出数独的唯一解。我们保证所有已知数据的格式都是合法的，并且题目有唯一的解。 格式要求，输入9行，每行9个字符，0代表未知，其它数字为已知。输出9行，每行9个数字表示数独的解。 样例输入1（即图中题目）：005300000800000020070010500400005300010070006003200080060500009004000030000009700 输出：145327698839654127672918543496185372218473956753296481367542819984761235521839764 样例输入2：800000000003600000070090200050007000000045700000100030001000068008500010090000400 输出：812753649943682175675491283154237896369845721287169534521974368438526917796318452 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(System.in); static int[][] map = new int[9][9]; public static void main(String[] args) { for (int i = 0; i &lt; 9; i++) { String buf = scanner.next(); char[] num = buf.toCharArray(); for (int j = 0; j &lt; 9; j++) { map[i][j] = num[j] - 48; } } backTrack(0, 0); } static void backTrack(int x, int y) { if (x == 9 &amp;&amp; y == 0) { for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 9; j++) { System.out.print(map[i][j] + &quot; &quot;); } System.out.println(); } System.exit(0); } else { // 还没填数 if (map[x][y] == 0) { for (int i = 1; i &lt;= 9; i++) { map[x][y] = i; if (!isRowCollision(x, y) &amp;&amp; !isColumnCollision(x, y) &amp;&amp; !is3x3Collision(x, y)) { // 从左到右，从上到下填 backTrack(x + (y + 1) / 9, (y + 1) % 9); } map[x][y] = 0; } } else { // 填了的就继续下一个 backTrack(x + (y + 1) / 9, (y + 1) % 9); } } } static boolean isRowCollision(int x, int y) { for (int i = 0; i &lt; 9; i++) { if (map[x][y] == map[x][i] &amp;&amp; y != i) { return true; } } return false; } static boolean isColumnCollision(int x, int y) { for (int i = 0; i &lt; 9; i++) { if (map[x][y] == map[i][y] &amp;&amp; x != i) { return true; } } return false; } static boolean is3x3Collision(int x, int y) { int start, end; if (x &lt; 3) { start = 0; } else if (x &lt; 6) { start = 3; } else { start = 6; } if (y &lt; 3) { end = 0; } else if (y &lt; 6) { end = 3; } else { end = 6; } for (int i = start; i &lt; start + 3; i++) { for (int j = end; j &lt; end + 3; j++) { if (map[i][j] == map[x][y] &amp;&amp; i != x &amp;&amp; j != y) { return true; } } } return false; }} 敢死队G将军有一支训练有素的军队，这个军队除开G将军外，每名士兵都有一个直接上级（可能是其他士兵，也可能是G将军）。现在G将军将接受一个特别的任务，需要派遣一部分士兵（至少一个）组成一个敢死队，为了增加敢死队队员的独立性，要求如果一名士兵在敢死队中，他的直接上级不能在敢死队中。 请问，G将军有多少种派出敢死队的方法。注意，G将军也可以作为一个士兵进入敢死队。 输入格式：输入的第一行包含一个整数n，表示包括G将军在内的军队的人数。军队的士兵从1至n编号，G将军编号为1。接下来n-1个数，分别表示编号为2, 3, …, n的士兵的直接上级编号，编号i的士兵的直接上级的编号小于i。 输出格式：输出一个整数，表示派出敢死队的方案数。由于数目可能很大，你只需要输出这个数除10007的余数即可。 样例输入1：31 1输出：4 样例说明：这四种方式分别是： 选1； 选2； 选3； 选2, 3。 样例输入2：71 1 2 2 3 3输出：40 数据规模与约定：对于20%的数据，n ≤ 20；对于40%的数据，n ≤ 100；对于100%的数据，1 ≤ n ≤ 100000。 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 分析：树形动态规划 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.BufferedInputStream;import java.util.Scanner;import java.util.LinkedList;import java.util.List;public class Main { static class Node { // 士兵的下级 List&lt;Integer&gt; subordinate = new LinkedList&lt;&gt;(); int[] dp = { 1, 1 }; } static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int n = scanner.nextInt(); static Node[] node = new Node[n + 1]; public static void main(String[] args) { for (int i = 1; i &lt;= n; i++) { node[i] = new Node(); } for (int i = 2; i &lt;= n; i++) { int m = scanner.nextInt(); // 储存下级 node[m].subordinate.add(i); } for (int i = n; i &gt; 0; i--) { for (int j = 0; j &lt; node[i].subordinate.size(); j++) { int sub = node[i].subordinate.get(j); node[i].dp[1] *= (node[sub].dp[0]) % 10007; node[i].dp[0] *= (node[sub].dp[0] + node[sub].dp[1]) % 10007; } } // 减去所有都没有去的情况 int count = (node[1].dp[0] + node[1].dp[1] - 1) % 10007; System.out.println(count); }}","link":"/2018/01/25/zh/programing/basis/algorithm/blue_bridge_cup/5th_province/"},{"title":"蓝桥杯2015年第6届省赛","text":"结果填空三角形面积如图所示，图中的所有小方格面积都是1。 那么，图中的三角形面积应该是多少呢？ 请填写三角形的面积。不要填写任何多余内容或说明性文字。 手算： 正方形面积：64左边直角三角形：$\\frac{ 8 \\times 4 }{ 2 } = 16$右上角直角三角形：$\\frac{ 8 \\times 2 }{ 2 } = 8$右下角直角三角形：$\\frac{ 6 \\times 4 }{ 2 } = 12$三角形面积即：64 - 16 - 8 - 12 = 28 立方变自身观察下面的现象,某个数字的立方，按位累加仍然等于自身。1^3 = 1，1 = 18^3 = 512，5 + 1 + 2 = 817^3 = 4913，4 + 9 +1 + 3 = 17… 请你计算包括1，8，17在内，符合这个性质的正整数一共有多少个？ 6 请填写该数字，不要填写任何多余的内容或说明性的文字。 暴力123456789101112131415161718192021public class Main { public static void main(String args[]) { int num = 0; for (int i = 1; i &lt; 999999; i++) { if (sumEach(i)) { num++; } } System.out.println(num); } private static boolean sumEach(int n) { int sum = 0; int cube = n * n * n; while (cube &gt; 0) { sum += cube % 10; cube /= 10; } return sum == n; }} 三羊献瑞观察下面的加法算式： 其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。 请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。1 0 8 5 回溯12345678910111213141516171819202122232425262728293031323334353637383940public class Main { static int[] number = new int[10]; static int[] anwser = new int[8]; public static void main(String args[]) { backTrack(0); } static void backTrack(int current) { // current 从 0 开始，到 8 时共 9 个数字 // 而题目只有 9 个数字，故到数组第 8 位时停下 if (current == 8) { // 是否满足题设 if (isOK()) { System.out.println(anwser[4] + &quot; &quot; + anwser[5] + &quot; &quot; + anwser[6] + &quot; &quot; + anwser[1]); } } else { // 尝试填入 0~9 这 10 个数字 for (int i = 0; i &lt;= 9; i++) { // 如果数字已经用过就跳过 if (number[i] == 1) { continue; } anwser[current] = i; number[i] = 1; // 尝试填入下一位 backTrack(current + 1); number[i] = 0; } } } static boolean isOK() { int A = anwser[0] * 1000 + anwser[1] * 100 + anwser[2] * 10 + anwser[3]; int B = anwser[4] * 1000 + anwser[5] * 100 + anwser[6] * 10 + anwser[1]; int S = anwser[4] * 10000 + anwser[5] * 1000 + anwser[2] * 100 + anwser[1] * 10 + anwser[7]; // “三”出现了 2 次，而且在最高位，故不可能为 0 return anwser[4] != 0 &amp;&amp; A + B == S; }} 加法变乘法我们都知道：1+2+3+ … + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015 比如：1+2+3+…+1011+12+…+2728+29+…+49 = 2015就是符合要求的答案。 请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。16 12345678910111213141516public class Main { public static void main(String[] args) { for (int i = 1; i &lt; 47; i++) { for (int j = i + 2; j &lt; 49; j++) { int sum = 1225; // 1+2+3+4+5 = 15 // 1*2+3*4+5 = 19 =&gt; 15-(1+2+3+4)+(1*2+3*4) sum -= i + (i + 1) + j + (j + 1); sum += i * (i + 1) + j * (j + 1); if (sum == 2015) { System.out.println(i); } } } }} 牌型种数小明被劫持到X赌城，被迫与其他3人玩牌。一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。 这时，小明脑子里突然冒出一个问题：如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？3598180 分析：13种不同的牌，每种4张花色，排除花色，就是每种牌可以出现0-4次。 回溯1234567891011121314151617181920212223242526272829303132public class Main { private static int have = 0; private static int total = 0; public static void main(String[] args) { backTrack(0); System.out.println(total); } private static void backTrack(int times) { // 如果手上拿的牌数 &gt; 13，退出这种状态 if (have &gt; 13) { return; } // 第 13 次，并且手上也是 13 张牌 // 应该是牌型的不同数量不会出现同种点数 if (times == 13) { if (have == 13) { total++; } } else { for (int i = 0; i &lt;= 4; i++) { // 这种牌拿多少张 // 比如第一次：A 拿 4 张 have += i; // 下一种牌型：2~K backTrack(times + 1); have -= i; } } }} 熊怪吃核桃森林里有一只熊怪，很爱吃核桃。不过它有个习惯，每次都把找到的核桃分成相等的两份，吃掉一份，留一份。如果不能等分，熊怪就会扔掉一个核桃再分。第二天再继续这个过程，直到最后剩一个核桃了，直接丢掉。 有一天，熊怪发现了1543个核桃，请问，它在吃这些核桃的过程中，一共要丢掉多少个核桃。5 1234567891011121314public class Main { public static void main(String[] args) { int count = 0; int n = 1543; while (n &gt; 0) { if ((n &amp; 1) == 1) { n--; count++; } n /= 2; } System.out.println(count); }} 星系炸弹在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。 请填写该日期，格式为 yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19 2017-8-4 12345678910import java.util.Calendar;public class Main { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); calendar.set(2014, 11, 9); calendar.add(Calendar.DATE, 1000); System.out.println(calendar.get(Calendar.YEAR) + &quot;-&quot; + calendar.get(Calendar.MONTH) + &quot;-&quot; + calendar.get(Calendar.DATE)); }} 九数分三组1~9的数字可以组成3个3位数，设为：A,B,C, 现在要求满足如下关系：B = 2 * AC = 3 * A 请你写出A的所有可能答案，数字间用空格分开，数字按升序排列。 192 219 273 327 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.LinkedList;import java.util.List;public class Main { static int[] num = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; static int A, B, C; static List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); public static void main(String[] args) { backTrack(0); list.stream().forEach(x -&gt; System.out.print(x + &quot; &quot;)); } static void backTrack(int n) { if (n == 9) { if (isOK()) { list.add(A); } } else { for (int i = n; i &lt; 9; i++) { swap(i, n); backTrack(n + 1); swap(i, n); } } } static boolean isOK() { A = num[0] * 100 + num[1] * 10 + num[2]; B = num[3] * 100 + num[4] * 10 + num[5]; C = num[6] * 100 + num[7] * 10 + num[8]; return B == 2 * A &amp;&amp; C == 3 * A; } static void swap(int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; }} 方程整数解方程: $a^2 + b^2 + c^2 = 1000$ 这个方程有整数解吗？有：a,b,c=6,8,30 就是一组解。你能算出另一组合适的解吗？ 请填写该解中最小的数字。10 24 18 10 1234567891011121314public class Main { public static void main(String[] args) { int sqrt = (int) Math.sqrt(1000); for (int a = 1; a &lt; sqrt; a++) { for (int b = 1; b &lt; a; b++) { for (int c = 1; c &lt; b; c++) { if (a * a + b * b + c * c == 1000) { System.out.println(a + &quot; &quot; + b + &quot; &quot; + c); } } } } }} 奇妙的数字小明发现了一个奇妙的数字：它的平方和立方正好把0~9的10个数字每个用且只用了一次。 你能猜出这个数字是多少吗？69 123456789101112131415161718192021222324252627282930313233343536373839404142public class Main { static int[] num = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; public static void main(String[] args) { backTrack(0); } static void backTrack(int n) { if (n == 10) { judge(); } else { for (int i = n; i &lt; 10; i++) { swap(i, n); backTrack(n + 1); swap(i, n); } } } static void judge() { if (num[0] == 0 || num[4] == 0) { return; } // 100：平方位数5、立方位数7，位数和超过10 // 50：平方位数4、立方位数6，位数和是10 // 所以 a &lt; 100 int square = num[0] * 1000 + num[1] * 100 + num[2] * 10 + num[3]; int cube = num[4] * 100000 + num[5] * 10000 + num[6] * 1000 + num[7] * 100 + num[8] * 10 + num[9]; int n = (int) Math.sqrt(square); int m = (int) Math.cbrt(cube); if (n == m &amp;&amp; n * n == square &amp;&amp; n * n * n == cube) { System.out.println(n + &quot; &quot; + square + &quot; &quot; + cube); System.exit(0); } } static void swap(int i, int j) { int tmp = num[i]; num[i] = num[j]; num[j] = tmp; }} 手链样式小明有3颗红珊瑚，4颗白珊瑚，5颗黄玛瑙。他想用它们串成一圈作为手链，送给女朋友。 现在小明想知道：如果考虑手链可以随意转动或翻转，一共可以有多少不同的组合样式呢？1170 组合：不考虑翻转：$[12! / (3! x 4! x 5!)] / 12 = 2310$种考虑翻转：求出左右对称的情况，将1个A，1个C两边都隔5个，剩下2个A，4个B，4个C，两边对称，即将ABBCC排列，共5!/(2 x 2) = 30种。结果：30 + (2310 - 30)/2 = 1170 立方尾不变有些数字的立方的末尾正好是该数字本身。比如：1,4,5,6,9,24,25,…. 请你计算一下，在10000以内的数字中（指该数字，并非它立方后的数值），符合这个特征的正整数一共有多少个。36 123456789101112131415161718public class Main { public static void main(String[] args) { int count = 0; for (long i = 1; i &lt;= 10000; i++) { int bits = (i + &quot;&quot;).length(); long cube = i * i * i; int mod = 1; while (bits &gt; 0) { mod *= 10; bits--; } if (cube % mod == i) { count++; } } System.out.println(count); }} 代码填空循环节长度两个整数做除法，有时会产生循环小数，其循环部分称为：循环节。比如，11/13=6=&gt;0.846153846153….. 其循环节为[846153] 共有6位。 下面的方法，可以求出循环节的长度。 请仔细阅读代码，并填写划线部分缺少的代码。 1234567891011121314public static int f(int n, int m) { n = n % m; Vector v = new Vector(); for (;;) { v.add(n); n *= 10; n = n % m; if (n == 0) return 0; // if(v.indexOf(n)&gt;=0) _________________________________ ; //填空 if (v.indexOf(n) &gt;= 0) return v.size(); }} 九数组分数1,2,3…9 这九个数字组成一个分数，其值恰好为1/3，如何组法？ 下面的程序实现了该功能，请填写划线部分缺失的代码。 12345678910111213141516171819202122232425262728293031public class Main { public static void test(int[] x) { int a = x[0] * 1000 + x[1] * 100 + x[2] * 10 + x[3]; int b = x[4] * 10000 + x[5] * 1000 + x[6] * 100 + x[7] * 10 + x[8]; if (a * 3 == b) System.out.println(a + &quot; &quot; + b); } public static void f(int[] x, int k) { if (k &gt;= x.length) { test(x); return; } for (int i = k; i &lt; x.length; i++) { { int t = x[k]; x[k] = x[i]; x[i] = t; } f(x, k + 1); // _______________________________________ // 填空 { int t = x[k]; x[k] = x[i]; x[i] = t; } // 交换 } } public static void main(String[] args) { int[] x = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; f(x, 0); }} 打印菱形给出菱形的边长，在控制台上打印出一个菱形来。为了便于比对空格，我们把空格用句点代替。当边长为8时，菱形为：…….*…….…..…….…..………...……….………..…………..………....……………….….…..…..……….…….* 下面的程序实现了这个功能，但想法有点奇怪。请仔细分析代码，并填写划线部分缺失的代码。 123456789101112131415161718192021222324public class Main { public static void f(int n) { String s = &quot;*&quot;; for (int i = 0; i &lt; 2 * n - 3; i++) s += &quot;.&quot;; s += &quot;*&quot;; String s1 = s + &quot;\\n&quot;; String s2 = &quot;&quot;; for (int i = 0; i &lt; n - 1; i++) { // System.out.println(&quot;=&gt;&quot; + s); // s = &quot;.&quot; + _____________________________________ + &quot;*&quot;; //填空 s = &quot;.&quot; + s.substring(0, 2 * (n - 2) - i) + &quot;*&quot;; s1 = s + &quot;\\n&quot; + s1; s2 += s + &quot;\\n&quot;; } System.out.println(s1 + s2); } public static void main(String[] args) { f(8); }} 程序设计饮料换购乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去，但不允许赊账。 请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的n瓶饮料，最后他一共能得到多少瓶饮料。 输入：一个整数n，表示开始购买的饮料数量（0&lt;n&lt;10000）输出：一个整数，表示实际得到的饮料数 样例输入1：100样例输出1：149 样例输入2：101样例输出2：151 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 123456789101112131415161718192021import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.close(); int sum = n; // n瓶饮料，n个瓶盖，可以换n/3瓶饮料 int nTrade = n / 3; // 换了后，剩余的饮料 int rest = n - nTrade * 3; // 换来的饮料和剩余饮料的瓶盖，又可以换n/3瓶饮料 int againTrade = (nTrade + rest) / 3; // 换了后，剩余的饮料 int againRest = (nTrade + rest) % 3; // 最后一次换来的饮料看看能不能最后一次换 int lastTrade = (againTrade + againRest) / 3; sum += nTrade + rest + againTrade + lastTrade; System.out.println(sum); }} 垒骰子赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。 atm想计算一下有多少种不同的可能的垒骰子方式。 两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。由于方案数可能过多，请输出模 10^9 + 7 的结果。 不要小看了 atm 的骰子数量哦～ 输入格式：第一行两个整数 n mn表示骰子数目接下来 m 行，每行两个整数 a b ，表示 a 和 b 不能紧贴在一起。 输出格式：一行一个数，表示答案模 10^9 + 7 的结果。 样例输入：2 11 2样例输出：544 数据范围：对于 30% 的数据：n &lt;= 5对于 60% 的数据：n &lt;= 100对于 100% 的数据：0 &lt; n &lt;= 10^9, m &lt;= 36 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 分析：矩阵快速幂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.BufferedInputStream;import java.math.BigInteger;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static BigInteger MOD = new BigInteger(&quot;1000000007&quot;); static int[] init = { -1, 4, 5, 6, 1, 2, 3 }; // 骰子对面 static boolean[][] conflict = new boolean[7][7]; // 冲突 public static void main(String[] args) { BigInteger n = new BigInteger(scanner.next()); int m = scanner.nextInt(); for (int i = 0; i &lt; m; i++) { int a = scanner.nextInt(); int b = scanner.nextInt(); conflict[a][b] = conflict[b][a] = true; } // dp[i][j]：i个骰子且最顶面是j的情况种数 // 使用了滚动dp，否则会超空间 BigInteger[][] dp = new BigInteger[2][7]; int e = 0; for (int i = 1; i &lt; 7; i++) dp[e][i] = BigInteger.ONE; for (BigInteger i = new BigInteger(&quot;2&quot;); n.compareTo(i) &gt;= 0; i = i.add(BigInteger.ONE)) { e = 1 - e; for (int j = 1; j &lt; 7; j++) { dp[e][j] = BigInteger.ZERO; for (int k = 1; k &lt; 7; k++) { if (!conflict[init[j]][k]) dp[e][j] = dp[e][j].add(dp[1 - e][k]).mod(MOD); System.out.println(&quot;dp[&quot; + e + &quot;][&quot; + j + &quot;]=&quot; + dp[e][j]); } } } System.out.println(&quot;e=&quot; + e); BigInteger sum = BigInteger.ZERO; for (int i = 1; i &lt; 7; i++) { sum = sum.add(dp[e][i]).mod(MOD); } System.out.println(&quot;sum = &quot; + sum); BigInteger four = new BigInteger(&quot;4&quot;); System.out.println(sum.multiply(four.modPow(n, MOD)).mod(MOD)); }} 生命之树在X森林里，上帝创建了生命之树。 他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。上帝要在这棵树内选出一个非空节点集S，使得对于S中的任意两个点a,b，都存在一个点列 {a, v1, v2, …, vk, b} 使得这个点列中的每个点都是S里面的元素，且序列中相邻两个点间有一条边相连。 在这个前提下，上帝要使得S中的点所对应的整数的和尽量大。这个最大的和就是上帝给生命之树的评分。 经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。 输入格式：第一行一个整数 n 表示这棵树有 n 个节点。第二行 n 个整数，依次表示每个节点的评分。接下来 n-1 行，每行 2 个整数 u, v，表示存在一条 u 到 v 的边。由于这是一棵树，所以是不存在环的。 输出格式：输出一行一个数，表示上帝给这棵树的分数。 样例输入：51 -2 -3 4 54 23 11 22 5 样例输出：8 数据范围：对于 30% 的数据，n &lt;= 10对于 100% 的数据，0 &lt; n &lt;= 10^5, 每个节点的评分的绝对值不超过 10^6 。 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 3000ms 分析：树型动态规划 这是一道纯粹的树型动态规划题, 图的结构采用邻接表实现, 整个问题最后化简为”从一棵树中选取一棵结点权值和最大的子树(后面称其为最优子树)”. 最优子树的存在形态只有两种: 包含原树的根结点 ( 直接最优子树 ). 这种情况下, 原树的直接最优子树必然等于根结点加上它的下属子树中总权非负的直接最优子树. 不包含原树的根结点 ( 间接最优子树 ). 这种情况下, 原树的间接最优子树必然是它的下属子树中的某一个具有最大权值的直接最优子树或间接最优子树( 谁大取谁 ). 如此一来, 状态转移方程就清晰了, 下面直接代码表示: 每个顶点均有[选/不选]两种情况： node[i].dp[0]:不选 node[i].dp[1]:选 状态转移方程：node[n].dp[1] += Math.max(node[t].dp[1], node[t].dp[0]); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.io.BufferedInputStream;import java.util.LinkedList;import java.util.List;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int n = scanner.nextInt(); static Node[] node = new Node[n + 1]; public static void main(String[] args) { for (int i = 1; i &lt;= n; i++) { // 存储节点的评分 node[i] = new Node(); node[i].score = scanner.nextInt(); } for (int i = 0; i &lt; n - 1; i++) { // 存储邻接点 int a = scanner.nextInt(); int b = scanner.nextInt(); node[a].adjacent.add(b); node[b].adjacent.add(a); } dfs(1); getScore(); } static void dfs(int n) { node[n].dp[1] = node[n].score; node[n].dp[0] = 0; node[n].isVisit = true; for (int i = 0; i &lt; node[n].adjacent.size(); i++) { int adjIndex = node[n].adjacent.get(i); if (!node[adjIndex].isVisit) { dfs(adjIndex); node[n].dp[1] += Math.max(node[adjIndex].dp[1], node[adjIndex].dp[0]); } else { node[n].dp[1] = Math.max(node[n].dp[1], node[n].score); node[n].dp[0] = Math.max(node[n].dp[0], 0); } } } static void getScore() { int score = -1; for (int i = 1; i &lt; node.length; i++) { score = Math.max(score, node[i].dp[1]); score = Math.max(score, node[i].dp[0]); } System.out.println(score); } static class Node { // 节点的评分 int score; // 是否被访问过 boolean isVisit; // 邻接点 List&lt;Integer&gt; adjacent = new LinkedList&lt;&gt;(); // 背包 int[] dp = new int[2]; }} 移动距离X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下： 1 2 3 4 5 612 11 10 9 8 713 14 15 ….. 我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动） 输入为3个整数w m n，空格分开，都在1到10000范围内w为排号宽度，m,n为待计算的楼号。要求输出一个整数，表示m n 两楼间最短移动距离。 用户输入：6 8 2输出：4 用户输入：4 7 20输出：5 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 灾后重建Pear市一共有N（&lt;=50000）个居民点，居民点之间有M（&lt;=200000）条双向道路相连。这些居民点两两之间都可以通过双向道路到达。这种情况一直持续到最近，一次严重的地震毁坏了全部M条道路。震后，Pear打算修复其中一些道路，修理第i条道路需要Pi的时间。不过，Pear并不打算让全部的点连通，而是选择一些标号特殊的点让他们连通。Pear有Q（&lt;=50000）次询问，每次询问，他会选择所有编号在[l,r]之间，并且 编号 mod K = C 的点，修理一些路使得它们连通。由于所有道路的修理可以同时开工，所以完成修理的时间取决于花费时间最长的一条路，即涉及到的道路中Pi的最大值。 你能帮助Pear计算出每次询问时需要花费的最少时间么？这里询问是独立的，也就是上一个询问里的修理计划并没有付诸行动。 【输入格式】第一行三个正整数N、M、Q，含义如题面所述。接下来M行，每行三个正整数Xi、Yi、Pi，表示一条连接Xi和Yi的双向道路，修复需要Pi的时间。可能有自环，可能有重边。1&lt;=Pi&lt;=1000000。 接下来Q行，每行四个正整数Li、Ri、Ki、Ci，表示这次询问的点是[Li,Ri]区间中所有编号Mod Ki=Ci的点。保证参与询问的点至少有两个。 【输出格式】输出Q行，每行一个正整数表示对应询问的答案。 【样例输入】7 10 41 3 102 6 94 1 53 7 43 6 91 5 82 7 43 2 101 7 67 6 91 7 1 01 7 3 12 5 1 03 7 2 1 【样例输出】9688 【数据范围】对于20%的数据，N,M,Q&lt;=30对于40%的数据，N,M,Q&lt;=2000对于100%的数据，N&lt;=50000,M&lt;=2*10^5,Q&lt;=50000. Pi&lt;=10^6. Li,Ri,Ki均在[1,N]范围内，Ci在[0,对应询问的Ki)范围内。 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 5000ms","link":"/2018/01/25/zh/programing/basis/algorithm/blue_bridge_cup/6th_province/"},{"title":"蓝桥杯2016年第7届Java-B组国赛","text":"愤怒小鸟X星球愤怒的小鸟喜欢撞火车！ 一根平直的铁轨上两火车间相距 1000 米两火车 （不妨称A和B） 以时速 10米/秒 相对行驶。 愤怒的小鸟从A车出发，时速50米/秒，撞向B车，然后返回去撞A车，再返回去撞B车，如此往复….两火车在相距1米处停车。 问：这期间愤怒的小鸟撞 B 车多少次？ 9 注意：需要提交的是一个整数（表示撞B车的次数），不要填写任何其它内容。 123456789101112131415161718192021public class Main { public static void main(String[] args) { int times = 0; int aSpeed = 10; int bSpeed = 10; int birdSpeed = 50; double currentLength = 1000; double spare = 0; for (int i = 0; currentLength &gt; 1; i++) { if ((i &amp; 1) == 0) { spare = currentLength / (birdSpeed + bSpeed); times++; } else { spare = currentLength / (birdSpeed + aSpeed); } currentLength -= bSpeed * spare + aSpeed * spare; //System.out.printf(&quot;%f %f\\n&quot;, spare, currentLength); } System.out.println(times); }} 反幻方我国古籍很早就记载着 2 9 47 5 36 1 8 这是一个三阶幻方。每行每列以及对角线上的数字相加都相等。 下面考虑一个相反的问题。可不可以用 1~9 的数字填入九宫格。使得：每行每列每个对角线上的数字和都互不相等呢？ 比如：9 1 28 4 37 5 6 你的任务是搜索所有的三阶反幻方。并统计出一共有多少种。旋转或镜像算同一种。 比如：9 1 28 4 37 5 6 7 8 95 4 16 3 2 2 1 93 4 86 5 7 等都算作同一种情况。 请提交三阶反幻方一共多少种。 3120 这是一个整数，不要填写任何多余内容。 回溯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Main { static int[] fang = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; static int times = 0; public static void main(String[] args) { backTrack(0); System.out.println(times / 8); } private static void backTrack(int current) { if (current == fang.length - 1) { if (isOK()) { times++; //outPut(); } } else { for (int i = current; i &lt; fang.length; i++) { swap(current, i); backTrack(current + 1); swap(current, i); } } } private static boolean isOK() { int line1 = fang[0] + fang[1] + fang[2]; int line2 = fang[3] + fang[4] + fang[5]; int line3 = fang[6] + fang[7] + fang[8]; int column1 = fang[0] + fang[3] + fang[6]; int column2 = fang[1] + fang[4] + fang[7]; int column3 = fang[2] + fang[5] + fang[8]; int a = fang[0] + fang[4] + fang[8]; int b = fang[2] + fang[4] + fang[6]; if (line1 == line2 || line1 == line3 || line2 == line3 || line1 == column1 || line1 == column2 || line1 == column3 || line2 == column1 || line2 == column2 || line2 == column3 || line3 == column1 || line3 == column2 || line3 == column3 || line1 == a || line1 == b || line2 == a || line2 == b || line3 == a || line3 == b || a == b || column1 == column2 || column2 == column3 || column1 == column3 || column1 == a || column2 == a || column3 == a || column1 == b || column2 == b || column3 == b) { return false; } return true; } private static void swap(int i, int j) { int tmp = fang[i]; fang[i] = fang[j]; fang[j] = tmp; } private static void outPut() { for (int i = 0; i &lt; fang.length; i++) { out.printf(&quot;%d &quot;, fang[i]); if (i == 2 || i == 5 || i == 8) { System.out.println(); } if (i == 8) { System.out.println(); } } }} 打靶小明参加X星球的打靶比赛。比赛使用电子感应计分系统。其中有一局，小明得了96分。 这局小明共打了6发子弹，没有脱靶。但望远镜看过去，只有3个弹孔。显然，有些子弹准确地穿过了前边的弹孔。 不同环数得分是这样设置的：1,2,3,5,10,20,25,50 那么小明的6发子弹得分都是多少呢？有哪些可能情况呢？ 下面的程序解决了这个问题。仔细阅读分析代码，填写划线部分缺失的内容。 1234567891011121314151617181920212223242526272829303132333435public class Main { static void f(int[] ta, int[] da, int k, int ho, int bu, int sc) { if (ho &lt; 0 || bu &lt; 0 || sc &lt; 0) return; if (k == ta.length) { if (ho &gt; 0 || bu &gt; 0 || sc &gt; 0) return; for (int i = 0; i &lt; da.length; i++) { for (int j = 0; j &lt; da[i]; j++) System.out.print(ta[i] + &quot; &quot;); } System.out.println(); return; } for (int i = 0; i &lt;= bu; i++) { da[k] = i; // 填空位置4 // ho初始值为3，所以应该是对应题目的只有3个洞 // 那么打中的话就要减少相应的洞数 // da[k]应该是累计打中哪些环，但洞数只能是1个个减少 // 所以ho - da[k] / da[k] // 但如果da[k] = 0，分母可能会出错，所以与1比较 f(ta, da, k + 1, ho - da[k] / Math.max(da[k], 1), bu - i, sc - ta[k] * i); } da[k] = 0; } public static void main(String[] args) { int[] ta = { 1, 2, 3, 5, 10, 20, 25, 50 }; int[] da = new int[8]; f(ta, da, 0, 3, 6, 96); }} 路径之谜小明冒充X星球的骑士，进入了一个奇怪的城堡。城堡里边什么都没有，只有方形石头铺成的地面。 假设城堡地面是 n x n 个方格。 按习俗，骑士要从西北角走到东南角。可以横向或纵向移动，但不能斜着走，也不能跳跃。每走到一个新方格，就要向正北方和正西方各射一箭。（城堡的西墙和北墙内各有 n 个靶子） 同一个方格只允许经过一次。但不必做完所有的方格。 如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？ 有时是可以的，比如图中的例子。 本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一） 输入：第一行一个整数n(0&lt;n&lt;20)，表示地面有 n x n 个方格第二行n个整数，空格分开，表示北边的箭靶上的数字（自西向东）第三行n个整数，空格分开，表示西边的箭靶上的数字（自北向南） 输出：一行若干个整数，表示骑士路径。 为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号: 0,1,2,3….比如，图中的方块编号为： 0 1 2 34 5 6 78 9 10 1112 13 14 15 样例输入：42 4 3 44 3 3 3 样例输出：0 4 5 1 2 3 7 11 10 9 13 14 15 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.Scanner;public class Main { private static int N; // x为0时，y可以为1或-1，即上下；同理得左右方向 private static int[][] direction = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } }; // 二维数组时的一维数组下标 private static int[][] oneArray; private static int totalNorth = 0;// 北边靶子的总数目 private static int totalWest = 0;// 西边靶子的总数目 private static int[] restNorth;// 保存北边靶子上的数目 private static int[] restWest; // 保存西边靶子的数目 private static int[][] visit; // 标记数组，标记迷宫的方格是否走过 private static int[] way = null; // 满足要求的行走路径 private static int wayLength = 1; // 可行路径的长度 public static void main(String[] args) { Scanner scanner = new Scanner(System.in); N = scanner.nextInt(); way = new int[N * N + 1]; visit = new int[N][N]; oneArray = new int[N][N]; for (int i = 0, index = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) oneArray[i][j] = index++; restNorth = new int[N]; for (int i = 0; i &lt; N; i++) { restNorth[i] = scanner.nextInt(); totalNorth += restNorth[i]; } restWest = new int[N]; for (int i = 0; i &lt; N; i++) { restWest[i] = scanner.nextInt(); totalWest += restWest[i]; } scanner.close(); firstStep(); backTrack(0, 0); } private static void firstStep() { restNorth[0]--; totalNorth--; restWest[0]--; totalWest--; visit[0][0] = 1; way[0] = 0; } private static void getResult() { for (int i = 0; i &lt; wayLength; i++) System.out.print(way[i] + &quot; &quot;); } public static void backTrack(int x, int y) { if (x == N - 1 &amp;&amp; y == N - 1) { if (totalNorth == 0 &amp;&amp; totalWest == 0) { getResult(); } } else { for (int i = 0; i &lt; 4; i++) { int dx = x + direction[i][0]; int dy = y + direction[i][1]; // 1.没出界，2.行列上的靶子数目至少为1 if (dx &gt;= 0 &amp;&amp; dx &lt; N &amp;&amp; dy &gt;= 0 &amp;&amp; dy &lt; N &amp;&amp; visit[dx][dy] == 0 &amp;&amp; restNorth[dy] &gt; 0 &amp;&amp; restWest[dx] &gt; 0) { visit[dx][dy] = 1; // 每走一步，北边和西边的靶子就被射一箭 restNorth[dy]--; totalNorth--; restWest[dx]--; totalWest--; way[wayLength++] = oneArray[dx][dy]; backTrack(dx, dy); wayLength--; // 走不通，路径长度-1 visit[dx][dy] = 0; restNorth[dy]++; totalNorth++; restWest[dx]++; totalWest++; } } } }} 碱基生物学家正在对n个物种进行研究。其中第i个物种的DNA序列为s[i]，其中的第j个碱基为s[i][j]，碱基一定是A、T、G、C之一。生物学家想找到这些生物中一部分生物的一些共性，他们现在关注那些至少在m个生物中出现的长度为k的连续碱基序列。准确的说，科学家关心的序列用2m元组(i1,p1,i2,p2….im,pm)表示，满足：1 &lt;= i1 &lt; i2 &lt; …. &lt; im &lt;= n;且对于所有q(0 &lt;= q &lt; k), s[i1][p1+q] = s[i2][p2+q] = …. = s[im][pm+q]。 现在给定所有生物的DNA序列，请告诉科学家有多少的2m元组是需要关注的。如果两个2m元组有任何一个位置不同，则认为是不同的元组。 输入格式：输入的第一行包含三个整数n、m、k，两个整数之间用一个空格分隔，意义如题目所述。接下来n行，每行一个字符串表示一种生物的DNA序列。DNA序列从1至n编号，每个序列中的碱基从1开始依次编号，不同的生物的DNA序列长度可能不同。 输出格式：输出一个整数，表示关注的元组个数。答案可能很大，你需要输出答案除以1000000007的余数。 样例输入1：3 2 2ATCTCGACG 样例输出1：2 样例输入2：4 3 3AAAAAAAAAAAAA 样例输出2：7 数据规模与约定：对于20%的数据，k&lt;=5,所有字符串总长L满足L &lt;=100对于30%的数据，L&lt;=10000对于60%的数据，L&lt;=30000对于100%的数据，n&lt;=5,m&lt;=5,1&lt;=k&lt;=L&lt;=100000保证所有DNA序列不为空且只会包含’A’ ’G’ ’C’ ’T’四种字母 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms 1","link":"/2018/01/22/zh/programing/basis/algorithm/blue_bridge_cup/7th_country/"},{"title":"蓝桥杯2016年第7届省赛","text":"结果填空煤球数目有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），….如果一共有100层，共有多少个煤球？ 171700 1234567891011public class Main { public static void main(String[] args) { int a = 1; int sum = a; for (int i = 2; i &lt;= 100; i++) { a += i; sum += a; } System.out.println(sum); }} 生日蜡烛某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。 现在算起来，他一共吹熄了236根蜡烛。 请问，他从多少岁开始过生日party的？ 26 1234567891011121314151617public class Main { public static void main(String[] args) { int start = 1; int end = 2; while (true) { int sum = (start + end) * (end - start + 1) / 2; if (sum &lt; 236) { end++; } else if (sum &gt; 236) { start++; } else { System.out.println(start); break; } } }} 凑算式 这个算式中AI代表19的数字，不同的字母代表不同的数字。 比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。 这个算式一共有多少种解法？ 29 回溯1234567891011121314151617181920212223242526272829303132333435363738public class Main { static int solution = 0; static int[] number = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; public static void main(String[] args) { backTrack(0); System.out.println(solution); } static void backTrack(int depth) { if (depth == 9) { if (isOK()) { solution++; } } else { for (int i = depth; i &lt; 9; i++) { swap(number, depth, i); backTrack(depth + 1); swap(number, depth, i); } } } static boolean isOK() { int A = number[0]; int B = number[1]; int C = number[2]; int DEF = number[3] * 100 + number[4] * 10 + number[5]; int GHI = number[6] * 100 + number[7] * 10 + number[8]; return GHI * B + DEF * C == (10 - A) * C * GHI; } static void swap(int[] array, int i, int j) { int tmp = array[i]; array[i] = array[j]; array[j] = tmp; }} 网友年龄某君新认识一网友。当问及年龄时，他的网友说：“我的年龄是个2位数，我比儿子大27岁,如果把我的年龄的两位数字交换位置，刚好就是我儿子的年龄” 请你计算：网友的年龄一共有多少种可能情况？ 7 提示：30岁就是其中一种可能哦. 暴力12345678910111213141516public class Main { public static void main(String[] args) { int maybe = 0; for (int mom = 28; mom &lt;= 99; mom++) { for (int son = 1; son &lt;= mom - 27; son++) { int a = mom / 10; int b = mom % 10; int c = b * 10 + a; if (c == son &amp;&amp; mom - 27 == son) { maybe++; } } } System.out.println(maybe); }} 平方怪圈如果把一个正整数的每一位都平方后再求和，得到一个新的正整数。对新产生的正整数再做同样的处理。 如此一来，你会发现，不管开始取的是什么数字，最终如果不是落入1，就是落入同一个循环圈。 请写出这个循环圈中最大的那个数字。 145 123456789101112131415161718192021222324252627import java.util.HashMap;import java.util.Map;public class Main { public static void main(String[] args) { Map&lt;Integer, Boolean&gt; isPut = new HashMap&lt;&gt;(); int a = 2; int sum = 0; while (true) { while (a != 0) { sum += Math.pow(a % 10, 2); a /= 10; } a = sum; sum = 0; // 落入循环即以前已经添加过 if (isPut.get(a) != null) { for (Integer i : isPut.keySet()) { System.out.print(i + &quot; &quot;); } break; } else { isPut.put(a, true); } } }} 搭积木小明最近喜欢搭数字积木，一共有10块积木，每个积木上有一个数字，0~9。 搭积木规则：每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。最后搭成4层的金字塔形，必须用完所有的积木。 下面是两种合格的搭法： 123456789 0 1 2 3 4 56 7 8 9 0 3 1 7 5 29 8 6 4 请你计算这样的搭法一共有多少种？ 768 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Main { static int[] number = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; static int count = 0; public static void main(String[] args) { backTrack(0); System.out.println(count); } static void backTrack(int n) { if (n == 10) { count++; } else { for (int i = n; i &lt; 10; i++) { swap(n, i); if (isOK(n)) { backTrack(n + 1); } swap(n, i); } } } static void swap(int i, int j) { int tmp = number[i]; number[i] = number[j]; number[j] = tmp; } static boolean isOK(int n) { switch (n) { case 1: return number[0] &lt; number[1]; case 2: return number[0] &lt; number[2]; case 3: return number[1] &lt; number[3]; case 4: return number[1] &lt; number[4] &amp;&amp; number[2] &lt; number[4]; case 5: return number[2] &lt; number[5]; case 6: return number[3] &lt; number[6]; case 7: return number[3] &lt; number[7] &amp;&amp; number[4] &lt; number[7]; case 8: return number[4] &lt; number[8] &amp;&amp; number[5] &lt; number[8]; case 9: return number[5] &lt; number[9]; default: return true; } }} 方格填数如下的10个格子 填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻） 一共有多少种可能的填数方案？ 1580 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Main { static int solution = 0; static int number[] = new int[10]; static int map[][] = new int[3][4]; public static void main(String args[]) { for (int x = 0; x &lt; 3; x++) { for (int y = 0; y &lt; 4; y++) { // 初始化数据，（除了-1到10之间）的数都可行，这里初始化为-2 map[x][y] = -2; } } backTrack(0, 1); System.out.println(solution); } static void backTrack(int x, int y) { if (x == 2 &amp;&amp; y == 3) { solution++; } else { // 将0到9都填入该方格 for (int num = 0; num &lt;= 9; num++) { if (number[num] == 1 || isContinuous(num, x, y)) { continue; } map[x][y] = num; number[num] = 1; backTrack(x + (y + 1) / 4, (y + 1) % 4); map[x][y] = -2; number[num] = 0; } } } // 判断相邻格子的数字是否连续 static boolean isContinuous(int num, int x, int y) { // 上方 if (x &gt;= 1 &amp;&amp; Math.abs(map[x - 1][y] - num) == 1) { return true; } // 左方 if (y &gt;= 1 &amp;&amp; Math.abs(map[x][y - 1] - num) == 1) { return true; } // 左上方 if (x &gt;= 1 &amp;&amp; y &gt;= 1 &amp;&amp; Math.abs(map[x - 1][y - 1] - num) == 1) { return true; } // 右上方 if (x &gt;= 1 &amp;&amp; y &lt; 3 &amp;&amp; Math.abs(map[x - 1][y + 1] - num) == 1) { return true; } // 右方 if (y &lt; 3 &amp;&amp; Math.abs(map[x][y + 1] - num) == 1) { return true; } // 下方 if (x &lt; 2 &amp;&amp; Math.abs(map[x + 1][y] - num) == 1) { return true; } // 左下方 if (x &lt; 2 &amp;&amp; y &gt;= 1 &amp;&amp; Math.abs(map[x + 1][y - 1] - num) == 1) { return true; } // 右下方 if (x &lt; 1 &amp;&amp; y &lt; 3 &amp;&amp; Math.abs(map[x + 1][y + 1] - num) == 1) { return true; } return false; }} 剪邮票如图，有12张连在一起的12生肖的邮票。 现在你要从中剪下5张来，要求必须是连着的。（仅仅连接一个角不算相连） 如图2，图3中，粉红色所示部分就是合格的剪取。 请你计算，一共有多少种不同的剪取方法？ 116 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Main { static int solution = 0; static int[] number = new int[5]; static int[] isChosen = new int[12]; public static void main(String args[]) { // 从12个数字里选5个数字 backTrack(0); System.out.println(solution); } static void backTrack(int n) { // 去重 if (n &gt; 1 &amp;&amp; number[n - 1] &lt; number[n - 2]) { return; } if (n == 5) { if (isOK()) { // printNumber(); solution++; } } else { for (int i = 0; i &lt; 12; i++) { if (isChosen[i] == 0) { isChosen[i] = 1; number[n] = i; backTrack(n + 1); isChosen[i] = 0; } } } } static boolean isOK() { boolean[] isVisit = new boolean[5]; dfs(isVisit, 0); return isVisit[0] &amp;&amp; isVisit[1] &amp;&amp; isVisit[2] &amp;&amp; isVisit[3] &amp;&amp; isVisit[4]; } static void dfs(boolean isVisit[], int i) { isVisit[i] = true; for (int j = 0; j &lt; isVisit.length; j++) { if (!isVisit[j]) { if (number[i] / 4 == number[j] / 4 &amp;&amp; Math.abs(number[i] - number[j]) == 1) { dfs(isVisit, j); } if (Math.abs(number[i] - number[j]) == 4) { dfs(isVisit, j); } } } } static void printNumber() { for (int i : number) { System.out.print(i + &quot; &quot;); } System.out.println(); }} 寒假作业现在小学的数学题目也不是那么好玩的。看看这个寒假作业： □ + □ = □□ - □ = □□ × □ = □□ ÷ □ = □ 每个方块代表1~13中的某一个数字，但不能重复。比如：6 + 7 = 139 - 8 = 13 * 4 = 1210 / 2 = 5 以及：7 + 6 = 139 - 8 = 13 * 4 = 1210 / 2 = 5 就算两种解法。（加法，乘法交换律后算不同的方案） 你一共找到了多少种方案？ 64 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Main { static int[] number = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }; static int count = 0; public static void main(String[] args) { backTrack(0); System.out.println(count); } static void backTrack(int n) { if (n == 13) { System.out.println(number[0] + &quot;+&quot; + number[1] + &quot;=&quot; + number[2]); System.out.println(number[3] + &quot;-&quot; + number[4] + &quot;=&quot; + number[5]); System.out.println(number[6] + &quot;*&quot; + number[7] + &quot;=&quot; + number[8]); System.out.println(number[9] + &quot;/&quot; + number[10] + &quot;=&quot; + number[11]); System.out.println(number[9] + &quot;/&quot; + number[10] + &quot;=&quot; + number[12]); System.out.println(); count++; } else { for (int i = n; i &lt; 13; i++) { swap(n, i); if (isOK(n)) { backTrack(n + 1); } swap(n, i); } } } static void swap(int i, int j) { int tmp = number[i]; number[i] = number[j]; number[j] = tmp; } static boolean isOK(int n) { switch (n) { case 2: return number[0] + number[1] == number[2]; case 5: return number[3] - number[4] == number[5]; case 8: return number[6] * number[7] == number[8]; case 11: return number[11] * number[12] == number[10]; default: return true; } }} 代码填空分小组9名运动员参加比赛，需要分3组进行预赛。有哪些分组的方案呢？ 我们标记运动员为 A,B,C,… I下面的程序列出了所有的分组方法。 该程序的正常输出为：ABC DEF GHIABC DEG FHIABC DEH FGIABC DEI FGHABC DFG EHIABC DFH EGIABC DFI EGHABC DGH EFIABC DGI EFHABC DHI EFGABC EFG DHIABC EFH DGIABC EFI DGHABC EGH DFIABC EGI DFHABC EHI DFGABC FGH DEIABC FGI DEHABC FHI DEGABC GHI DEFABD CEF GHIABD CEG FHIABD CEH FGIABD CEI FGHABD CFG EHIABD CFH EGIABD CFI EGHABD CGH EFIABD CGI EFHABD CHI EFGABD EFG CHI….. (以下省略，总共560行)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Main { public static String remain(int[] a) { String s = &quot;&quot;; for (int i = 0; i &lt; a.length; i++) { if (a[i] == 0) s += (char) (i + 'A'); } return s; } public static void f(String s, int[] a) { for (int i = 0; i &lt; a.length; i++) { if (a[i] == 1) continue; a[i] = 1; for (int j = i + 1; j &lt; a.length; j++) { if (a[j] == 1) continue; a[j] = 1; for (int k = j + 1; k &lt; a.length; k++) { if (a[k] == 1) continue; a[k] = 1; // System.out.println(_____________); //填空 System.out.println(s + &quot; &quot; + (char) (i + 'A') + (char) (j + 'A') + (char) (k + 'A') + &quot; &quot; + remain(a)); a[k] = 0; } a[j] = 0; } a[i] = 0; } } public static void main(String[] args) { int[] a = new int[9]; a[0] = 1; for (int b = 1; b &lt; a.length; b++) { a[b] = 1; for (int c = b + 1; c &lt; a.length; c++) { a[c] = 1; String s = &quot;A&quot; + (char) (b + 'A') + (char) (c + 'A'); f(s, a); a[c] = 0; } a[b] = 0; } }} 抽签X星球要派出一个5人组成的观察团前往W星。其中：A国最多可以派出4人。B国最多可以派出2人。C国最多可以派出2人。…. 那么最终派往W星的观察团会有多少种国别的不同组合呢？ 下面的程序解决了这个问题。数组a[]中是每个国家可以派出的最多的名额。程序执行结果为：DEFFFCEFFFCDFFFCDEFFCCFFFCCEFFCCDFFCCDEFBEFFFBDFFFBDEFFBCFFFBCEFFBCDFFBCDEF….(以下省略，总共101行) 12345678910111213141516171819202122232425public class Main { public static void f(int[] a, int k, int n, String s) { if (k == a.length) { if (n == 0) System.out.println(s); return; } String s2 = s; for (int i = 0; i &lt;= a[k]; i++) { // _____________________________; //填空位置 // a：各个国家能派的人数 // k：第几个国家 // n：还需要派几个人 // s2：当前派遣队伍 f(a, k + 1, n - i, s2); s2 += (char) (k + 'A'); } } public static void main(String[] args) { int[] a = { 4, 2, 2, 1, 1, 3 }; f(a, 0, 5, &quot;&quot;); }} 消除尾一下面的代码把一个整数的二进制表示的最右边的连续的1全部变成0如果最后一位是0，则原数字保持不变。 如果采用代码中的测试数据，应该输出：00000000000000000000000001100111 0000000000000000000000000110000000000000000000000000000000001100 00000000000000000000000000001100 请仔细阅读程序，填写划线部分缺少的代码。 1234567891011121314151617181920public class Main { public static void main(String[] args) { f(103); f(12); } private static void f(int x) { int i; for (i = 0; i &lt; 32; i++) System.out.print(x &gt;&gt; (31 - i) &amp; 1); System.out.print(&quot; &quot;); // x = _______________________; // 填空 x = x &amp; (x + 1); for (i = 0; i &lt; 32; i++) System.out.print(x &gt;&gt; (31 - i) &amp; 1); System.out.println(); }} 快速排序排序在各种场合经常被用到。快速排序是十分常用的高效率的算法。 其思想是：先选一个“标尺”，用它把整个队列过一遍筛子，以保证：其左边的元素都不大于它，其右边的元素都不小于它。 这样，排序问题就被分割为两个子区间。再分别对子区间排序就可以了。 下面的代码是一种实现，请分析并填写划线部分缺少的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main { public static void main(String[] args) { int i; int a[] = { 5, 13, 6, 24, 2, 8, 19, 27, 6, 12, 1, 17 }; int N = 12; quicksort(a, 0, N - 1); for (i = 0; i &lt; N; i++) System.out.print(a[i] + &quot; &quot;); System.out.println(); } private static int partition(int[] a, int p, int r) { int i = p; int j = r + 1; int x = a[p]; while (true) { while (i &lt; r &amp;&amp; a[++i] &lt; x) ; while (a[--j] &gt; x) ; if (i &gt;= j) break; swap(a, i, j); } // ______________________; // 填空 swap(a, p, j); return j; } private static void quicksort(int[] a, int p, int r) { if (p &lt; r) { int q = partition(a, p, r); quicksort(a, p, q - 1); quicksort(a, q + 1, r); } } private static void swap(int[] a, int i, int j) { int tmp = a[i]; a[i] = a[j]; a[j] = tmp; }} 骰子游戏我们来玩一个游戏。同时掷出3个普通骰子（6个面上的数字分别是1~6）。如果其中一个骰子上的数字等于另外两个的和，你就赢了。 下面的程序计算出你能获胜的精确概率（以既约分数表示） 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { int n = 0; for (int i = 0; i &lt; 6; i++) for (int j = 0; j &lt; 6; j++) for (int k = 0; k &lt; 6; k++) { // if(________________________________) n++; //填空位置 if ((i + 1) + (j + 1) == (k + 1) || (i + 1) + (k + 1) == (j + 1) || (j + 1) + (k + 1) == (i + 1)) n++; } int m = gcd(n, 6 * 6 * 6); System.out.println(n / m + &quot;/&quot; + 6 * 6 * 6 / m); } public static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 程序设计四平方和四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。 比如：5 = 0^2 + 0^2 + 1^2 + 2^27 = 1^2 + 1^2 + 1^2 + 2^2（^符号表示乘方的意思） 对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法 程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开 样例输入1：5样例输出1：0 0 1 2 样例输入2：12样例输出2：0 2 2 2 样例输入3：773535样例输出4：1 1 267 838 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 3000ms 暴力12345678910111213141516171819202122import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); public static void main(String args[]) { int n = scanner.nextInt(); for (int a = 0; a &lt; Math.sqrt(n); a++) { for (int b = a; b &lt; Math.sqrt(n); b++) { for (int c = b; c &lt; Math.sqrt(n); c++) { for (int d = c; d &lt; Math.sqrt(n); d++) { if (a * a + b * b + c * c + d * d == n) { System.out.printf(&quot;%d %d %d %d&quot;, a, b, c, d); return; } } } } } }} 取球博弈两个人玩取球的游戏，一共有N个球，每人轮流取球，每次可取集合{n1,n2,n3}中的任何一个数目，如果无法继续取球，则游戏结束。此时，持有奇数个球的一方获胜。如果两人都是奇数，则为平局。 假设双方都采用最聪明的取法，第一个取球的人一定能赢吗？ 输入格式：第一行3个正整数n1 n2 n3，空格分开，表示每次可取的数目 (0&lt;n1,n2,n3&lt;100)第二行5个正整数x1 x2 … x5，空格分开，表示5局的初始球数(0&lt;xi&lt;1000) 输出格式：一行5个字符，空格分开。分别表示每局先取球的人能否获胜。能获胜则输出+次之，如有办法逼平对手，输出0无论如何都会输，则输出- 样例输入1：1 2 31 2 3 4 5 输出： 0 + 0 - 样例输入2：1 4 510 11 12 13 15 输出：0 - 0 + + 样例输入3：2 3 57 8 9 10 11 输出： 0 0 0 0 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 3000ms 分析： 最聪明做法：在保证持有奇数的球情况下，尽量取最大的偶数球。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int[] ball = new int[3]; static int[] init = new int[5]; static String result = &quot;&quot;; public static void main(String args[]) { for (int i = 0; i &lt; 3; i++) { ball[i] = scanner.nextInt(); } for (int i = 0; i &lt; 5; i++) { init[i] = scanner.nextInt(); } play(); System.out.println(result.toString()); } // 还可以取的球数 static int rest = 0; static int first = 0, second = 0; static void play() { for (int i = 0; i &lt; 5; i++, first = 0, second = 0) { rest = init[i]; while (rest &gt; 0) { first += afterPick(first); second += afterPick(second); } judge(); } } static int afterPick(int self) { int pick = -1; // 奇 + 奇 = 偶 // 偶 + 偶 = 偶 // 持有奇数个球 if ((self &amp; 1) == 1) { // 找到最大偶数，保证取到后仍是最大奇数 for (int i = 2; i &gt;= 0; i--) { if ((ball[i] &amp; 1) == 0) { if (rest &gt;= ball[i]) { rest -= ball[i]; pick = ball[i]; break; } } } } else { // 找到最大奇数 for (int i = 2; i &gt;= 0; i--) { if ((ball[i] &amp; 1) == 1) { if (rest &gt;= ball[i]) { rest -= ball[i]; pick = ball[i]; break; } } } } // 找不到 if (pick == -1) { for (int i = 2; i &gt;= 0; i--) { if (rest &gt;= ball[i]) { rest -= ball[i]; pick = ball[i]; break; } // 如果到最小球还没找到，即剩余的比最小球还小 // 一般来说到了最后一个，默认两者都不取球 if (i == 0 &amp;&amp; pick == -1) { rest = 0; pick = 0; } } } return pick; } static void judge() { if ((first &amp; 1) == 1) { if ((second &amp; 1) == 1) { result += &quot;0&quot;; } else { result += &quot;+&quot;; } } else { if ((second &amp; 1) == 0) { result += &quot;0&quot;; } else { result += &quot;-&quot;; } } result += &quot; &quot;; }} 压缩变换小明最近在研究压缩算法。他知道，压缩的时候如果能够使得数值很小，就能通过熵编码得到较高的压缩比。然而，要使数值很小是一个挑战。 最近，小明需要压缩一些正整数的序列，这些序列的特点是，后面出现的数字很大可能是刚出现过不久的数字。对于这种特殊的序列，小明准备对序列做一个变换来减小数字的值。 变换的过程如下：从左到右枚举序列，每枚举到一个数字，如果这个数字没有出现过，刚将数字变换成它的相反数，如果数字出现过，则看它在原序列中最后的一次出现后面（且在当前数前面）出现了几种数字，用这个种类数替换原来的数字。 比如，序列(a1, a2, a3, a4, a5)=(1, 2, 2, 1, 2)在变换过程为：a1: 1未出现过，所以a1变为-1；a2: 2未出现过，所以a2变为-2；a3: 2出现过，最后一次为原序列的a2，在a2后、a3前有0种数字，所以a3变为0；a4: 1出现过，最后一次为原序列的a1，在a1后、a4前有1种数字，所以a4变为1；a5: 2出现过，最后一次为原序列的a3，在a3后、a5前有1种数字，所以a5变为1。现在，给出原序列，请问，按这种变换规则变换后的序列是什么。 输入格式：输入第一行包含一个整数n，表示序列的长度。第二行包含n个正整数，表示输入序列。 输出格式：输出一行，包含n个数，表示变换后的序列。 样例输入1：51 2 2 1 2 样例输出1：-1 -2 0 1 1 样例输入2：121 1 2 3 2 3 1 2 2 2 3 1 样例输出2：-1 0 -2 -3 1 1 2 2 0 0 2 2 数据规模与约定：对于30%的数据，n&lt;=1000；对于50%的数据，n&lt;=30000；对于100%的数据，1 &lt;=n&lt;=100000，1&lt;=ai&lt;=10^9 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 3000ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.HashMap;import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int n = scanner.nextInt(); static int[] sequence = new int[n]; static int[] newSequence = new int[n]; public static void main(String args[]) { for (int i = 0; i &lt; n; i++) { sequence[i] = scanner.nextInt(); } // 字典 // key：序列数字 // value：从前一次出现到当前出现间，不同的数字 HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; type = new HashMap&lt;&gt;(); for (int i = 0, k = 0; i &lt; n; i++) { // 不同的数字，hash函数最后的size-1就是不同的数字个数 // 之所以是size-1是因为这里还保存了序列数字本身前一次出现的位置 HashMap&lt;Integer, Integer&gt; iType = type.get(sequence[i]); if (iType == null) { newSequence[i] = -sequence[i]; iType = new HashMap&lt;&gt;(); // 保存本身的位置i iType.put(sequence[i], i); type.put(sequence[i], iType); } else { newSequence[i] = iType.size() - 1; // 前面出现数字的更新位置后退1，这个走的速度慢 k = iType.get(sequence[i]) + 1; // 清除不同数字 iType.clear(); // 更新当前的位置i iType.put(sequence[i], i); } // 从第2个开始，前面出现的都要进行统计 if (i != 0) { for (int j = k; j &lt; i; j++) { HashMap&lt;Integer, Integer&gt; frontType = type.get(sequence[j]); frontType.put(sequence[i], i); } } } for (int i = 0; i &lt; n; i++) { System.out.print(newSequence[i] + &quot; &quot;); } }} 密码脱落X星球的考古学家发现了一批古代留下来的密码。这些密码是由A、B、C、D 四种植物的种子串成的序列。仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。 你的任务是：给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。 输入一行，表示现在看到的密码串（长度不大于1000）要求输出一个正整数，表示至少脱落了多少个种子。 样例1输入：ABCBA 输出：0 样例2输入：ABDCDCBABC 输出：3 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms 分析：贪心， 1 最大比例X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数，并且相邻的两个级别间的比例是个固定值。也就是说：所有级别的奖金数构成了一个等比数列。比如：16, 24, 36, 54其等比值为：3/2 现在，我们随机调查了一些获奖者的奖金数。请你据此推算可能的最大的等比值。 输入格式：第一行为数字 N (0&lt;N&lt;100)，表示接下的一行包含N个正整数第二行N个正整数Xi(Xi&lt;1 000 000 000 000)，用空格分开。每个整数表示调查到的某人的奖金数额 要求输出：一个形如A/B的分数，要求A、B互质。表示可能的最大比例系数 测试数据保证了输入格式正确，并且最大比例是存在的。 例如，输入：31250 200 32 程序应该输出：25/4 再例如，输入：43125 32 32 200 程序应该输出：5/2 再例如，输入：3549755813888 524288 2 程序应该输出：4/1 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms 1 交换瓶子有N个瓶子，编号 1 ~ N，放在架子上。 比如有5个瓶子：2 1 3 5 4 要求每次拿起2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：1 2 3 4 5 对于这么简单的情况，显然，至少需要交换2次就可以复位。 如果瓶子更多呢？你可以通过编程来解决。 输入格式为两行：第一行: 一个正整数N（N&lt;10000）, 表示瓶子的数目第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。 输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。 样例1输入：53 1 2 5 4 输出：3 样例2输入：55 4 3 2 1 输出：2 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 分析：从1下标开始遍历，如果下标和值不一致就交换，直到一致，然后继续遍历。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); in.nextToken(); int n = (int) in.nval; int[] array = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { in.nextToken(); array[i] = (int) in.nval; } int count = 0; for (int i = 1; i &lt;= n; i++) { while (array[i] != i) { swap(array, i, array[i]); count++; } } out.println(count); out.flush(); } static void swap(int[] array, int i, int j) { int tmp = array[i]; array[i] = array[j]; array[j] = tmp; }} 冰雹数任意给定一个正整数N，如果是偶数，执行： N / 2如果是奇数，执行： N * 3 + 1 生成的新的数字再执行同样的动作，循环往复。 通过观察发现，这个数字会一会儿上升到很高，一会儿又降落下来。就这样起起落落的，但最终必会落到“1”这有点像小冰雹粒子在冰雹云中翻滚增长的样子。 比如N=99,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1可以看到，N=9的时候，这个“小冰雹”最高冲到了52这个高度。 输入格式：一个正整数N（N&lt;1000000）输出格式：一个正整数，表示不大于N的数字，经过冰雹数变换过程中，最高冲到了多少。 样例1输入：10 输出：52 样例2输入：100 输出：9232 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms 分析：最简单做法就是每次都计算，但是n比较大时，可能会超时。既然知道了范围，可以通过本地打表，将所有最大值和对应的n保存起来，这样查询的时间复杂度为1。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;import java.util.HashMap;import java.util.Map;public class Main { static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); public static void main(String[] args) throws IOException { StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); in.nextToken(); long n = (long) in.nval; // 打表 getAll(); /* long min = Long.MAX_VALUE; for (long key : map.keySet()) { if (key &gt; n) { min = Math.min(map.get(key), min); } } out.println(min); out.flush(); */ } static void getAll() { long n = 1000000; long max = 1; // key最大值 // value下标 Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for (long i = 0; i &lt; n; i++) { long k = i; while (k &gt; 1) { max = Math.max(k, max); if ((k &amp; 1) == 1) { k = k * 3 + 1; } else { k /= 2; } } map.put(max, i); } out.println(&quot;static Map&lt;Long, Long&gt; map;&quot;); out.println(&quot;static {&quot;); out.println(&quot;map = new HashMap&lt;&gt;();&quot;); for (long key : map.keySet()) { out.printf(&quot;map.put(%dL, %dL);\\n&quot;, map.get(key), key); } out.println(&quot;}&quot;); out.flush(); }} 卡片换位你玩过华容道的游戏吗？这是个类似的，但更简单的游戏。看下面 3 x 2 的格子 +—+—+—+| A | * | * |+—+—+—+| B | | * |+—+—+—+ 在其中放5张牌，其中A代表关羽，B代表张飞，* 代表士兵。还有一个格子是空着的。 你可以把一张牌移动到相邻的空格中去(对角不算相邻)。游戏的目标是：关羽和张飞交换位置，其它的牌随便在哪里都可以。 输入格式：输入两行6个字符表示当前的局面 输出格式：一个整数，表示最少多少步，才能把AB换位（其它牌位置随意） 样例1输入： A**B 输出：17 样例2输入：A B 输出：12 资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms 广度搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.util.ArrayDeque;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Queue;public class Main { static Map&lt;String, Boolean&gt; isVisit = new HashMap&lt;&gt;(); static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String start = in.readLine() + in.readLine(); String end = swap(start, start.indexOf(&quot;A&quot;), start.indexOf(&quot;B&quot;)); out.println(&quot;start -&gt; &quot; + start + &quot; end -&gt; &quot; + end); out.flush(); bfs(start, end); } static boolean isEnd(String maybe, String end) { // 其它的牌随便在哪里都可以，只要AB位置互换 int A = end.indexOf(&quot;A&quot;); int B = end.indexOf(&quot;B&quot;); int a = maybe.indexOf(&quot;A&quot;); int b = maybe.indexOf(&quot;B&quot;); return A == a &amp;&amp; B == b; } static void bfs(String start, String end) { isVisit.put(start, true); Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(new Node(start, 0)); while (!queue.isEmpty()) { Node headNode = queue.poll(); headNode.buildChildNode(); for (Node node : headNode.childNode) { out.println(node.value + &quot; &quot; + node.step); out.flush(); if (isEnd(node.value, end)) { out.println(node.step); out.flush(); return; } else { queue.offer(node); } } } } static String swap(String string, int i, int j) { char[] cs = string.toCharArray(); char tmp = cs[i]; cs[i] = cs[j]; cs[j] = tmp; return new String(cs); } static class Node { String value; int step; List&lt;Node&gt; childNode; Node(String value, int step) { this.value = value; this.step = step; } void buildChildNode() { this.childNode = new LinkedList&lt;&gt;(); // 每个节点最多3种情况 List&lt;String&gt; node = new LinkedList&lt;&gt;(); int index = this.value.indexOf(&quot; &quot;); // 在上边 if (index &lt; 3) { // 在左边，则右边、下边可以走过来 if (index == 0) { node.add(swap(this.value, index, index + 1)); node.add(swap(this.value, index, 3)); } // 在中间，则左边、右边、下边可以走过来 else if (index == 1) { node.add(swap(this.value, index, index - 1)); node.add(swap(this.value, index, index + 1)); node.add(swap(this.value, index, 4)); } // 在右边，则左边、下边可以走过来 else if (index == 2) { node.add(swap(this.value, index, index - 1)); node.add(swap(this.value, index, 5)); } } else { // 在下边 // 在左边，则右边、上边可以走过来 if (index == 3) { node.add(swap(this.value, index, index + 1)); node.add(swap(this.value, index, 0)); } // 在中间，则左边、右边、上边可以走过来 else if (index == 4) { node.add(swap(this.value, index, index - 1)); node.add(swap(this.value, index, index + 1)); node.add(swap(this.value, index, 1)); } // 在右边，则左边、上边可以走过来 else if (index == 5) { node.add(swap(this.value, index, index - 1)); node.add(swap(this.value, index, 2)); } } for (int i = 0; i &lt; node.size(); i++) { if (isVisit.get(node.get(i)) == null) { this.childNode.add(new Node(node.get(i), this.step + 1)); isVisit.put(node.get(i), true); } } } }}","link":"/2018/01/23/zh/programing/basis/algorithm/blue_bridge_cup/7th_province/"},{"title":"蓝桥杯2017年第8届省赛","text":"结果填空购物单小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。 这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。 取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。你的任务是计算出，小明最少需要取多少现金。 以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950**** 180.90 88折**** 10.25 65折**** 56.14 9折**** 104.65 9折**** 100.30 88折**** 297.15 半价**** 26.75 65折**** 130.62 半价**** 240.28 58折**** 270.62 8折**** 115.87 88折**** 247.34 95折**** 73.21 9折**** 101.00 半价**** 79.54 半价**** 278.44 7折**** 199.26 半价**** 12.97 9折**** 166.30 78折**** 125.50 58折**** 84.98 9折**** 113.35 68折**** 166.57 半价**** 42.56 9折**** 81.90 95折**** 131.78 8折**** 255.89 78折**** 109.17 9折**** 146.69 68折**** 139.33 65折**** 141.16 78折**** 154.74 8折**** 59.42 8折**** 85.44 68折**** 293.70 88折**** 261.79 65折**** 11.30 88折**** 268.27 58折**** 128.29 88折**** 251.03 8折**** 208.39 75折**** 128.88 75折**** 62.06 9折**** 225.87 75折**** 12.89 75折**** 34.28 75折**** 62.16 58折**** 129.12 半价**** 218.37 半价**** 289.69 8折 需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。特别地，半价是按50%计算。 请提交小明要从取款机上提取的金额，单位是元。 5200 答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。 123456789101112131415161718192021222324252627282930import java.util.ArrayList;import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while (scanner.hasNext()) { list.add(scanner.next()); } int sum = 0; for (int i = 0; i &lt; list.size(); i++) { if (i % 3 == 1) { double percent = 0.0; if (list.get(i + 1).equals(&quot;半价&quot;)) { percent = 0.5; } else { percent = Integer.parseInt(list.get(i + 1).split(&quot;折&quot;)[0]) / 10.0; if (percent &gt; 0) { percent /= 10.0; } } sum += Double.parseDouble(list.get(i)) * percent; } } System.out.println(sum); }} 纸牌三角形A,2,3,4,5,6,7,8,9 共9张纸牌排成一个正三角形（A按1计算）。要求每个边的和相等。下图就是一种排法。 这样的排法可能会有很多。 如果考虑旋转、镜像后相同的算同一种，一共有多少种不同的排法呢？ 144 回溯12345678910111213141516171819202122232425262728293031323334353637public class Main { static int[] array = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; static int solution = 0; public static void main(String[] args) { backTrack(0); // 旋转3种情况，镜像2种情况 System.out.println(solution / 6); } static void backTrack(int num) { if (num == 9) { if (isOK()) { solution++; } } else { for (int i = num; i &lt; 9; i++) { swap(num, i); backTrack(num + 1); swap(num, i); } } } static void swap(int i, int j) { int tmp = array[i]; array[i] = array[j]; array[j] = tmp; } static boolean isOK() { int a = array[0] + array[1] + array[2] + array[3]; int b = array[3] + array[4] + array[5] + array[6]; int c = array[6] + array[7] + array[8] + array[0]; return a == b &amp;&amp; a == c; }} 等差素数列2,3,5,7,11,13,….是素数序列。类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 210 分别是：199 409 619 829 1039 1249 1459 1669 1879 2089 暴力123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class Main { static ArrayList&lt;Integer&gt; prime; public static void main(String[] args) { prime = getPrime(10000); find(10); System.out.println(); } static void find(int length) { int tolerance = 1; int i = 0; // 从公差为1找起 // 凑齐10个数即公差存在，且最小 ArrayList&lt;Integer&gt; container = new ArrayList&lt;&gt;(); int nums = 1; while (true) { container.add(prime.get(i)); for (int k = i + 1, j = 1; k &lt; prime.size(); k++) { if (prime.get(k) - prime.get(i) == j * tolerance) { container.add(prime.get(k)); nums++; j++; } } if (nums == 10) { for (Integer k : container) { System.out.print(k + &quot; &quot;); } System.out.println(); System.out.println(tolerance); break; } else { container.clear(); nums = 1; i++; if (i == prime.size()) { tolerance++; i = 0; } } } } static ArrayList&lt;Integer&gt; getPrime(int n) { boolean[] notPrime = new boolean[n + 1]; int sqrtN = (int) Math.sqrt(n); for (int i = 2; i &lt;= sqrtN; i++) { if (notPrime[i]) continue; for (int j = i * i; j &lt;= n; j += i) { // j是i的倍数，即不是素数 notPrime[j] = true; } } ArrayList&lt;Integer&gt; prime = new ArrayList&lt;&gt;(); if (n &gt; 1) { prime.add(2); } for (int i = 3; i &lt;= n; i += 2) { if (!notPrime[i]) { prime.add(i); } } System.out.println(prime.size()); return prime; }} 方格分割6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。 如图是可行的分割法： 试计算：包括这3种分法在内，一共有多少种不同的分割方法。 509注意：旋转对称的属于同一种分割法。 分析：图形中心对称，从中间走，能走到边界的话即是一种分割方法。 12345678910111213141516171819202122232425262728293031323334public class Main { static int n = 6; static int[][] map = new int[n + 1][n + 1]; static int solution = 0; static int[][] direction = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }; public static void main(String[] args) { map[3][3] = 1; backTrack(3, 3); System.out.println(solution / 4); } static void backTrack(int x, int y) { // 边缘 if (x == 0 || y == 0 || x == n || y == n) { solution++; return; } for (int i = 0; i &lt; 4; i++) { int dx = x + direction[i][0]; int dy = y + direction[i][1]; // 没有走过 if (map[dx][dy] == 0) { // 标记 map[dx][dy] = 1; // 镜像标记 map[n - dx][n - dy] = 1; backTrack(dx, dy); map[dx][dy] = 0; map[n - dx][n - dy] = 0; } } }} 承压计算X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。 每块金属原料的外形、尺寸完全一致，但重量不同。金属材料被严格地堆放成金字塔形。 123456789101112131415161718192021222324252627282930 7 5 8 7 8 8 9 2 7 2 8 1 4 9 1 8 1 8 8 4 1 7 9 6 1 4 5 4 5 6 5 5 6 9 5 6 5 5 4 7 9 3 5 5 1 7 5 7 9 7 4 7 3 3 1 4 6 4 5 5 8 8 3 2 4 3 1 1 3 3 1 6 6 5 5 4 4 2 9 9 9 2 1 9 1 9 2 9 5 7 9 4 3 3 7 7 9 3 6 1 3 8 8 3 7 3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 其中的数字代表金属块的重量（计量单位较大）。最下一层的X代表30台极高精度的电子秤。 假设每块原料的重量都十分精确地平均落在下方的两个金属块上，最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。电子秤的计量单位很小，所以显示的数字很大。 工作人员发现，其中读数最小的电子秤的示数为：2086458231 请你推算出：读数最大的电子秤的示数为多少？ 72665192664 123456789101112131415161718192021222324252627282930import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); public static void main(String[] args) { double[][] weight = new double[30][30]; for (int i = 0; i &lt; 29; i++) { for (int j = 0; j &lt;= i; j++) { weight[i][j] = scanner.nextDouble(); } } for (int i = 1; i &lt; 30; i++) { for (int j = 0; j &lt; i; j++) { double front = weight[i - 1][j] / 2.0; weight[i][j] += front; weight[i][j + 1] += front; } } double max = Double.MIN_VALUE; double min = Double.MAX_VALUE; for (int i = 0; i &lt; 30; i++) { max = Math.max(weight[29][i], max); min = Math.max(weight[29][i], min); } // 按比例缩放 System.out.println(2086458231 / min * max); }} 魔方状态二阶魔方就是只有2层的魔方，只由8个小块组成。 小明很淘气，他只喜欢3种颜色，所有把家里的二阶魔方重新涂了颜色，如下： 前面：橙色右面：绿色上面：黄色左面：绿色下面：橙色后面：黄色 请你计算一下，这样的魔方被打乱后，一共有多少种不同的状态。 如果两个状态经过魔方的整体旋转后，各个面的颜色都一致，则认为是同一状态。 1 迷宫X星球的一处迷宫游乐场建在某个小山坡上。它是由10x10相互连通的小房间组成的。 房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：L表示走到左边的房间，R表示走到右边的房间，U表示走到上坡方向的房间，D表示走到下坡方向的房间。 X星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！ 开始的时候，直升机把100名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。 迷宫地图如下： UDDLUULRULUURLLLRRRURRUURLDLRDRUDDDDUUUUURUDLLRRUUDURLRLDLRLULLURLLRDURDLULLRDDDUUDDUDUDLLULRDLUURRR 请你计算一下，最后，有多少玩家会走出迷宫而不是在里边兜圈子? 31 如果你还没明白游戏规则，可以参看一个简化的4x4迷宫的解说图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int n = 10; static char[][] map = new char[n][n]; static int people = 0; public static void main(String[] args) { for (int i = 0; i &lt; n; i++) { String buf = scanner.next(); char[] c = buf.toCharArray(); for (int j = 0; j &lt; n; j++) { map[i][j] = c[j]; } } goMap(); System.out.println(people); } static void goMap() { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { go(i, j); } } } static void go(int x, int y) { // 走100次还没走出边界即走不出去 for (int i = 1; i &lt;= n * n; i++) { switch (map[x][y]) { case 'U': x--; break; case 'D': x++; break; case 'L': y--; break; case 'R': y++; break; } if (x == -1 || x == 10 || y == -1 || y == 10) { people++; break; } } }} 9数算式观察如下的算式： 9213 x 85674 = 789314562 左边的乘数和被乘数正好用到了19的所有数字，每个1次。而乘积恰好也是用到了19的所有数字，并且每个1次。 请你借助计算机的强大计算能力，找出满足如上要求的9数算式一共有多少个？ 346 注意： 总数目包含题目给出的那个示例。 乘数和被乘数交换后作为同一方案来看待。 回溯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Main { static int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; static int count = 0; public static void main(String args[]) { backTrack(0); System.out.println(count); } static void backTrack(int n) { if (n == 9) { if (isOK()) { count++; } } else { for (int i = n; i &lt; 9; i++) { swap(i, n); backTrack(n + 1); swap(i, n); } } } static boolean isOK() { long a = array[0] * 1000 + array[1] * 100 + array[2] * 10 + array[3]; long b = array[4] * 10000 + array[5] * 1000 + array[6] * 100 + array[7] * 10 + array[8]; long c = a * b; return isVisistOnce(c); } static boolean isVisistOnce(long n) { boolean[] num = new boolean[10]; while (n != 0) { int k = (int) (n % 10); if (num[k] || k == 0) { return false; } num[k] = true; n /= 10; } for (int i = 1; i &lt;= 9; i++) { if (!num[i]) { return false; } } return true; } static void swap(int i, int j) { int tmp = array[i]; array[i] = array[j]; array[j] = tmp; }} 跳蚱蜢 有 9 只盘子，排成 1 个圆圈。其中 8 只盘子内装着 8 只蚱蜢，有一个是空盘。我们把这些蚱蜢顺时针编号为 1~8 每只蚱蜢都可以跳到相邻的空盘中，也可以再用点力，越过一个相邻的蚱蜢跳到空盘中。 请你计算一下，如果要使得蚱蜢们的队形改为按照逆时针排列，并且保持空盘的位置不变（也就是 1-8 换位，2-7 换位,…），至少要经过多少次跳跃？20 分析：把盘子当成四叉树，把空盘子当成起点，问题就转换成了从 12345678 状态开始，到 87654321 状态结束，最短步数是多少？ 广度搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.ArrayDeque;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Queue;class Main { // 开始状态和结束状态 static String start = &quot;12345678&quot;, end = &quot;87654321&quot;; // 可能跳回原来的盘子，要去重 static Map&lt;String, Boolean&gt; isVisit = new HashMap&lt;&gt;(); public static void main(String[] args) { bfs(); } static void bfs() { isVisit.put(start, true); Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(new Node(start, 0)); while (!queue.isEmpty()) { Node headNode = queue.poll(); headNode.buildChildNodes(); for (Node node : headNode.childNode) { System.out.println(node.value + &quot; &quot; + node.step); if (node.value.equals(end)) { System.out.println(node.step); return; } else { queue.offer(node); } } } } static class Node { List&lt;Node&gt; childNode; String value; int step; Node(String value, int step) { this.value = value; this.step = step; } void buildChildNodes() { this.childNode = new LinkedList&lt;&gt;(); // 为了方便，直接字符串拼接 List&lt;String&gt; array = new LinkedList&lt;&gt;(); array.add(this.value.substring(1) + &quot;&quot; + this.value.charAt(0)); array.add(this.value.substring(2) + &quot;&quot; + this.value.charAt(1) + &quot;&quot; + this.value.charAt(0)); array.add(this.value.charAt(this.value.length() - 1) + &quot;&quot; + this.value.substring(this.value.length() - 1)); array.add(this.value.charAt(this.value.length() - 1) + &quot;&quot; + this.value.charAt(this.value.length() - 2) + &quot;&quot; + this.value.substring(0, this.value.length() - 2)); for (int i = 0; i &lt; array.size(); i++) { if (isVisit.get(array.get(i)) == null &amp;&amp; array.get(i).length() == 8) { this.childNode.add(new Node(array.get(i), this.step + 1)); isVisit.put(array.get(i), true); } } } }} 算式900小明的作业本上有道思考题： 看下面的算式： (□□□□ - □□□□) * □□ = 900 其中的小方块代表 09 的数字，这 10 个方块刚好包含了 09 中的所有数字。注意：0 不能作为某个数字的首位。 小明经过几天的努力，终于做出了答案！如下：(5012 - 4987) * 36 = 900 用计算机搜索后，发现还有另外一个解，本题的任务就是：请你算出这另外的一个解。 6048 5973 12 12345678910111213141516171819202122232425262728293031public class Main { static int[] number = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; public static void main(String[] args) { backTrack(0); } static void backTrack(int n) { if (n == 10) { int a = number[0] * 1000 + number[1] * 100 + number[2] * 10 + number[3]; int b = number[4] * 1000 + number[5] * 100 + number[6] * 10 + number[7]; int c = number[8] * 10 + number[9]; if ((a - b) * c == 900) { System.out.println(a + &quot; &quot; + b + &quot; &quot; + c); } } else { for (int i = n; i &lt; 10; i++) { swap(n, i); if (number[0] != 0 &amp;&amp; number[4] != 0 &amp;&amp; number[8] != 0) { backTrack(n + 1); } swap(n, i); } } } static void swap(int i, int j) { int tmp = number[i]; number[i] = number[j]; number[j] = tmp; }} 外星日历某星系深处发现了文明遗迹。 他们的计数也是用十进制。他们的文明也有日历。日历只有天数，没有年、月的概念。有趣的是，他们也使用了类似“星期”的概念，只不过他们的一个星期包含了 9 天，为了方便，这里分别记为: A, B, C….H, I 从一些资料上看到：他们的 23 日是星期 E他们的 190 日是星期 A他们的 343251 日是星期 I 令人兴奋的是，他们居然也预见了“世界末日”的那天，当然是一个很大很大的数字 651764141421415346185 请你计算一下，这遥远的一天是该文明的星期几？ G 方法1：windows 的计算器直接 651764141421415346185 mod 9 = 7 方法2： 123BigInteger a = new BigInteger(&quot;651764141421415346185&quot;);BigInteger b = new BigInteger(&quot;9&quot;);System.out.println(a.mod(b)); 代码填空取数位求 1 个整数的第 k 位数字有很多种方法，以下的方法就是一种。 对于题目中的测试数据，应该打印5。 12345678910111213141516171819202122public class Main { static int len(int x) { if (x &lt; 10) return 1; return len(x / 10) + 1; } // 取x的第k位数字 static int f(int x, int k) { if (len(x) - k == 0) return x % 10; // return ______________________; // 填空 // 应该是从左向右数 return f(x / 10, k); } public static void main(String[] args) { int x = 23513; // System.out.println(len(x)); System.out.println(f(x, 3)); }} 最大公共子串最大公共子串长度问题就是：求两个串的所有子串中能够匹配上的最大长度是多少。 比如：”abcdkkk” 和 “baabcdadabc”，可以找到的最长的公共子串是”abcd”,所以最大公共子串长度为4。 下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。 请分析该解法的思路，并补全划线部分缺失的代码。 123456789101112131415161718192021222324252627282930public class Main { static int f(String s1, String s2) { char[] c1 = s1.toCharArray(); char[] c2 = s2.toCharArray(); // 7 + 1，11 + 1 int[][] a = new int[c1.length + 1][c2.length + 1]; int max = 0; // a.length：行长度8 for (int i = 1; i &lt; a.length; i++) { // a[i].length：列长度12 for (int j = 1; j &lt; a[i].length; j++) { if (c1[i - 1] == c2[j - 1]) { // a[i][j] = __________________; // 填空 a[i][j] = a[i - 1][j - 1] + 1; if (a[i][j] &gt; max) max = a[i][j]; } } } return max; } public static void main(String[] args) { int n = f(&quot;abcdkkk&quot;, &quot;baabcdadabc&quot;); System.out.println(n); }} 动态规划： 123456789101112通过前一过程的结果得到当前状态的结果a[i][j] = a[i - 1][j - 1] + 1 b, a, a, b, c, d, a, d, a, b, c [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]a [0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0]b [0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0]c [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3]d [0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 0, 0]k [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]k [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]k [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 字母组串由 A, B, C 这3个字母就可以组成许多串。比如：”A”, “AB”, “ABC”, “ABA”, “AACBB”…. 现在，小明正在思考一个问题：如果每个字母的个数有限定，能组成多少个已知长度的串呢？ 他请好朋友来帮忙，很快得到了代码，解决方案超级简单，然而最重要的部分却语焉不详。 请仔细分析源码，填写划线部分缺少的内容。 123456789101112131415161718public class A{ // a个A，b个B，c个C 字母，能组成多少个不同的长度为n的串。 static int f(int a, int b, int c, int n) { if(a&lt;0 || b&lt;0 || c&lt;0) return 0; if(n==0) return 1; //return ________________________________; //填空 return f(a - 1, b, c, n - 1) + f(a, b - 1, c, n - 1) + f(a, b, c - 1, n - 1); } public static void main(String[] args) { System.out.println(f(1,1,1,2)); System.out.println(f(1,2,3,3)); }} 对于上面的测试数据，小明口算的结果应该是：619 杨辉三角杨辉三角也叫帕斯卡三角，在很多数量关系中可以看到，十分重要。 第0行： 1第1行： 1 1第2行： 1 2 1第3行： 1 3 3 1第4行： 1 4 6 4 1…. 两边的元素都是1， 中间的元素是左上角的元素与右上角的元素和。 我们约定，行号，列号都从0计数。所以： 第6行的第2个元素是15，第3个元素是20 直观地看，需要开辟一个二维数组，其实一维数组也可以胜任。如下程序就是用一维数组“腾挪”的解法。 12345678910111213141516171819202122232425262728public class Main { public static void main(String[] args) { System.out.println(f(6, 2)); System.out.println(f(6, 3)); System.out.println(f(40, 20)); } // 杨辉三角的第row行，第col列 static long f(int row, int col) { if (row &lt; 2) return 1; if (col == 0) return 1; if (col == row) return 1; long[] a = new long[1024]; a[0] = 1; a[1] = 1; int p = 2; int q; while (p &lt;= row) { a[p] = 1; // for( _________________ ) a[q] = a[q] + a[q-1]; //填空 for (q = p - 1; q &gt; 0; q--) a[q] = a[q] + a[q - 1]; p++; } return a[col]; }} 程序设计日期问题小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。 比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。 给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？ 输入：一个日期，格式是”AA/BB/CC”。(0 &lt;= A, B, C &lt;= 9) 输入：输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。 样例输入：02/03/04 样例输出：2002-03-042004-02-032004-03-02 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 直接列举+Calendar判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Arrays;import java.util.Calendar;import java.util.LinkedHashSet;import java.util.Scanner;import java.io.BufferedInputStream;class Main { // 链表集合，可以保证去重的同时顺序不改变 static LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); public static void main(String args[]) { String string = scanner.next(); String[] strNum = string.split(&quot;/&quot;); int[] num = { Integer.valueOf(strNum[0]), Integer.valueOf(strNum[1]), Integer.valueOf(strNum[2]) }; // 先排序 Arrays.sort(num); // 手动按数字从小到大进行组合 // 这样可以避免之后再对日期排序 // 最多有6种情况 combine(num[0], num[1], num[2]); combine(num[0], num[2], num[1]); combine(num[1], num[0], num[2]); combine(num[1], num[2], num[0]); combine(num[2], num[0], num[1]); combine(num[2], num[1], num[0]); set.stream().forEach(x -&gt; System.out.println(x)); } static void combine(int a, int b, int c) { int year; if (0 &lt;= a &amp;&amp; a &lt;= 59) { year = 2000 + a; } else if (60 &lt;= a &amp;&amp; a &lt;= 99) { year = 1900 + a; } else { return; } // 直接通过Calendar出错来检查日期是否正确 if (isValidate(year, b, c)) { String month = String.format(&quot;%02d&quot;, b); String date = String.format(&quot;%02d&quot;, c); set.add(year + &quot;-&quot; + month + &quot;-&quot; + date); } } static boolean isValidate(int year, int month, int date) { try { Calendar calendar = Calendar.getInstance(); calendar.setLenient(false); // 注意月份从0开始 calendar.set(year, month - 1, date); calendar.get(Calendar.YEAR); return true; } catch (Exception e) { return false; } }} 包子凑数小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。 每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。 当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。 小明想知道一共有多少种数目是包子大叔凑不出来的。 输入：第一行包含一个整数N。(1 &lt;= N &lt;= 100)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100) 输出：一个整数代表答案。如果凑不出的数目有无限多个，输出INF。 样例输入1：245输出：6 样例输入2：246输出：INF 样例说明：对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。对于样例2，所有奇数都凑不出来，所以有无限多个。 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 分析：完全背包扩展欧几里德，方程 ax + by = gcd(a,b)欧几里德判断所有数的公约数是否为1，是就有限，不是即无限。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int steamer[]; static boolean dp[] = new boolean[10100]; static int cannot = 0; public static void main(String[] args) { int n = scanner.nextInt(); steamer = new int[n]; for (int i = 0; i &lt; n; i++) { steamer[i] = scanner.nextInt(); } int m = steamer[0]; for (int i = 0; i &lt; n; i++) { m = gcd(m, steamer[i]); } // 所有数的公约数不为1，凑不出 if (m != 1) { System.out.println(&quot;INF&quot;); } else { // 完全背包 dp[0] = true; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 10000; j++) { if (dp[j]) { dp[j + steamer[i]] = true; } } } for (int i = 0; i &lt; 10000; i++) { if (dp[i] != true) { System.out.print(i + &quot; &quot;); cannot++; } } System.out.println(); System.out.println(cannot); } } static int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }} 分巧克力儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同 例如：一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入：第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000)输入保证每位小朋友至少能获得一块1x1的巧克力。 输出：输出切出的正方形巧克力最大可能的边长。 样例输入：2 106 55 6 样例输出：2 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 二分12345678910111213141516171819202122232425262728293031323334353637383940import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int n = scanner.nextInt(); static int k = scanner.nextInt(); static int[] h = new int[n]; static int[] w = new int[n]; public static void main(String[] args) { for (int i = 0; i &lt; n; i++) { h[i] = scanner.nextInt(); w[i] = scanner.nextInt(); } int front = 1; int reer = 100000; while (front &lt; reer) { // 每次切的正方形边长 int midddle = (front + reer) / 2; // 切出来的面积大于等于人数即可 if (cut(midddle) &gt;= k) { front = midddle + 1; } else { reer = midddle - 1; } } System.out.println(front); } static int cut(int length) { int sum = 0; for (int i = 0; i &lt; n; i++) { sum += (h[i] / length) * (w[i] / length); } return sum; }} k倍区间给定一个长度为 N 的数列，A1, A2, … AN，如果其中一段连续的子序列 Ai, Ai+1, … Aj(i &lt;= j) 之和是 K 的倍数，我们就称这个区间 [i, j] 是 K 倍区间。 你能求出数列中总共有多少个 K 倍区间吗？ 输入第一行包含两个整数 N 和 K (1 &lt;= N, K &lt;= 100000)以下 N 行每行包含一个整数 Ai (1 &lt;= Ai &lt;= 100000) 输出输出一个整数，代表K倍区间的数目。 输入：5 212345 输出：6 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 分析：判断某些区间的和时会重复计算，比如区间 [1,4]，其和为 1+2+3+4，而 1+2+3 在区间 [1,3] 时就已经计算过了，为了减少重复，使用前缀和： 用 sum[i] 表示 A1 + A2 + … +Ai 对任意一段区间 [l, r]，其和为 sum[r] - sum[l-1] 保证这个区间和为K倍数：(sum[r] - sum[l-1]) % k == 0 变形后：sum[r] % k == sum[l-1] % k 样例说明： 1234区间： 1 2 3 4 5前缀和：1 3 6 10 15取余： 1 1 0 0 1，这里其实还隐藏了第一个 0补全：0 1 1 0 0 1 根据变形 sum[r] % k == sum[l-1] % k 可以判断出：0 == 0：[1, 3]、[1, 4]、[4]1 == 1：[2, 5]、[3, 5]、[2] 这里就相当于将余数相同的进行了组合： 123补全： 0 1 1 0 0 10下标：1 2 3 （为了方便说明）1下标： 1 2 3 根据变形，1号0可以和2号0，也可以和3号0组合；2号0可以和3号0组合，即组合公式C(3, 2) = 3种。同理，1号1可以和2号1，也可以和3号1组合；2号1可以和3号1组合，组合公式同上。 123456789101112131415161718192021222324252627282930import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static int n = scanner.nextInt(); static int k = scanner.nextInt(); static int[] array = new int[n + 1]; // 前i项的和 static int[] sum = new int[n + 1]; // 前缀和取余后为x的个数(0&lt;= x &lt; k) static int[] mod = new int[k]; // 符合条件的区间个数 static long count = 0; public static void main(String[] args) { for (int i = 1; i &lt;= n; i++) { array[i] = scanner.nextInt(); sum[i] = sum[i - 1] + array[i]; mod[sum[i] % k]++; } // 隐藏0 mod[0] = 1; for (int i = 0; i &lt; k; i++) { // 余数相同的进行组合：C(n, 2) count += (mod[i] * (mod[i] - 1)) / 2; } System.out.println(count); }} 正则问题考虑一种简单的正则表达式：只由 x ( ) | 组成的正则表达式。小明想求出这个正则表达式能接受的最长字符串的长度。 例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。 输入一个由x()|组成的正则表达式。输入长度不超过100，保证合法。 输出这个正则表达式能接受的最长字符串的长度。 样例输入：((xx|xxx)x|(x|xx))xx 输出：6 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 深度搜索123456789101112131415161718192021222324252627282930313233343536373839import java.io.BufferedInputStream;import java.util.Scanner;public class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static String string = scanner.next(); static int index = 0; static int length = string.length(); public static void main(String[] args) { System.out.println(dfs()); } static long dfs() { long x = 0, total = 0; while (index &lt; length) { char symbol = string.charAt(index); if (symbol == '(') { // 遇到(进入新状态计算x个数 index++; x += dfs(); } else if (symbol == ')') { // 遇到)表示计算完()内部，回到上一层 index++; break; } else if (symbol == '|') { // 遇到|表示要取最大值 index++; total = Math.max(x, total); x = 0; } else { // 遇到x，计数 index++; x++; } } return Math.max(x, total); }} 油漆面积X星球的一批考古机器人正在一片废墟上考古，该区域的地面坚硬如石、平整如镜。管理人员为方便，建立了标准的直角坐标系。 每个机器人都各有特长、身怀绝技。它们感兴趣的内容也不相同，经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。 矩形的表示格式为(x1,y1,x2,y2)，代表矩形的两个对角点坐标。 为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆，小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。 其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。注意，各个矩形间可能重叠。 本题的输入为若干矩形，要求输出其覆盖的总面积。 输入格式：第一行，一个整数n，表示有多少个矩形(1&lt;=n&lt;10000)接下来的n行，每行有4个整数x1 y1 x2 y2，空格分开，表示矩形的两个对角顶点坐标。(0&lt;= x1,y1,x2,y2 &lt;=10000) 输出格式：一行一个整数，表示矩形覆盖的总面积。 样例1：31 5 10 103 1 20 202 7 15 17 输出：340 样例2：35 2 10 62 7 12 108 1 15 15 输出：128 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 2000ms 分析：线段树 + 扫描线解决的典型题目，参考博客。 因为4个坐标都是整型，也可以直接使用二维数组，记录访问过的点，最后再遍历该数组。 1 青蛙跳杯子X星球的流行宠物是青蛙，一般有两种颜色：白色和黑色。X星球的居民喜欢把它们放在一排茶杯里，这样可以观察它们跳来跳去。如下图，有一排杯子，左边的一个是空着的，右边的杯子，每个里边有一只青蛙。 *WWWBBB 其中，W字母表示白色青蛙，B表示黑色青蛙，*表示空杯子。 X星的青蛙很有些癖好，它们只做3个动作之一： 跳到相邻的空杯子里。 隔着1只其它的青蛙（随便什么颜色）跳到空杯子里。 隔着2只其它的青蛙（随便什么颜色）跳到空杯子里。 对于上图的局面，只要1步，就可跳成下图局面： WWW*BBB 本题的任务就是已知初始局面，询问至少需要几步，才能跳成另一个目标局面。 输入为2行，2个串，表示初始局面和目标局面。输出要求为一个整数，表示至少需要多少步的青蛙跳。 样例1：*WWBBWWBB* 输出：2 样例2：WWW*BBBBBB*WWW 输出：10 我们约定，输入的串的长度不超过15 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 广度搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.io.BufferedInputStream;import java.util.ArrayDeque;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Queue;import java.util.Scanner;class Main { static Scanner scanner = new Scanner(new BufferedInputStream(System.in)); static Map&lt;String, Boolean&gt; isVisit = new HashMap&lt;&gt;(); public static void main(String[] args) { // 开始状态和结束状态 String start = scanner.next(); String end = scanner.next(); bfs(start, end); } static void bfs(String start, String end) { isVisit.put(start, true); Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(new Node(start, 0)); while (!queue.isEmpty()) { Node headNode = queue.poll(); headNode.buildChildNodes(); for (Node node : headNode.childNode) { System.out.println(node.value + &quot; &quot; + node.step); if (node.value.equals(end)) { System.out.println(node.step); return; } else { queue.offer(node); } } } } static class Node { List&lt;Node&gt; childNode; String value; int step; Node(String value, int step) { this.value = value; this.step = step; } void buildChildNodes() { this.childNode = new LinkedList&lt;&gt;(); // 确定*位置 int xIndex = this.value.indexOf(&quot;*&quot;); // 只有一个*，数据有问题 if (xIndex == 0 &amp;&amp; this.value.length() == 1) { return; } List&lt;String&gt; array = new LinkedList&lt;&gt;(); // 青蛙跳 if (xIndex &gt;= 1) array.add(swap(this.value, xIndex, xIndex - 1)); if (xIndex &gt;= 2) array.add(swap(this.value, xIndex, xIndex - 2)); if (xIndex &gt;= 3) array.add(swap(this.value, xIndex, xIndex - 3)); if (this.value.length() &gt; xIndex + 1) array.add(swap(this.value, xIndex, xIndex + 1)); if (this.value.length() &gt; xIndex + 2) array.add(swap(this.value, xIndex, xIndex + 2)); if (this.value.length() &gt; xIndex + 3) array.add(swap(this.value, xIndex, xIndex + 3)); for (int i = 0; i &lt; array.size(); i++) { if (isVisit.get(array.get(i)) == null) { this.childNode.add(new Node(array.get(i), this.step + 1)); isVisit.put(array.get(i), true); } } } static String swap(String string, int i, int j) { char[] cs = string.toCharArray(); char tmp = cs[i]; cs[i] = cs[j]; cs[j] = tmp; return new String(cs); } }}","link":"/2018/01/26/zh/programing/basis/algorithm/blue_bridge_cup/8th_province/"},{"title":"蓝桥杯2015-2017省赛题目总结","text":"前记刷了这几年的题，总体还是比较简单的，就是有些填空题比较坑，总结一下题型和技巧。 注意 scanner.close(); 等代码规范，以免出现意想不到的事。毕竟不是项目，代码丑也没人看。 题型结果填空、代码填空、程序设计 结果填空先看懂题目，确定暴力能出结果的直接暴力跑。 有些就是小学初中的题目，套公式跑，减少出错几率。 日期类日期类问题最好用Java的Calendar类，比如2017年的第1个大题。 涉及到闰年判断，月份判断，很容易做错，直接使用Calendar类判断日期对不对就很快做完了。 日期检查1234567891011try { Calendar calendar = Calendar.getInstance(); // 取消宽松，不然日期出错会跳到下一天 calendar.setLenient(false); // 中间的month从0开始，而1表示2月 calendar.set(2017, 1, 29); // get里可以是其他，只要日期错了就无法get calendar.get(Calendar.YEAR);} catch (Exception e) { System.out.println(false);} 比如：高斯出生于：1777年4月30日。高斯获得博士学位的那天日记上标着：8113，表示那一天是高斯出生后的第8113天，问年月日？ 1799-7-16 1234Calendar calendar = Calendar.getInstance();calendar.set(1777, 4, 30);calendar.add(calendar.DATE, 8113);System.out.println(calendar.get(Calendar.YEAR) + &quot;-&quot; + calendar.get(Calendar.MONTH) + &quot;-&quot;+ calendar.get(Calendar.DAY_OF_MONTH)); 其他有些题目有去重的要求的，比如镜像和旋转，一定要注意排除掉，最好动手画画，确定是题目说的情况。 遇到除法的最好转成乘法，避免转换为浮点数。 代码填空这些题基本就是回溯、动态规划、递归、广度/深度优先搜索等，一般是填1句代码的。 没什么诀窍，复制到IDE里，然后确定题型： 回溯：改变后又变回来，如：a=1; f(n); a=0; 动态规划：一维二维数组中涉及前面的状态，如：a[i] = a[i-1]; 广度：“至少”等字眼 深度：和递归类似 在半懵逼下，多放几个断点，跟着程序走一下，看看能不能找到缺的是什么。 程序设计回溯，动态规划，前缀和，广度/深度搜索，线段树，扫描线，数学常用定理：欧几里德。 看懂题目，确定题型会做，增加多几个自己手算的样例，避免失分。 代码基本模版，替代Scanner，这个输入输出流更快： 1234567891011121314151617181920212223242526272829import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main { public static void main(String[] args) throws IOException { // 实际数据大小如果超过long，可以只用BufferedReader StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); // StreamTokenizer.TT_EOF这个是个参数，就是EOF while (in.nextToken() != StreamTokenizer.TT_EOF) { int a = (int) in.nval; // scanner.nextInt(); in.nextToken();// 指向下一个 int b = (int) in.nval; in.nextToken(); String c = in.sval; out.println(a + b + c); // 刷新，不然数据会留在缓冲区 out.flush(); } }} 总结好好刷一个月题，重点理解上面说到的内容，拿个省奖是没问题的，去不去得了北京旅游就得看造化了。","link":"/2018/01/28/zh/programing/basis/algorithm/blue_bridge_cup/summary_of_2015_2017_provincial_competition_topics/"},{"title":"树状数组","text":"树状数组/二叉索引树（Binary Indexed Tree）： A 数组就是原数组，C 数组则是树状数组。 通过观察可以发现： 12345678910[1, 1] C1 = A1[1, 2] C2 = A1 + A2[3, 3] C3 = A3[1, 4] C4 = A1 + A2 + A3 + A4[5, 5] C5 = A5[5, 6] C6 = A5 + A6[7, 7] C7 = A7[1, 8] C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8C[i] 管理的区间：[i - bitLow(i) + 1, i] 它的查询和修改的时间复杂度都是 O(logN)，空间复杂度则为 O(N)，这是因为树状数组通过将线性结构转化成树状结构，从而进行跳跃式扫描。 通常使用在高效的计算数列的前缀和，区间和。 模版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class BinaryIndexedTree { int length; int[] tree;// 数组有效范围 1~length /** * 为了统一下标，tree[0]不被使用 * * @param length 数组长度 */ BinaryIndexedTree(int length) { this.length = length; tree = new int[length + 1]; } /** * index一直加上lowBit(index)，直到index为length * 这些位置的值都加上value * * @param index 索引 * @param value 值 */ void put(int index, int value) { while (index &lt;= length) { tree[index] += value; index += lowBit(index); } } /** * index一直减去lowBit(index)，直到index为length * 这些位置的值都减去value * * @param index 索引 */ int get(int index) { int sum = tree[index]; int z = index - lowBit(index); index--; while (index != z) { sum -= tree[index]; index -= lowBit(index); } return sum; } /** * 保留k的二进制最低位1的值 * * @param index 索引 */ static int lowBit(int k) { // 1110保留最低位1，即最右边1：0010 return k &amp; -k; } /** * 计算1~index范围内和 * * @param index 索引 */ int sum(int index) { int sum = 0; while (index &gt; 0) { sum += tree[index]; index -= lowBit(index); } return sum; } /** * 计算start~end范围内和 * * @param start 起始 * @param end 终点 */ int sum(int start, int end) { return sum(end) - sum(start - 1); }}","link":"/2018/03/19/zh/programing/basis/data_structure/tree/binary_indexed_tree/"},{"title":"二叉搜索树","text":"二叉搜索树/二叉排序树（Binary Search Tree）： 根的左子树不空，则左子树上所有结点的值均小于它的根结点的值。 根的右子树不空，则右子树上所有结点的值均大于它的根结点的值。 根的左、右子树也分别为二叉搜索树。 模版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190class BSTree { class Node { int key, value; Node leftChild, rightChild; Node(int key, int value) { this.key = key; this.value = value; } } Node root; /** * 查找指定节点 * * @param key 键 * * @return 指定节点 */ Node query(int key) { Node currentNode = root; while (currentNode != null &amp;&amp; currentNode.key != key) { if (key &lt; currentNode.key) { currentNode = currentNode.leftChild; } else { currentNode = currentNode.rightChild; } } return currentNode; } /** * 插入节点 * * @param key 键 * @param value 值 */ void insert(int key, int value) { if (root == null) { root = new Node(key, value); return; } Node currentNode = root; Node parentNode = root; boolean isLeftChild = true; // 待插入的节点需要从根节点开始进行比较 // 小于根节点则与根节点左子树比较，反之则与右子树比较 // 直到左子树为空或右子树为空，插入到相应为空的位置 while (currentNode != null) { parentNode = currentNode; if (key &lt; currentNode.key) { currentNode = currentNode.leftChild; isLeftChild = true; } else { currentNode = currentNode.rightChild; isLeftChild = false; } } Node newNode = new Node(key, value); if (isLeftChild) { parentNode.leftChild = newNode; } else { parentNode.rightChild = newNode; } } /** * 删除指定节点 * * @param key 键 * * @return 是否删除成功 */ boolean delete(int key) { Node currentNode = root; Node parentNode = root; boolean isLeftChild = true; while (currentNode != null &amp;&amp; currentNode.key != key) { parentNode = currentNode; if (key &lt; currentNode.key) { currentNode = currentNode.leftChild; isLeftChild = true; } else { currentNode = currentNode.rightChild; isLeftChild = false; } } if (currentNode == null) { return false; } if (currentNode.leftChild == null &amp;&amp; currentNode.rightChild == null) { // 要删除的节点为叶子节点 if (currentNode == root) { root = null; } else if (isLeftChild) { parentNode.leftChild = null; } else { parentNode.rightChild = null; } } else if (currentNode.rightChild == null) {// 要删除的节点只有左孩子 if (currentNode == root) { root = currentNode.leftChild; } else if (isLeftChild) { parentNode.leftChild = currentNode.leftChild; } else { parentNode.rightChild = currentNode.leftChild; } } else if (currentNode.leftChild == null) {// 要删除的节点只有右孩子 if (currentNode == root) { root = currentNode.rightChild; } else if (isLeftChild) { parentNode.leftChild = currentNode.rightChild; } else { parentNode.rightChild = currentNode.rightChild; } } else { // 要删除的节点既有左孩子又有右孩子 // 思路：用待删除节点右子树中的key值最小节点的值来替代要删除的节点的值，然后删除右子树中key值最小的节点 // 右子树key最小的节点一定不含左子树，所以删除这个key最小的节点一定是属于叶子节点或者只有右子树的节点 Node directPostNode = getDirectPostNode(currentNode); currentNode.key = directPostNode.key; currentNode.value = directPostNode.value; } return true; } /** * 得到待删除节点的直接后继节点 * * @param delNode 待删除节点 * * @return 直接后继节点 */ Node getDirectPostNode(Node delNode) { Node parentNode = delNode;// 用来保存待删除节点的直接后继节点的父亲节点 Node directPostNode = delNode;// 用来保存待删除节点的直接后继节点 Node currentNode = delNode.rightChild; while (currentNode != null) { parentNode = directPostNode; directPostNode = currentNode; currentNode = currentNode.leftChild; } if (directPostNode != delNode.rightChild) {// 从树中删除此直接后继节点 parentNode.leftChild = directPostNode.rightChild; directPostNode.rightChild = null; } return directPostNode;// 返回此直接后继节点 } /** * 先序遍历 * * @param rootNode 根节点 */ void preOrder(Node rootNode) { if (rootNode != null) { System.out.println(&quot;key: &quot; + rootNode.key + &quot; &quot; + &quot;value: &quot; + rootNode.value); preOrder(rootNode.leftChild); preOrder(rootNode.rightChild); } } /** * 中序遍历 * * @param rootNode 根节点 */ void inOrder(Node rootNode) { if (rootNode != null) { inOrder(rootNode.leftChild); System.out.println(&quot;key: &quot; + rootNode.key + &quot; &quot; + &quot;value: &quot; + rootNode.value); inOrder(rootNode.rightChild); } } /** * 后序遍历 * * @param rootNode 根节点 */ void postOrder(Node rootNode) { if (rootNode != null) { postOrder(rootNode.leftChild); postOrder(rootNode.rightChild); System.out.println(&quot;key: &quot; + rootNode.key + &quot; &quot; + &quot;value: &quot; + rootNode.value); } }}","link":"/2018/03/19/zh/programing/basis/data_structure/tree/binary_search_tree/"},{"title":"线段树","text":"线段树/区间树（Segment tree）是一种二叉搜索树： 特点： 每个结点表示的是一个线段，或者说是一个区间。 当父节点的区间为$[x, y]$时，左孩子的区间就为$[x, \\frac{ (x + y) }{ 2 }]$，右孩子的区间就为$[\\frac{ (x + y) }{ 2 } + 1, y]$。 对于每一棵线段树上的节点，都有三个值：左区间、右区间以及权值。（在某些情况下只有左右区间，这个时候线段树只是作为维护某个值而使用的数据结构，如扫描线） 线段树主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为 O(logN）。而未优化的空间复杂度为 2N，因此有时需要离散化来压缩空间。 模版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179class SegmentTree { class Node { int left, right;// 左右区间的值 boolean cover;// 表示是否被覆盖 int count;// 表示此节点表示的线段区间出现的次数（被覆盖的次数），默认为0 Node leftChild, rightChild; Node(int left, int right) { this.left = left; this.right = right; this.count = 0; this.cover = false; } } Node root; /** * 建立一棵线段树 * * @param left 左区间 * @param right 右区间 */ void build(int left, int right) { root = new Node(left, right); build(root); } /** * 建立一棵线段树 * * @param root 根节点 */ void build(Node root) { int left = root.left; int right = root.right; // root节点为叶子节点 if (right - left == 1) { return; } else if (right - left &gt; 1) { int mid = (left + right) &gt;&gt; 1;//// 将左右区间平分 Node leftNode = new Node(left, mid); Node rightNode = new Node(mid, right); root.leftChild = leftNode; root.rightChild = rightNode; // 递归的创建左右子树 build(leftNode); build(rightNode); } } /** * 插入一条线段[left, right] * * @param left 左端点 * @param right 右端点 */ void insert(int left, int right) { insert(left, right, root); } /** * 插入一条线段[left, right] * * @param left 左端点 * @param right 右端点 * @param node 节点 */ void insert(int left, int right, Node node) { if (node == null || left &lt; node.left || right &gt; node.right) { System.out.println(&quot;输入的参数不合法!&quot; + &quot;left:&quot; + left + &quot; &quot; + &quot;right:&quot; + right); System.out.println(&quot;root:&quot; + node.left + &quot; &quot; + node.right); return; } if (node.left == left &amp;&amp; node.right == right) { node.count++; node.cover = true; return; } int mid = (node.left + node.right) &gt;&gt; 1; if (right &lt;= mid) { insert(left, right, node.leftChild); } else if (left &gt;= mid) { insert(left, right, node.rightChild); } else { insert(left, mid, node.leftChild); insert(mid, right, node.rightChild); } } /** * 删除一条线段[left, right] * * @param left 左端点 * @param right 右端点 */ void delete(int left, int right) { delete(left, right, root); } /** * 删除一条线段[left, right] * * @param left 左端点 * @param right 右端点 * @param node 节点 */ void delete(int left, int right, Node node) { if (node == null || left &lt; node.left || right &gt; node.right) { System.out.println(&quot;输入的参数不合法!&quot;); return; } if (left == node.left &amp;&amp; right == node.right) { node.count--; if (node.count == 0) { node.cover = false; } return; } int mid = (node.left + node.right) &gt;&gt; 1; if (right &lt;= mid) { delete(left, right, node.leftChild); } else if (left &gt;= mid) { delete(left, right, node.rightChild); } else { delete(left, mid, node.leftChild); // 注意不是mid+1，比如区间[1, 10]的左右两部分分别是[1, 5]，[5, 10] delete(mid, right, node.rightChild); } } /** * 前序遍历 */ void preOrder() { preOrder(root); } /** * 前序遍历 * * @param root 根节点 */ void preOrder(Node root) { if (root.right - root.left == 1) { System.out.println(&quot;[&quot; + root.left + &quot;,&quot; + root.right + &quot;]:&quot; + root.count); return; } else if (root.right - root.left &gt; 1) { System.out.println(&quot;[&quot; + root.left + &quot;,&quot; + root.right + &quot;]:&quot; + root.count); preOrder(root.leftChild); preOrder(root.rightChild); } } /** * 统计线段树中cover为true的线段的总长度 */ int count() { return count(root); } /** * 统计线段树中cover为true的线段的总长度 * * @param node 节点 */ int count(Node node) { if (node.cover == true) {// 不继续往下查找，否则会重复 return node.right - node.left; } else { if (node.right - node.left == 1) { return 0; } else { return count(node.leftChild) + count(node.rightChild); } } }} 优点 时间快，操作多 线段树的所有操作都是基于分治算法，再经过 pushUp 优化，整个算法十分稳定。比起一般的数组暴力算法，线段树是明显更优的。 结构 修改 求和 平均 线段树 O(logN) O(logN) O(logN) 前缀和 O(N) O(1) O(N/2) 普通 O(1) O(N) O(N/2) 另外，它操作多样化，比起树状数组，多了区间最值一种操作。 缺点 浪费空间 线段树一直是一棵满二叉树，所以无论如何，它所开的空间必须是四倍。但是在某些情况，线段树会浪费三倍的空间(只有一条链等)，但你又不能省掉这三倍空间，还是得苦逼的开四倍。 和树状数组比起来，一棵普通的线段树是树状数组空间的四倍。","link":"/2018/03/19/zh/programing/basis/data_structure/tree/segment_tree/"},{"title":"字典树","text":"字典树/前缀树/单词查找树/键树（Trie）： 上图表示了关键字集合 {“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。 基本性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 从第一字符开始有连续重复的字符只占用一个节点，比如上面的to，和ten，中重复的单词t只占用了一个节点。 应用： 前缀匹配 字符串检索 词频统计 字符串排序 模版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151class Trie { class Node { int num;// 有多少单词通过这个节点，即由根至该节点组成的字符串模式出现的次数 Node[] child;// 所有的子节点 boolean isEnd;// 是不是最后一个节点 char value;// 节点的值 Node() { num = 1; child = new Node[SIZE]; isEnd = false; } } int SIZE = 26; Node root; /** * 插入一个单词 * * @param str 单词 */ void insert(String str) { if (root == null) { root = new Node(); return; } if (str == null || str.length() == 0) { return; } Node node = root; char[] letters = str.toCharArray();// 将目标单词转换为字符数组 for (int i = 0, len = str.length(); i &lt; len; i++) { int pos = letters[i] - 'a'; // 如果当前节点的儿子节点中没有该字符，则构建一个TrieNode并复值该字符 if (node.child[pos] == null) { node.child[pos] = new Node(); node.child[pos].value = letters[i]; } else { // 如果已经存在，则将由根至该儿子节点组成的字符串模式出现的次数+1 node.child[pos].num++; } node = node.child[pos]; } node.isEnd = true; } /** * 计算单词前缀的数量 * * @param prefix 前缀 * @return 单词前缀的数量 */ int countPrefix(String prefix) { if (prefix == null || prefix.length() == 0) { return -1; } Node node = root; char[] letters = prefix.toCharArray(); for (int i = 0, len = prefix.length(); i &lt; len; i++) { int pos = letters[i] - 'a'; if (node.child[pos] == null) { return 0; } else { node = node.child[pos]; } } return node.num; } /** * 打印指定前缀的单词 * * @param prefix 前缀 * @return 单词 */ String hasPrefix(String prefix) { if (prefix == null || prefix.length() == 0) { return null; } Node node = root; char[] letters = prefix.toCharArray(); for (int i = 0, len = prefix.length(); i &lt; len; i++) { int pos = letters[i] - 'a'; if (node.child[pos] == null) { return null; } else { node = node.child[pos]; } } preTraverse(node, prefix); return null; } /** * 遍历经过此节点的单词 * * @param node 节点 * @param prefix 前缀 */ void preTraverse(Node node, String prefix) { if (!node.isEnd) { for (Node child : node.child) { if (child != null) { preTraverse(child, prefix + child.value); } } return; } System.out.println(prefix); } /** * 存在完全匹配的单词 * * @param str 单词 * @return boolean */ boolean has(String str) { if (str == null || str.length() == 0) { return false; } Node node = root; char[] letters = str.toCharArray(); for (int i = 0, len = str.length(); i &lt; len; i++) { int pos = letters[i] - 'a'; if (node.child[pos] != null) { node = node.child[pos]; } else { return false; } } // 走到这一步，表明可能完全匹配，可能部分匹配，如果最后一个字符节点为末端节点，则是完全匹配，否则是部分匹配 return node.isEnd; } /** * 前序遍历 * * @param node 节点 */ void preTraverse(Node node) { if (node != null) { System.out.print(node.value + &quot;-&quot;); for (Node child : node.child) { preTraverse(child); } } }}","link":"/2018/03/19/zh/programing/basis/data_structure/tree/trie/"},{"title":"MySQL 大表优化方案","text":"前言当 MySQL 单表记录数过大时，增删改查性能都会急剧下降，可以参考以下优化手段： 单表优化 读写分离 缓存 拆分 NoSQL 单表优化除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。 字段 尽量使用 TINYINT、SMALLINT、MEDIUM_INT 作为整数类型而非 INT，如果非负则加上 UNSIGNED。 VARCHAR 的长度只分配真正需要的空间。 使用枚举或整数代替字符串类型。 尽量使用 TIMESTAMP 而非 DATETIME。 单表不要有太多字段，建议在20以内。 避免使用 NULL 字段，很难查询优化且占用额外索引空间。 用整型来存 IP。（INET_ATON(EXPR)、INET_NTOA（EXPR）函数） 索引 索引并不是越多越好，要根据查询有针对性的创建，考虑在 WHERE 和 ORDER BY 命令上涉及的列建立索引，可根据 EXPLAIN 来查看是否用了索引还是全表扫描。 应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描。 值分布很稀少的字段不适合建索引，例如”性别”这种只有两三个值的字段。 字符字段只建前缀索引。 字符字段最好不要做主键。 不用外键，由程序保证约束。 尽量不用 UNIQUE，由程序保证约束。 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引。 SQL 可通过开启慢查询日志来找出较慢的 SQL。 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边。 SQL 语句尽可能简单：一条 SQL 只能在一个 CPU 运算；大语句拆小语句，减少锁时间；一条大 SQL 可能堵死整个库。 不用 SELECT *。 OR 改成 IN（OR 的效率是 n 级别，IN 的效率是 log(n) 级别， IN 的个数建议控制在200以内）。 不用函数和触发器，在应用程序实现。 避免 %xxx 查询。 少用 JOIN。 使用同类型进行比较，比如用 ‘123’ 和 ‘123’ 比，123 和 123 比。 尽量避免在 WHERE 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。 对于连续数值，使用 BETWEEN 而非 IN，比如 SELECT id FROM t WHERE num BETWEEN 1 AND 5。 列表数据不要拿全表，要使用 LIMIT 来分页，每页数量也不要太大。 引擎目前广泛使用的是 MyISAM 和 InnoDB 两种引擎。 MyISAM 适合 SELECT 密集型的表，而 InnoDB 适合 INSERT 和 UPDATE 密集型的表。 MyISAMMyISAM 引擎是 MySQL 5.1 及之前版本的默认引擎，特点： 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁 不支持事务 不支持外键 不支持崩溃后的安全恢复 在表有读取查询的同时，支持往表中插入新纪录 支持 BLOB 和 TEXT 的前500个字符索引，支持全文索引 支持延迟更新索引，极大提升写入性能 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用 InnoDBInnoDB 是 MySQL 5.5 之后的默认引擎，特点： 支持行锁，采用 MVCC 来支持高并发 支持事务 支持外键 支持崩溃后的安全恢复 不支持全文索引 调优参数可以使用下面几个工具来做基准测试： sysbench：一个模块化，跨平台以及多线程的性能测试工具 iibench-mysql：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具 tpcc-mysql：Percona 开发的 TPC-C 测试工具 具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数： back_log：出在 MySQL 暂停时回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果 MySql 的连接数据达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过 back_log，将不被授予连接资源。【可以从默认的50升至500】 wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。【可以从默认的8小时减到半小时】 max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限。 thread_concurrency：并发线程数，设为CPU核数的两倍。 skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问。 key_buffer_size：索引块的缓存大小，增大可提升索引处理速度，对 MyISAM 表性能影响最大。对于内存4G左右，可设为 256M 或 384M，通过查询 show status like 'key_read%'，保证 key_reads / key_read_requests 在 0.1% 以下最好。 innodb_buffer_pool_size：缓存数据块和索引块，对 InnoDB 表性能影响最大。通过查询 show status like 'Innodb_buffer_pool_read%'，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests 越高越好。 innodb_additional_mem_pool_size：InnoDB 存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL 会记录 Warning 信息到数据库的错误日志中，这时就需要该调整这个参数大小。 innodb_log_buffer_size：InnoDB 存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB。 query_cache_size：缓存 MySQL 中的 ResultSet，也就是一条 SQL 语句执行的结果集，所以仅仅只能针对 select 语句。当某个表的数据有任何变化，都会导致所有引用了该表的 select 语句在 Query Cache 中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用 Query Cache 可能会得不偿失。根据命中率 Qcache_hits / (Qcache_hits + Qcache_inserts) * 100 进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大，可以通过命令 show status like 'Qcache_%' 查看目前系统 Query Cache 使用大小。 read_buffer_size：MySql 读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql 会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能。 sort_buffer_size：MySql 执行排序使用的缓冲大小。如果想要增加 ORDER BY 的速度，首先看是否可以让 MySQL 使用索引而不是额外的排序阶段。如果不能，可以尝试增加 sort_buffer_size 变量的大小。 read_rnd_buffer_size：MySql 的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但 MySql 会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。 record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值。 thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的。 table_cache：类似于 thread_cache_size，但用来缓存表文件，对 InnoDB 效果不大，主要用于 MyISAM。 升级硬件根据 MySQL 是 CPU 密集型还是 I/O 密集型，通过提升 CPU 和内存、使用 SSD，都能显著提升 MySQL 性能。 读写分离从库读、主库写，一般不采用双主或多主来增大复杂性，尽量采用文中的其他方案来提高性能。目前很多拆分的解决方案兼顾了读写分离。 缓存缓存可以发生在这些层次： MySQL 内部：在系统调优参数介绍了相关设置。 数据访问层：比如 MyBatis 针对 SQL 语句做缓存，而 Hibernate 可以精确到单个记录，这里缓存的对象主要是持久化对象 Persistence Object。 应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象 Data Transfer Object。 Web 层：针对 Web 页面做缓存。 浏览器客户端：用户端的缓存。 可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式： 直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是大多数应用缓存框架的工作方式，比如 Spring Cache。实现简单，同步好，但效率一般。 回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。实现复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率高。 表分区MySQL 5.1 引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。 对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对 SQL 层来说是一个完全封装底层的黑盒子。MySQL 实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。 用户的 SQL 语句需要针对分区表做优化，条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区。 可以通过 EXPLAIN PARTITIONS 来查看某条 SQL 语句会落在那些分区上，从而进行 SQL 优化，如下5条记录落在 p1,p4 两个分区上： 1234567891011121314mysql&gt; explain partitions select count(1) from user_partition where id in (1,2,3,4,5)\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_partition partitions: p1,p4 type: rangepossible_keys: PRIMARY key: PRIMARY key_len: 8 ref: NULL rows: 5 Extra: Using where; Using index1 row in set (0.00 sec) 优点 可以让单表存储更多的数据。 分区表的数据更容易维护，可以通过清除整个分区来批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作。 部分查询能够从查询条件确定只落在少数分区上，速度会很快。 分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备。 可以使用分区表赖避免某些特殊瓶颈，例如 InnoDB 单个索引的互斥访问、ext3 文件系统的 inode 锁竞争。 可以备份和恢复单个分区。 缺点 一个表最多只能有1024个分区。 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。 分区表无法使用外键约束。 NULL 值会使分区过滤无效。 所有分区必须使用相同的存储引擎。 分区类型 RANGE 分区：基于属于一个给定连续区间的列值，把多行分配给分区。 LIST 分区：类似 RANGE 分区，区别在于 LIST 分区是基于列值匹配一个离散值集合中的某个值来进行选择。 HASH 分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含 MySQL 中有效的、产生非负整数值的任何表达式。 KEY 分区：类似 HASH 分区，区别在于 KEY 分区只支持计算一列或多列，且 MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。 适用场景 时间序列性比较强，则可以按时间来分区：（查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容易地批量删除） 1234567891011121314CREATE TABLE members ( firstname VARCHAR(25) NOT NULL, lastname VARCHAR(25) NOT NULL, username VARCHAR(16) NOT NULL, email VARCHAR(35), joined DATE NOT NULL)PARTITION BY RANGE( YEAR(joined) ) ( PARTITION p0 VALUES LESS THAN (1960), PARTITION p1 VALUES LESS THAN (1970), PARTITION p2 VALUES LESS THAN (1980), PARTITION p3 VALUES LESS THAN (1990), PARTITION p4 VALUES LESS THAN MAXVALUE); 数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存。 垂直拆分垂直分库是根据数据库里面的数据表的相关性进行拆分。垂直分表是对数据表进行垂直拆分的一种方式。常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，使用主键关联。 比如，一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。 比如，原始的用户表： 垂直拆分后： 优点 行数据变小，一个数据块（Block）就能存放更多的数据，在查询时就能减少 I/O（每次查询时读取的 Block 就少）。 最大化利用 Cache，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起。 数据维护简单。 缺点 主键出现冗余，需要管理冗余列。 会引起表连接 JOIN 操作，增加 CPU 开销，可以通过在业务服务器上进行 JOIN 来减少数据库压力。 依然存在单表数据量过大的问题（需要水平拆分）。 事务处理复杂。 水平拆分水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的 MySQL 表或库，达到分布式的效果，能够支持非常大的数据量。表分区本质上也是一种特殊的库内分表。 库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻 MySQL 服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的 IO、CPU、网络，这个就要通过分库来解决 前面的用户表如果进行水平拆分（按用户名首字母）： 实际情况中往往是结合垂直拆分和水平拆分，比如将 Users_A_M 和 Users_N_Z 再拆成 Users 和 UserExtras，这样一共四张表。 优点 不存在单库大数据和高并发的性能瓶颈。 应用端改造较少。 提高了系统的稳定性和负载能力。 缺点 分片事务一致性难以解决。 跨节点 Join 性能差，逻辑复杂。 数据多次扩展难度跟维护量极大。 分片原则 能不分就不分，参考单表优化。 分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。 分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性 Hash 分片，这几种分片都有利于扩容。 尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题。 查询条件尽量优化，尽量避免 Select * 的方式，大量数据结果集下，会消耗大量带宽和 CPU 资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。 通过数据冗余和表分区赖降低跨库 Join 的可能。 这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。 总体上来说，分片的选择是取决于最频繁的查询 SQL 的条件，因为不带任何 Where 语句的查询 SQL，会遍历所有的分片，性能相对最差，因此这种 SQL 越多，对系统的影响越大，所以我们要尽量避免这种 SQL 的产生。 解决方案 由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。 客户端架构 通过修改数据访问层，如 JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以 Jar 包的方式呈现。 客户端架构例子： 可以看到分片的实现是和应用服务器在一起的，通过修改 Spring JDBC 层来实现。 优点： 应用直连数据库，降低外围系统依赖所带来的宕机风险。 集成成本低，无需额外运维的组件。 缺点： 限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心。 将分片逻辑的压力放在应用服务器上，造成额外风险。 代理架构 通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件。 代理架构例子： 代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要 Zookeeper 之类的服务组件来管理。 优点： 能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强。 对于应用服务器透明且没有增加任何额外负载。 缺点： 需部署和运维独立的代理中间件，成本高。 应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险。 NoSQL在 MySQL 上做 Sharding 是一种戴着镣铐的跳舞，事实上很多大表本身对 MySQL 这种 RDBMS 的需求并不大，并不要求 ACID，可以考虑将这些表迁移到 NoSQL，彻底解决水平扩展问题。 日志类、监控类、统计类数据。 非结构化或弱结构化数据。 对事务要求不强，且无太多关联操作的数据。","link":"/2018/07/22/zh/programing/basis/database/mysql/large_table_optimization_scheme/"},{"title":"数据库","text":"Mysql数据库三范式第一范式（1NF） 无重复的列：数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。 举例1：一张学生表Student(stuNo,stuName,age,age,sex)是不符合第一范式的，因为有重复列age属性。去除重复列age以后的Student(stuNo,stuName,age,sex)是符合第一范式的。 第二范式（2NF） 属性完全依赖于主键【消除部分子函数依赖】：数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是属性完全依赖于主键。 这里说的主关键字可能不只有一个，有些情况下是存在联合主键的，就是主键有多个属性。 第三范式（3NF） 属性不依赖于其它非主属性【消除传递依赖】：一个数据库表中不包含已在其它表中已包含的非主关键字信息。 InnoDB 和 MyISAM 存储引擎的区别基本区别： MyISAM 类型不支持事务处理等高级处理，而 InnoDB 类型支持、外键、行级锁等高级数据库功能。 MyISAM 类型的表强调的是性能，其执行速度比 InnoDB 类型更快。 具体区别： InnoDB 不支持 FULLTEXT 类型的索引。 InnoDB 中不保存表的具体行数，也就是说，执行 select count( * ) from table 时，InnoDB 要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意：当count( * ) 语句包含 where 条件时，两种表的操作是一样的。 对于 AUTO_INCREMENT 类型的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中，可以和其他字段一起建立联合索引。 DELETE FROM table 时，InnoDB 不会重新建立表，而是一行一行的删除。 LOAD TABLE FROM MASTER 操作对 InnoDB 是不起作用的，解决方法是首先把 InnoDB 表改成 MyISAM 表，导入数据后再改成 InnoDB 表，但是对于使用的额外的 InnoDB 特性(例如外键)的表不适用。 InnoDB 表的行锁也不是绝对的，假如在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围， InnoDB 表同样会锁全表，例如 update table set num=1 where name like “%aaa%” 索引分类（主键、唯一索引、全文索引、覆盖索引等等），最左前缀原则，哪些条件无法使用索引数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引付出的代价： 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 优点： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 一般来说，应该在这些列上创建索引： 经常需要搜索的列上，可以加快搜索的速度。 作为主键的列，强制该列的唯一性和组织表中数据的排列结构。 经常用在连接的列，这些列主要是一些外键，加快连接的速度。 经常需要根据范围进行搜索的列，因为索引已经排序，其指定的范围是连续的。 经常需要排序的列，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询速度。 经常使用在WHERE子句中的列，加快条件的判断速度。 一般来说，不应该创建索引的的这些列具有下列特点： 查询中很少使用或者参考的列。 只有很少数据值的列。因为这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 当修改性能远远大于检索性能时。因为修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。 三种索引：唯一索引、主键索引和聚集索引 唯一索引：唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引：数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 B树、B+树区别，索引为何使用B+树根据B-Tree的定义，可知检索一次最多需要访问h个节点。利用磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。 为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 综上所述，用B-Tree作为索引结构效率是非常高的。 聚集索引与非聚集索引（使用非聚集索引的查询过程）事务的ACID（原子性、一致性、隔离性、持久性）原子性（Atomicity）：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性（Correspondence）：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。（实体完整性、参照完整性、用户自定义完整性） 隔离性（Isolation）：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性（Durability）：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 7.事务隔离级别和各自存在的问题（脏读、不可重复读、幻读）和解决方式（间隙锁及MVCC） 8.乐观锁和悲观锁、行锁与表锁、共享锁与排他锁（inndob如何手动加共享锁与排他锁）如果现在只有一张火车票，怎么让所有人都看见但是只有一个人能购买成功 (这里就是悲观锁乐观锁的应用处理并发问题) 9.MVCC（增加两个版本号）及delete、update、select时的具体控制 10.死锁判定原理和具体场景 11.查询缓慢和解决方式（explain、慢查询日志、show profile等） drop、truncate、delete区别基本区别： drop 直接删掉表； truncate 删除表中数据，再插入时自增长 id 又从1开始； delete 删除表中数据，可以加 where 字句。 具体区别： delete 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。truncate 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。 表和索引所占空间。当表被 truncate 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。 一般而言，drop &gt; truncate &gt; delete 应用范围。truncate 只能对 table，delete 可以是 table 和 view truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。 truncate 与不带 where 的 delete：只删除数据，而不删除表的结构（定义）。 drop 将删除表的结构被依赖的约束（constrain)、触发器（trigger)、索引（index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。 delete 是 DML（data maintain Language)，这个操作会被放到 rollback segment中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发。 truncate、drop 是 DLL（data define language)，操作立即生效，原数据不放到 rollback segment中，不能回滚。 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合 where 来约束影响范围。回滚段要足够大。要删除表用 drop；若想保留表而将表中数据删除，且与事务无关，用 truncate 即可实现；如果与事务有关，或想触发 trigger，还是用 delete。 truncate 速度快,而且效率高,因为 truncate 在功能上与不带 where 子句的 delete 语句相同：二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，并在事务日志中为所删除的每行记录一项。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop 语句。 对于由 FOREIGN KEY 约束引用的表，不能使用 truncate，而应使用不带 where 子句的 delete 语句。由于 truncate 不记录在日志中，所以它不能激活触发器。 查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序集合查询有哪些union：并操作intersect：交操作except：差操作 union 查询计算机系的所有学生和年龄大于19岁的学生的并集： 123SELECT * FROM student WHERE dept='CS'UNIONSELECT * FROM student WHERE age &gt; 19; 等价于： 12SELECT * FROM studentWHERE dept='CS' OR age &gt; 19; intersect 查询计算机系中年龄大于19岁的学生： 123SELECT * FROM student WHERE dept='CS'INTERSECTSELECT * FROM student WHERE age &gt; 19; 等价于： 12SELECT * FROM studentWHERE dept='CS' AND age &gt; 19; except 查询计算机系中年龄大于19岁的学生： 123SELECT * FROM student WHERE dept='CS'EXCEPTSELECT * FROM student WHERE age &lt;= 19; 等价于： 12SELECT * FROM studentWHERE dept='CS' AND age &gt; 19; 注意：MySQL 中没有求交集和差集的功能，只能用其他关键字达到类似功能。 求交集： 123SELECT a.member_id, a.name FROM aINNER JOIN bUSING (member_id, name); 求差集： 12SELECT t1.* FROM t1WHERE name NOT IN (SELECT name FROM t2); UNION 和 UNION ALL 的区别UNION 将多个查询结果合并起来，系统自动去掉重复元组，在排序时会按照字段的顺序。UNION ALL 则会保留重复的元组，在排序时只是简单的将两个结果合并后就返回。 MYSQL 优化，读写分离、主从复制数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）Redis发布订阅数据淘汰机制（好几种）字典及渐进式rehashRDB与AOF为何高效（内存数据库、非阻塞IO、IO多路复用、单线程、hash表、跳表等）Redis的几种数据结构","link":"/2018/02/14/zh/programing/basis/database/mysql/mysql/"},{"title":"MySQL 各种连接","text":"准备工作MySQL 版本：10.1.29-MariaDB-6+b1 建表 SQL： 1234567891011CREATE TABLE `a_table` ( `a_id` int(11) DEFAULT NULL, `a_name` varchar(10) DEFAULT NULL, `a_part` varchar(10) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `b_table` ( `b_id` int(11) DEFAULT NULL, `b_name` varchar(10) DEFAULT NULL, `b_part` varchar(10) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8; 测试数据 SQL： 123INSERT INTO `a_table` VALUES (1, 'A', '总裁部'), (2, 'B', '秘书部'), (3, 'C', '设计部'), (4, 'D', '运营部');INSERT INTO `b_table` VALUES (2, 'B', '秘书部'), (3, 'C', '设计部'), (5, 'E', '人事部'), (6, 'F', '生产部'); 表数据： 123456789101112131415161718MariaDB [test]&gt; SELECT * FROM a_table;+------+--------+--------+| a_id | a_name | a_part |+------+--------+--------+| 1 | A | 总裁部 || 2 | B | 秘书部 || 3 | C | 设计部 || 4 | D | 运营部 |+------+--------+--------+MariaDB [test]&gt; SELECT * FROM b_table;+------+--------+--------+| b_id | b_name | b_part |+------+--------+--------+| 2 | B | 秘书部 || 3 | C | 设计部 || 5 | E | 人事部 || 6 | F | 生产部 |+------+--------+--------+ 内连接关键字：inner join on 语句： 12SELECT * FROM a_table aINNER JOIN b_table b ON a.a_id = b.b_id; 123456+------+--------+--------+------+-------+---------+| a_id | a_name | a_part | b_id | b_name | b_part |+------+--------+--------+------+-------+---------+| 2 | B | 秘书部 | 2 | B | 秘书部 || 3 | C | 设计部 | 3 | C | 设计部 |+------+--------+--------+------+-------+---------+ 说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。 左（外）连接关键字：LEFT JOIN ON / LEFT OUTER JOIN ON 语句： 12SELECT * FROM a_table aLEFT JOIN b_table b ON a.a_id = b.b_id; 12345678+------+--------+--------+------+--------+--------+| a_id | a_name | a_part | b_id | b_name | b_part |+------+--------+--------+------+--------+--------+| 2 | B | 秘书部 | 2 | B | 秘书部 || 3 | C | 设计部 | 3 | C | 设计部 || 1 | A | 总裁部 | NULL | NULL | NULL || 4 | D | 运营部 | NULL | NULL | NULL |+------+--------+--------+------+--------+--------+ 说明：左（外）连接，左表（a_table）的记录将会全部表示出来，而右表（b_table）只会显示符合搜索条件的记录。右表记录不足的地方均为 NULL。 右（外）连接关键字：RIGHT JOIN ON / RIGHT OUTER JOIN ON 语句： 12SELECT * FROM a_table aRIGHT JOIN b_table b ON a.a_id = b.b_id; 12345678+------+--------+--------+------+--------+--------+| a_id | a_name | a_part | b_id | b_name | b_part |+------+--------+--------+------+--------+--------+| 2 | B | 秘书部 | 2 | B | 秘书部 || 3 | C | 设计部 | 3 | C | 设计部 || NULL | NULL | NULL | 5 | E | 人事部 || NULL | NULL | NULL | 6 | F | 生产部 |+------+--------+--------+------+--------+--------+ 说明：与左（外）连接相反，右（外）连接，左表（a_table）只会显示符合搜索条件的记录，而右表（b_table）的记录将会全部表示出来。左表记录不足的地方均为 NULL。 全（外）连接MySQL 目前不支持此种方式，可以用其他方式替代解决。 如何执行关联查询MySQL 认为任何一个查询都是一次“关联”，并不仅仅是一个查询需要到两个表匹配才叫关联，所以在 MySQL 中，每一个查询，每一个片段（包括子查询，甚至基于单表查询）都可以是一次关联。 当前 MySQL 关联执行的策略很简单：MySQL 对任何关联都执行嵌套循环关联操作，即 MySQL 先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。 例子： 查询语句： 1SELECT tbl1.col1, tbl2.col2 FROM tbl1 INNER JOIN tbl2 USING(col3) WHERE tbl1.col1 IN (5, 6); 假设 MySQL 按照查询中的表顺序进行关联操作，我们则可以用下面的伪代码表示 MySQL 将如何完成这个查询： 1234567891011outer_iter = iterator over tbl1 where col1 in (5, 6)outer_row = outer_iter.nextwhile outer_row inner_iter = iterator over tbl2 where col3 = outer_row.col3 inner_row = inner_iter.next while inner_row output [ outer_row.col1, inner_row.col2] inner_row = inner_iter.next end outer_row = outer_iter.nextend 上面的执行计划对于单表查询和多表关联查询都适用，如果是一个单表查询，那么只需要上面外层的基本操作。对于外连接，上面的执行过程仍然适用。例如，我们将上面的查询语句修改如下： 1SELECT tbl1.col1, tbl2.col2 FROM tbl1 LEFT OUTER JOIN tbl2 USING(col3) WHERE tbl1.col1 IN (5, 6); 那么，对应的伪代码如下： 123456789101112131415outer_iter = iterator over tbl1 where col1 in (5, 6)outer_row = outer_iter.nextwhile outer_row inner_iter = iterator over tbl2 where col3 = outer_row.col3 inner_row = inner_iter.next if inner_row while inner_row output [ outer_row.col1, inner_row.col2] inner_row = inner_iter.next end else output [ outer_row.col1, null] end outer_row = outer_iter.nextend","link":"/2018/10/31/zh/programing/basis/database/mysql/mysql_join/"},{"title":"MySQL Workbench export ER image","text":"Debian 下安装：sudo apt install mysql-workbench 连接数据库：菜单栏 Database -&gt; Connect to Database 逆向引擎：菜单栏 Database -&gt; Reverse Engineer 选择要逆向的数据库 一直 next，最后 excute，可以看到已经生成的 ER 图 文件导出：菜单栏 File -&gt; Export","link":"/2018/03/04/zh/programing/basis/database/mysql/workbench_export_er/"},{"title":"《算法导论》笔记1-2","text":"前言系统地过一遍《算法导论》，理清之前做题时的混乱思路。 伪代码均以类似 Python 的形式书写。 算法基础插入排序（insertion sort）伪代码： 123456789insert_sort(A) for j in range(1, A.length) value = A[j] # 将 A[j] 插到排好序的 A[0 ... j - 1] i = j - 1 while i &gt;= 0 and A[i] &gt; value A[i + 1] = A[i] i-- A[i + 1] = value 举个栗子： 假设手上有一副牌 A = {5, 2, 4, 6, 1, 3}，插入排序的步骤就是：从第二张牌 2 开始，前面的 5 和 2 比较，因为 5 &gt; 2，所以 2 插到 5 前面；此时牌序为 {2, 5, 4, 6, 1, 3}，因为 2 已经在最前面，所以下一轮。 {2, 5, 4, 6, 1, 3}从第三张牌 4 开始，前面的 5 和 4 比较，因为 5 &gt; 4，所以 4 插到 5 前面；此时牌序为 {2, 4, 5, 6, 1, 3}，因为前面的牌都有序了，下一轮。 {2, 4, 5, 6, 1, 3}从第四张牌 6 开始，前面的牌都有序了，下一轮。 {2, 4, 5, 6, 1, 3}从第五张牌 1 开始，前面的牌都有序了，并且都比 1 大，所以 1 插到最前面；此时牌序为 {1, 2, 4, 5, 6, 3}，下一轮。 {1, 2, 4, 5, 6, 3}从最后一张即第六张牌 3 开始，前面的牌都有序了，并且 3 比 4 小，所以 3 插到 4 前面，结束。 事实上，元素 A[0 … j - 1] 就是原来在位置 0 到 j - 1 的元素，但现在已按序排好，我们把 A[0 … j - 1] 的这些性质形式地表示为循环不变式。 关于循环不变式，我们必须证明三条性质：初始化：循环的第一次迭代之前，它为真。保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。终止：在循环终止前，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。详细的证明过程请看书。 Java 代码： 1234567891011121314151617/** * 插入排序 * int[] A = { 5, 2, 4, 6, 1, 3 }; * * @param A 数组 */void insertSort(int[] A) { for (int j = 1; j &lt; A.length; j++) { int value = A[j]; int i = j - 1; while (i &gt;= 0 &amp;&amp; A[i] &gt; value) { A[i + 1] = A[i]; i--; } A[i + 1] = value; }} 分治法许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归调用其自身以解决紧密相关的若干子问题。这些算法典型地遵循分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 分支模式在每层递归时都有三个步骤： 分解（divide）原问题为若干子问题，这些子问题是原问题的规模较小的实例。 解决（conquer）这些子问题，递归地求解各个子问题。然而，若子问题的规模足够小，则直接求解。 合并（combine）这些子问题的解成原问题的解。 归并排序算法完全遵循分治模式。直观上其操作如下：分解：分解待排序的 n 个元素的序列成各具 n/2 个元素的子序列。解决：使用归并排序递归地排序两个子序列。合并：合并两个已排序的子序列以产生已排序的答案。 归并排序的关键是合并步骤中的两个已排序序列的合并。我们通过调用一个辅助过程 merge(A, low, mid, high) 来完成合并，其中 A 为数组，low、mid 和 high 是数组下标，满足 low &lt;= mid &lt; high。该过程假设子数组 A[low … mid] 和 A[mid + 1 … high] 都已经排好序。它合并这两个子数组形成单一的已排好序的子数组并代替当前的子数组 A[low … high]。 举个栗子： 假设桌上有两堆牌面朝上的牌，并且每堆都已排好序，最小的牌在最上面。现在我们希望把这两堆牌合并成一个排好序的输出堆，牌面朝下地放在桌上。合并的步骤就是： 从两堆牌的最上面两张牌中拿掉小的那张，并把它牌面朝下地放到输出堆。 重复上面的步骤，直到其中一个输入堆空了，这时，我们只用拿起另一个输入堆的牌，并牌面朝下的放到输出堆。 伪代码： 1234567891011121314151617181920212223242526merge(A, low, mid, high) # 左堆牌的牌数 nL = mid - low + 1 # 右堆牌的牌数 nR = high - mid # 新建两堆牌 # 两堆牌还要各加入一张哨兵牌 L = [0 ... nL + 1] R = [0 ... nR + 1] # 复制左右区间 for i in range(0, nL) L[i] = A[low + i] for i in range(0, nR) R[i] = A[mid + i + 1] # 为了避免每个步骤都检查有堆为空，在每个堆底部都放一张无限大的牌（即哨兵牌） # 因为无限大，所以其中一堆空时，只能从另外的堆拿小的牌 L[nL] = MAX R[nR] = MAX i = j = 0 for k in range(low, high + 1) if L[i] &lt;= R[j] A[k] = L[i] i++ else A[k] = R[j] j++ 现在，我们就可以将合并过程作为归并排序算法中的一个子程序来用了。 merge_sort(A, low, high) 将归并排序子数组 A[low … high] 中的元素： 若 low == high，则子数组最多有一个元素，即已经排好序。 否则，分解步骤简单地计算一个下标 q，将 A[low … high] 分成两个子数组 A[low … mid] 和 A[mid + 1 … high]。 伪代码： 1234567merge_sort(A, low, high) if low &lt; high # 小于或等于的最大整数 mid = [(low + high) / 2] merge_sort(A, low, mid) merge_sort(A, mid + 1, high) merge(A, low, mid, high) Java 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 归并排序 * int[] A = { 5, 2, 4, 6, 1, 3 }; * mergeSort(A, 0, 5); * * @param A 数组 * @param low 开始下标 * @param high 结束下标 */void mergeSort(int[] A, int low, int high) { if (low &lt; high) { int mid = (low + high) / 2; mergeSort(A, low, mid); mergeSort(A, mid + 1, high); merge(A, low, mid, high); }}/** * 合并 * * @param A 数组 * @param low 开始下标 * @param mid 中间下标 * @param high 结束下标 */void merge(int[] A, int low, int mid, int high) { int nL = mid - low + 1; int nR = high - mid; int[] L = new int[nL + 1]; int[] R = new int[nR + 1]; for (int i = 0; i &lt; nL; i++) { L[i] = A[low + i]; } for (int i = 0; i &lt; nR; i++) { R[i] = A[mid + i + 1]; } L[nL] = Integer.MAX_VALUE; R[nR] = Integer.MAX_VALUE; for (int i = 0, j = 0, k = low; k &lt;= high; k++) { if (L[i] &lt;= R[j]) { A[k] = L[i]; i++; } else { A[k] = R[j]; j++; } }} 不用哨兵，重写 merge，使之一旦数组 L 或 R 的所有元素均被复制到 A 就立刻停止，然后把另一个数组的剩余部分复制回 A。 伪代码： 12345678910111213141516171819merge(A, low, mid, high) nL = mid - low + 1 nR = high - mid L = [0 ... nL] R = [0 ... nR] for i in range(0, nL) L[i] = A[low + i] for i in range(0, nR) R[i] = A[mid + i + 1] i = j = 0 for k in range(low, high + 1) # 左堆牌还能拿 # 右堆牌拿完 或 左堆牌顶上牌比较小 if i &lt; nL and (j == nR or L[i] &lt;= R[j]) A[k] = L[i] i++ elif j &lt; nR and (i == nL or L[i] &gt; R[j]) A[k] = R[j] j++ 练习题逆序对假设 A[n] 是一个有 n 个不同数的数组。若 i &lt; j 且 A[i] &gt; A[j] ，则称 (i, j) 是 A 的一个逆序对。 列出数组 {2, 3, 8, 6, 1} 的 5 个逆序对。 由集合 {1, 2, …, n} 中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？ 给出一个确定在 n 个元素的任何排列中逆序对数量的算法，最坏情况需要 O(nlgn) 时间。（提示：修改归并排序） 答： {2, 1}、{3, 1}、{8, 6}、{8, 1}、{6, 1} {n, n - 1, …, 1} 具有最多的逆序对，有 (n - 1)! 个逆序对。 伪代码： 1","link":"/2018/03/26/zh/programing/book_read/algorithms/introduction_to_algorithms/1-2/"},{"title":"《算法导论》笔记1-4","text":"分治策略最大子数组问题假设让你买一支股票，并且你已经知道未来 17 天的走势，要求最大化收益。 什么时候收益最大？当然是最低价买进，最高价卖出。如果这种策略有效的话，那么确定最大化收益的方法就是： 找到最高和最低价。 从最高价开始向左找最低价，从最低价开始向右找最高价。 取两对价格中差值最大的。 以上面走势为例就是： 最高价在第 2 天为 113 元，最低价在第 8 天为 63 元。 [1, 2] 差值为 13 元，[8, 12] 差值为 43 元。 但是该策略有问题，比如： 股票走势只给 5 天，按照上面的策略，应该买 [1, 2]，差值是 1 元。但很明显最大收益是 [2, 3]，差值为 3 元，所以不使用这种策略。 当然，可以使用暴力法，求出所有可能的买进卖出组合，只要卖出日期在买入日期即可。但是这种求法的运行时间太长，需要 Ω(n^2)。 问题转换：为了设计出运行时间为 O(n^2) 的算法，我们就要从另一个角度看待输入的数据，就是从观察每日价格转为观察每日的价格变化，对于第 i 天的价格变化，定义为第 i 天和第 i - 1 天的价格差。 比如上面的每天股票走势，就转换成： 如果把这行价格变化看做一个数组 A，那么求最大收益就转换成：在数组 A 中找出和最大的非空连续数组，这个连续子数组就称为最大子数组。比如这里的最大子数组就是 A[8 … 11]，它的和是 43。 只有当数组中包含负数时，最大子数组问题才有意义。（如果所有元素都是正数，那最大子数组显然就是整个数组） 使用分支策略的求解方法：如果我们要找子数组 A[low … high] 的最大子数组，那么使用分治策略就意味着我们要将子数组划分成两个规模尽量相等的子数组 A[low … mid] 和 A[mid + 1 … high]。 对于 A[low … high] 来说，它的任意连续子数组 A[i … j] 所处的位置必然是以下三种情况： 完全位于子数组 A[low … mid] 中，因此 low &lt;= i &lt;= j &lt;= mid。 完全位于子数组 A[mid + 1 … high] 中，因此 mid &lt; i &lt;= j &lt;= high。 跨越了中点，因此 low &lt;= i &lt;= mid &lt; j &lt;= high。 那么，最大子数组肯定也是这三种情况之一。即这三种情况中子数组和最大的就是最大子数组，所以可以递归求解 A[low … mid] 和 A[mid + 1 … high] 的最大子数组，然后再找跨越中点的最大子数组，最后在它们中选和最大的。 对于第三种情况，我们可以很容易地在线性时间（相对于子数组 A[low … high]的规模）内求出跨越中点的最大子数组，就是找出左区间最大和及其所到的下标，右区间同样操作。它们的解合并起来就是跨越中点时，最大子数组的起始和末尾位置，以及最大和。 找跨越中点的最大子数组的伪代码： 123456789101112131415161718find_max_crossing_subarray(A, low, mid, high) left_sum = MIN sum = 0 # 从 mid 到 low 找左区间的最大和，下标 for i in range(low, mid, -1) sum += A[i] if sum &gt; left_sum left_sum = sum max_left = i right_sum = MIN sum = 0 # 找右区间的最大和，下标 for i in range(mid + 1, high) sum += A[i] if sum &gt; right_sum right_sum = sum max_right = i return (max_left, max_right, left_sum + right_sum) 有了线性时间的 find_max_crossing_subarray，就可以设计求解最大数组问题的分治算法的伪代码了： 1234567891011121314151617find_max_subarray(A, low, high) # 只有一个元素 if low == high return (low, high, A[low]) mid = [(low + high) / 2] left_low, left_high, left_sum = find_max_subarray(A, low, mid) right_low, right_high, right_sum = find_max_subarray(A, mid + 1, high) cross_low, cross_high, cross_sum = find_max_crossing_subarray(A, low, mid, high) # 找到三种情况中最大的 if left_sum &gt;= right_sum and left_sum &gt;= cross_sum return (left_low, left_right, left_sum) elif right_sum &gt;= left_sum and right_sum &gt;= cross_sum return (right_low, right_right, right_sum) else return (cross_low, cross_high, cross_sum) Java 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 找到跨越中点的最大子数组 * * @param A 子数组A * @param low 起始下标 * @param high 终止下标 * @return {起始下标, 终止下标, 最大和} */int[] findMaxCrossingSubArray(int[] A, int low, int mid, int high) { int leftSum = Integer.MIN_VALUE, maxLeft = 0; int sum = 0; for (int i = mid; i &gt;= low; i--) { sum += A[i]; if (sum &gt; leftSum) { leftSum = sum; maxLeft = i; } } int rightSum = Integer.MIN_VALUE, maxRright = 0; sum = 0; for (int i = mid + 1; i &lt;= high; i++) { sum += A[i]; if (sum &gt; rightSum) { rightSum = sum; maxRright = i; } } return new int[] { maxLeft, maxRright, leftSum + rightSum };}/** * 找到最大子数组 * * @param A 子数组A * @param low 起始下标 * @param high 终止下标 * @return {起始下标, 终止下标, 最大和} */int[] findMaxSubArray(int[] A, int low, int high) { if (low == high) return new int[] { low, high, A[low] }; int mid = (low + high) / 2; int[] f1 = findMaxSubArray(A, low, mid); int leftLow = f1[0], leftHigh = f1[1], leftSum = f1[2]; int[] f2 = findMaxSubArray(A, mid + 1, high); int rightLow = f2[0], rightHigh = f2[1], rightSum = f2[2]; int[] f3 = findMaxCrossingSubArray(A, low, mid, high); int crossLow = f3[0], crossHigh = f3[1], crossSum = f3[2]; if (leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum) { return new int[] { leftLow, leftHigh, leftSum }; } else if (rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum) { return new int[] { rightLow, rightHigh, rightSum }; } else { return new int[] { crossLow, crossHigh, crossSum }; }} 矩阵乘法的 Strassen 算法矩阵乘法你应该了解过，下面是它的伪代码： 123456789square_matrix_multiply(A, B) n = A.rows C = [n][n] for i in range(1, n) for j in range(1, n) c[i][j] = 0 for k in range(1, n) c[i][j] += a[i][k] * b[k][j] return C 而使用 Strassen 算法求矩阵乘法只用 O(n^2.81) 的时间复杂度。 一个简单的分治算法： 为了简单说明，当使用分治算法计算 C = A x B 时，假定三个矩阵均为 n x n 矩阵，其中 n 为 2 的幂。做出这个假设是因为每个分解步骤中，n x n 矩阵都被划分为 4 个 n/2 x n/2 的子矩阵，假定 n 是 2 的幂，那么只要 n &gt;= 2 即可保证子矩阵规模 n/2 为整数。 假定将 A、B 和 C 均分解为 4 个 n/2 x n/2 的子矩阵： 123456789101112A = |A11, A12| B = |B11, B12| C = |C11, C12| |A21, A22| |B21, B22| |C21, C22|因此可以将 C = A x B 改写成：|C11, C12| = |A11, A12| x |B11, B12||C21, C22| |A21, A22| |B21, B22|等价于：C11 = A11 x B11 + A12 x B21C12 = A11 x B12 + A12 x B22C21 = A21 x B11 + A22 x B21C22 = A21 x B12 + A22 x B22 利用上面的等价公式，为我们可以直接设计一个递归的分治算法： 123456789101112131415square_matrix_multiply_recursive(A, B) n = A.rows C = [n][n] if n == 1 c[1][1] = A[1][1] x B[1][1] else # 将 A、B 和 C 划分成子矩阵，然后递归计算 C[1][1] = square_matrix_multiply_recursive(A[1][1], B[1][1]) + square_matrix_multiply_recursive(A[1][2], B[2][1]) C[1][2] = square_matrix_multiply_recursive(A[1][1], B[1][2]) + square_matrix_multiply_recursive(A[1][2], B[2][2]) C[2][1] = square_matrix_multiply_recursive(A[2][1], B[1][1]) + square_matrix_multiply_recursive(A[2][2], B[2][1]) C[2][2] = square_matrix_multiply_recursive(A[2][1], B[1][2]) + square_matrix_multiply_recursive(A[2][2], B[2][2])","link":"/2018/03/26/zh/programing/book_read/algorithms/introduction_to_algorithms/1-4/"},{"title":"《算法导论》笔记2-6","text":"排序和顺序统计量堆排序（二叉）堆是一个数组，它可以被看成一个近似的完全二叉树（除了最底层，该树是完全满的，而且是从左到右填充）。 表示堆的数组 A 包括两个属性： A.length（通常）给出数组元素的个数。 A.heap_size 表示有多少个堆元素存储在该数组中。也就是说，虽然 A[A.length] 可能都存有数据，但只有 A[A.heap_size] 中存放的是堆的有效元素。（0 &lt;= heap_size &lt;= length） 1234567下标： 0 1 2 3 4 5 6 7 8 9数组：16 14 10 8 7 9 3 2 4 1 16 14 10 8 7 9 32 4 1 树的根节点是 A[0]，这样，给定一个节点的下标 i，就很容易得到它的父节点、左孩子和右孩子： 12345678parent(i) return [i/2]left(i) return 2i + 1right(i) return 2(i + 1) 维护最大堆的性质max_heapify 是用于维护最大堆性质的重要过程，如果父节点 A[i] 小于其左右孩子，就违背了最大堆的性质。max_heapify 通过让 A[i] 的值在最大堆中逐级下降，从而使得以下标 i 为根节点的子树重新遵循最大堆的性质。 伪代码： 123456789101112131415max_heapify(A, i) lChild = left(i) rChild = right(i) # 如果左孩子比父节点大 if lChild &lt;= A.heap_size and A[lChild] &gt; A[i] largest = lChild else largest = i # 如果右孩子比左孩子 或 父节点大 if rChild &lt;= A.heap_size and A[rChild] &gt; A[largest] largest = rChild # 最大节点不是父节点，要逐级下降 if largest != i swap(A[i], A[largest]) max_heapify(A, largest) 建堆我们可以用过程 max_heapify 自底向上地把一个大小为 n = A.length 的数组转换为最大堆。其中子数组 A[[n/2] + 1 … n] 中的元素都是树的叶节点，而每个叶节点都可以看成只包含一个元素的堆，所以自底向上就是从这些叶节点的父节点开始到根节点的过程。 伪代码： 1234build_max_heap(A) A.heap_size = A.length for i in range(0, [A.length/2], -1) max_heapify(A, i) 堆排序步骤： 将输入的数组 A[n] 建成最大堆（n = A.length）。 最大值总在根节点 A[0]，将 A[0] 和 A[n] 交换（即放到末尾），同时通过降低堆顶 heap_size，从而减小堆大小。 调整堆，使其符合最大堆性质。 不断重复 2~3 步，直到堆的大小从 n - 1 降到 1。 伪代码： 123456heap_sort(A) build_max_heap(A) for i in (1, A.heap_size, -1) swap(A[0], A[i]) A.heap_size-- max_heapify(A, 0) Java 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MaxHeap { int[] A; int heapSize; int length; MaxHeap(int[] A) { this.A = A; this.length = A.length - 1; this.heapSize = this.length; } int parent(int i) { return i / 2; } int left(int i) { return 2 * i + 1; } int right(int i) { return 2 * (i + 1); }}void swap(MaxHeap heap, int i, int j) { int tmp = heap.A[i]; heap.A[i] = heap.A[j]; heap.A[j] = tmp;}void maxHeapify(MaxHeap heap, int i) { int lChild = heap.left(i); int rChild = heap.right(i); int lagest = i; if (lChild &lt;= heap.heapSize &amp;&amp; heap.A[lChild] &gt; heap.A[i]) { lagest = lChild; } if (rChild &lt;= heap.heapSize &amp;&amp; heap.A[rChild] &gt; heap.A[lagest]) { lagest = rChild; } if (lagest != i) { swap(heap, i, lagest); maxHeapify(heap, lagest); }}MaxHeap buildMaxHeap(int[] A) { MaxHeap heap = new MaxHeap(A); for (int i = heap.length / 2; i &gt;= 0; i--) { maxHeapify(heap, i); } return heap;}int[] heapSort(int[] A) { MaxHeap heap = buildMaxHeap(A); for (int i = heap.heapSize; i &gt;= 1; i--) { swap(heap, 0, i); heap.heapSize--; maxHeapify(heap, 0); } return heap.A;} 优先队列优先队列（priority queue）是一种用来维护由一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为关键字（key）。 一个最大优先队列支持以下操作：insert(S, x)：把元素插入集合 S 中（等价于 S = S U {x}）。max(S)：返回 S 中具有最大关键字的元素。extract_max(S)：去掉并返回 S 中的具有最大关键字的元素。increase_key(S, x, k)：将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。 最大优先队列的应用有很多，其中一个就是在共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级，当一个作业完成或被中断后，调度器调用 extract_max 从所有的等待作业中，选出具有最高优先级的作业来执行。在任何时候，调度器可以调用 insert 把一个新作业加到队列中来。 暂略。。。","link":"/2018/03/28/zh/programing/book_read/algorithms/introduction_to_algorithms/2-6/"},{"title":"《算法导论》笔记2-7","text":"快速排序与归并排序一样，快速排序也使用了分治思想，下面是对一个典型的子数组 A[low … high] 进行快速排序的三步分支过程： 分解：数组 A[low … high] 被划分为两个子数组 A[low … mid - 1] 和 A[mid + 1 … high]，使得 A[low … mid - 1] 中的每一个元素都小于等于 A[mid]，而 A[mid] 也小于等于 A[mid + 1 … high] 中的每个元素。 解决：通过递归调用快速排序，对子数组 A[low … mid - 1] 和 A[mid + 1 … high] 进行排序。 合并：因为子数组都是原址排序的，所以不需要合并操作：数组 A[low … high] 已经有序。 伪代码： 12345quick_sort(A, low, high) if low &lt; high mid = partition(A, low, high) quick_sort(A, low, mid - 1) quick_sort(A, mid + 1, high) 算法的关键就是 partition(A, low, high) 划分过程，它实现对子数组 A[low … high] 的原址重排： 123456789partition(A, low, high) x = A[high] i = low - 1 for j in range(low, high - 1) if A[j] &lt;= x i++ swap(A[i], A[j]) swap(A[i + 1], A[high]) return i + 1 Java 代码： 1234567891011121314151617181920int partition(int[] A, int low, int high) { int x = A[high]; int i = low - 1; for (int j = low; j &lt; high; j++) { if (A[j] &lt;= x) { i++; swap(A, i, j); } } swap(A, i + 1, high); return i + 1;}void quickSort(int[] A, int low, int high) { if (low &lt; high) { int mid = partition(A, low, high); quickSort(A, low, mid - 1); quickSort(A, mid + 1, high); }} 快速排序的随机版在讨论快速排序的平均情况性能时，我们是假设了：输入数据的所有排列都是等概率的。但实际情况下，这个假设并不总是成立。为了使所有的输入都能获得较好的性能，我们可以在算法中引入随机性。 划分前进行一次随机交换： 1234randomized_partition(A, low, high) i = random(low, high) swap(A[high], A[i]) return partition(A, low, high) 快速排序中的划分改成上面的划分： 12345randomized_quicksort(A, low, high) if low &lt; high mid = randomized_partition(A, low, high) randomized_quicksort(A, low, mid - 1) randomized_quicksort(A, mid + 1, high)","link":"/2018/03/29/zh/programing/book_read/algorithms/introduction_to_algorithms/2-7/"},{"title":"《算法导论》笔记2-8","text":"线性时间排序计数排序计数排序假设 n 个输入元素中的每一个都是在 0 到 max 区间内的一个整数。（max 是数组里最大的数字） 基本思想：对每个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放到它的输出数组中的位置了。例如如果有 17 个元素小于 x，则 x 就应该在第 18 个输出位置上。当有几个元素相同时，这一方案就要稍作修改，因为不能把它们放在同一输出位置。 假设输入数组是 A[0 … n]，那么我们还需要两个数组：B[0 … n] 输出数组，C[0 … max] 临时数组。 伪代码： 1234567891011121314counting_sort(A, B, max) C = [max] # 初始化 for i in range(0, max) C[i] = 0 # 计数 for i in range(0, A.length) C[A[i]]++ # 统计有多少元素 &lt;= i for i in range(0, max) C[i] += C[i - 1] for i in range(0, A.length, -1) B[C[A[i]]] = A[i] C[A[i]]-- 基数排序这里通过实例说： 设有一个初始序列为 A = {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。为方便说明将这些数字补齐成这样：{050, 123, 543, 187, 049, 030, 000, 002, 011, 100}。 按个位排序：{050, 030, 000, 100, 011, 002, 123, 543, 187, 049}。（50、30、0、100 的个位都是 0） 按十位排序：{000, 100, 002, 011, 123, 030, 543, 049, 050, 187}。（个位排序后顺序判断） 按百位排序：{000, 002, 011, 030, 049, 050, 100, 123, 187, 543}。（十位排序后顺序判断） 最后得到由小到大的序列：{0, 2, 11, 30, 49, 50, 100, 123, 187, 543}。 例如，对 {2010-3-4, 2001-4-30, 2008-8-1, 2001-2-28, 1998-3-8} 按日期从小到大排序。 对日按照上面的个十位排序：{2008-8-1, 2010-3-4, 1998-3-8, 2001-2-28, 2001-4-30}。 对月按照个十位排序：{2001-2-28, 2010-3-4, 1998-3-8, 2001-4-30, 2008-8-1}。 对年按照个十百千位排序：{1998-3-8, 2001-2-28, 2001-4-30, 2008-8-1, 2010-3-4}。 伪代码： 12345radix_sort(A, highestBit) # 从最低位到最高位 for i in range(1, highestBit) # 使用稳定的排序算法对数组 A 排序，比如计数排序 counting_sort(A, B, max) 桶排序桶排序假设输入的数据服从均匀分布，平均情况下它的时间代价为 O(n)。 伪代码： 1234567891011bucket_sort(A) n = A.length # B 是存放链表（桶）的数组 B = new [n - 1] for i in range(1, n) # 把 A[i] 插到 B 对应的桶中 for i in range(0, n - 1) # 对 B 中的每一个桶（即B[i]）都进行排序，比如插入排序 # 桶里存了若干元素，也就相当于数组 insert_sort(B[i]) # 最后把第一个桶到最后一个桶中的所有元素合并起来","link":"/2018/04/07/zh/programing/book_read/algorithms/introduction_to_algorithms/2-8/"},{"title":"《算法导论》笔记3-10","text":"数据结构栈（stack）判断空栈： 12stack_empty(S) return S.top == 0 压栈： 123push(S, x) S.top++ S[S.top] = x 弹栈： 123456pop(S) if stack_empty(S) error &quot;underflow&quot; else S.top-- return S[S.top + 1] 队列（queue）入队： 123456enqueue(Q, x) Q[Q.tail] = x if Q.tail == Q.length Q.tail = 1 else Q.tail++ 出队： 1234567dequeue(Q, x) x = Q[Q.head] if Q.head == Q.length Q.head = 1 else Q.head++ return x 链表（linked list）搜索： 12345list_search(L, k) x = L.head while x != null and x.key != k x = x.next return x 插入： 123456list_insert(L, k) x.next = L.head if L.head != null L.head.prev = x L.head = x x.prev = null 删除： 1234567list_delete(L, x) if x.prev != null x.prev.next = x.next else L.head = x.next if x.next != null x.next.prev = x.prev","link":"/2018/03/29/zh/programing/book_read/algorithms/introduction_to_algorithms/3-10/"},{"title":"《算法导论》笔记3-11","text":"散列表直接寻址表散列表散列函数开放寻址法线性探查二次探查双重散列","link":"/2018/03/29/zh/programing/book_read/algorithms/introduction_to_algorithms/3-11/"},{"title":"《算法导论》笔记3-12","text":"二叉搜索树递归查找： 1234567tree_search(root, k) if root == null or k == root.key return root if k &lt; root.key return tree_search(root.left, k) else return tree_search(root.right, k) 迭代查找： 1234567tree_search(root, k) while root != null or k != root.key if k &lt; root.key root = root.left else root = root.right return root 最大关键字元素和最小关键字元素： 1234tree_min(root) while root.left != null root = root.left return root 1234tree_max(root) while root.right != null root = root.right return root 插入： 1234567891011121314151617tree_insert(T, node) parent = null root = T.root while root != null parent = root if node.key &lt; root.key root = root.left else root = root.right node.parent = parent # 空树 if parent == null T.root = node elif node.key &lt; parent.key parent.left = node else parent.right = node 删除： 123456789transplant(T, root, child) if root.parent == null T.root = child elif root == root.parent.left root.parent.left = child else root.parent.right = child if child != null child.parent = root.parent 1234567891011121314tree_delete(T, node) if node.left == null transplant(T, node, node.right) elif node.right == null transplant(T, node, node.left) else minChild = tree_min(node.right) if minChild != node transplant(T, minChild, minChild.right) minChild.right = node.right minChild.right.parent = minChild transplant(T, node, minChild) minChild.left = node.left minChild.left.parent = minChild","link":"/2018/03/29/zh/programing/book_read/algorithms/introduction_to_algorithms/3-12/"},{"title":"《算法导论》笔记3-13","text":"红黑树旋转： 1234567891011121314left_rotate(T, root) rChild = root.right root.right = rChild.left if rChild.left != T.null rChild.left.parent = root rChild.parent = root.parent if root.parent == T.null T.root = rChild elif root == root.parent.left root.parent.left = rChild else root.parent.right = rChild rChild.left = root root.parent = rChild 插入：","link":"/2018/03/29/zh/programing/book_read/algorithms/introduction_to_algorithms/3-13/"},{"title":"《算法导论》笔记3-9","text":"中位数和顺序统计期望为线性时间的选择算法这里的随机划分使用了快速排序中的随机版。 1234567891011randomized_select(A, low, high, index) if low == high return A[low] mid = randomized_partition(A, low, high) leftRange = mid - low + 1 if index == leftRange return A[mid] elif index &lt; leftRange return randomized_select(A, low, mid - 1, index) else return randomized_select(A, mid + 1, high, index - leftRange)","link":"/2018/04/08/zh/programing/book_read/algorithms/introduction_to_algorithms/3-9/"},{"title":"《Head First 设计模式》笔记10","text":"代理模式（Proxy）为另一个对象提供一个替身或占位符以控制对这个对象的访问。 栗子还记得上一个笔记中的糖果机吧，现在产品经理想要一份写着糖果机位置、库存和当前的状态报告。 是不是挺简单的？赶紧写代码。 糖果机加上位置信息： 123456789101112131415class GumballMachine { // ... private String location; public GumballMachine(String location, int count) { this.location = location; // ... } public String getLocation() { return location; } // ...} 一个监控糖果机的监视器： 12345678910111213class GumballMonitor { private GumballMachine gumballMachine; public GumballMonitor(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } public void report() { System.out.println(&quot;糖果机：&quot; + gumballMachine.getLocation()); System.out.println(&quot;当前库存：&quot; + gumballMachine.getCount()); System.out.println(&quot;当前状态：&quot; + gumballMachine.getState()); }} 测试12345public static void main(String[] args) { GumballMachine gumballMachine = new GumballMachine(&quot;广州&quot;, 600); GumballMonitor monitor = new GumballMonitor(gumballMachine); monitor.report();} 完美通过测试，收拾东西回家洗澡。 满足了假的需求产品经理的需求并没有完全表达清楚，我们就开始写了，最后白费了时间和精力，而且没完成任务。（记得问清楚需求再去实现） 需求是要一个能远程的监控器，而按我们上面的监视器和糖果机代码，它们就是在同一个 JVM 上执行的，就相当于一个本地监控器，什么意思呢？相当于在教室里装了一个摄像头，而且是实时监控，没联网的，那么只能在教室看，对于坐在办公室的老师来说这个摄像头没起作用。 前置知识RMI：远程方法调用（Remote Method Invocation），用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟机中的对象的方法，而允许被远程调用的对象需要通过一些标志加以标识。 详情的可以看看这篇文章。 制作远程服务将一个普通的对象变成可以被远程客户调用的远程对象，简要步骤： 制作远程接口：远程接口定义出可以让客户远程调用的方法。客户将用它作为服务的类类型。Stub 和实际的服务都实现此接口。 制作远程实现：做实际工作的类，为远程接口中定义的远程方法提供了真正的实现，是客户真正想要调用方法的对象（比如我们的GumballMachine）。 利用 rmic 产生的 stub 和 skeleton：客户和服务的辅助类。不需要创建，因为运行 rmic 工具时就会自动处理。 启动 RMI registry：rmireistry 就像电话簿，客户可以从中查到代理的位置（就是客户的 stub helper 对象）。 开始远程服务：让服务对象开始运行。服务实现类会去实例化一个服务的实例，并将这个服务注册到 RMI registry。注册之后，这个服务就可以供客户调用了。 制作远程接口 扩展 java.rmi.Remote Remote 不具有方法，只是作为一个“记号”接口。对 RMI 来说，Remote 接口具有特别的意义。 123456import java.rmi.Remote;import java.rmi.RemoteException;public interface MyRemote extends Remote { public String sayHello() throws RemoteException;} 注意： 所有的方法都要声明抛出 RemoteException，因为客户会调用实现远程接口的 Stub 上的方法，而 Stub 底层用到了网络和 I/O，所以各种意外都可能发生。方法上的变量和返回值都必须属于原语（primitive）或可序列化（Serializable）类型（远程方法的变量必须被打包并通过网络运送，这需要序列化）。原语类型、字符串和许多 API 中内定的类型都不会有问题，但如果是自己定义的类，必须保证它实现了 Serializable。 制作远程实现 你的服务必须实现远程接口，它是客户将要调用的方法的接口。 12345678910111213141516171819import java.rmi.server.UnicastRemoteObject;public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote { public MyRemoteImpl() throws RemoteException { } public String sayHello() { return &quot;服务器：你好&quot;; } // 为了方便后面的启动服务 public static void main(String[] args) { try { MyRemote service = new MyRemoteImpl(); Naming.rebind(&quot;RemoteHello&quot;, service); } catch (Exception e) { e.printStackTrace(); } }} 注意： 扩展 UnicastRemoteObject：为了成为远程服务对象，你的对象需要某些“远程的”功能。最简单的方式就是扩展 UnicastRemoteObject，让超类帮你做这些工作。不带变量的构造器要声明 RemoteException，这样当类被实例化的时候，超类的构造器总是会被调用。如果超类的构造器抛出异常，那么你只能什么子类的构造器也抛出异常。 产生 Stub 和 Skeleton 在远程实现类上执行 rmic 命令： 1rmic MyRemoteImpl 执行 rmireistry 执行命令启动 rmireistry 1rmireistry 启动服务 在这个简单的例子中，我们从实现类中的 main 方法启动： 1java MyRemoteImpl 客户取得 Stub 对象 客户总是使用远程接口做为服务类型，事实上客户不需要知道远程服务的真正类名什么。 12345678910111213import java.rmi.*;class MyRemoteClient { public static void main(String[] args) { try { // 通过查找 RemoteHello 注册名，找到远程服务 MyRemote service = (MyRemote) Naming.lookup(&quot;rmi://127.0.0.1/RemoteHello&quot;); System.out.println(service.sayHello()); } catch (Exception e) { e.printStackTrace(); } }} 注意： 要先启动 rmireistry 注册，再启动远程服务。远程方法的变量和返回值类型必须为可序列化的类型。必须给客户提供 Stub 类。 客户机内有：Client.class、MyRemoteImpl_Stub.class、MyRemote.class远程服务机内有：MyRemoteImpl.class、MyRemoteImpl_Stub.class、MyRemoteImpl_Skel.class、MyRemote.class 继续完成需求把糖果机变成一个远程服务 同样，按照上面的步骤进行。 1.创建远程接口： 1234567import java.rmi.*;public interface GumballMachineRemote extends Remote { public int getCount() throws RemoteException; public String getLocation() throws RemoteException; public State getState() throws RemoteException;} 2.State 这个返回类型不是序列化的，要修改： 12345678import java.io.Serializable;public interface State extends Serializable { public void insertQuarter(); public void ejectQuarter(); public void turnCrank(); public void dispense();} 3.每个实体状态都维护着一个糖果机的引用，而我们不希望整个糖果机都被序列化并随着 State 对象一起传送： 加上 transient 关键字，告诉 JVM 不要序列化这个字段。 12345public class SoldState implements State { transient GumballMachine gumballMachine; // ...} 4.糖果机要实现远程接口： 1234567891011import java.rmi.*;import java.rmi.server.UnicastRemoteObject;public class GumballMachine extends UnicastRemoteObject implements GumballMachineRemote { // 构造方法会抛 RemoteException 异常，因为超类 public GumballMachine(String location, int count) throws RemoteException { // ... } // ...} 5.修改监控器： 1234567891011121314151617181920import java.rmi.*;public class GumballMonitor { // 改成远程接口上的糖果机 private GumballMachineRemote gumballMachine; public GumballMonitor(GumballMachineRemote gumballMachine) { this.gumballMachine = gumballMachine; } public void report() { try { System.out.println(&quot;糖果机：&quot; + gumballMachine.getLocation()); System.out.println(&quot;当前库存&quot; + gumballMachine.getCount()); System.out.println(&quot;当前状态&quot; + gumballMachine.getState()); } catch (RemoteException e) { e.printStackTrace(); } }} 在 RMI registry 中注册 糖果机服务已经完成了，现在要把它装上，好开始接收请求。 首先要确保将它注册到 RMI registry 中，好让客户可以找到它： 123456789101112131415161718public class GumballMachineTestDrive { public static void main(String[] args) { if (args.length &lt; 2) { System.out.println(&quot;GumballMachine &lt;location&gt; &lt;count&gt;&quot;); System.exit(1); } try { String location = args[0]; int count = Integer.parseInt(args[1]); GumballMachineRemote gumballMachine = new GumballMachine(location, count); // 用糖果机的位置发布糖果机的 stub Naming.rebind(&quot;//&quot; + location + &quot;/gumballmachine&quot;, gumballMachine); } catch (Exception e) { e.printStackTrace(); } }} 在命令行注册： 1rmiregistry 启动糖果机服务： 1java GumballMachineTestDrive GuangZhou 100 监控器测试程序 现在一切就绪，可以尝试监控更多糖果机： 1234567891011121314151617181920public class GumballMonitorTestDrive { public static void main(String[] args) { List&lt;String&gt; locations = Arrays.asList( &quot;rmi://GuangZhou/gumballmachine&quot;, &quot;rmi://ShangHai/gumballmachine&quot;, &quot;rmi://BeiJing/gumballmachine&quot;); List&lt;GumballMonitor&gt; monitors = new ArrayList&lt;&gt;(); locations.forEach(location -&gt; { try { // 为每个远程机器创建一个代理 GumballMachineRemote machine = (GumballMachineRemote) Naming.lookup(location); monitors.add(new GumballMonitor(machine)); } catch (Exception e) { e.printStackTrace(); } }); monitors.forEach(monitor -&gt; monitor.report()); }} 虚拟代理（Virtual Proxy）远程代理 远程代理可以作为另一个 JVM 上对象的本地代表。调用代理方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。 本地客户 Client 发出请求 -&gt; 本地的远程代理 proxy 转发该请求 -&gt; 远程对象 RealSubject 虚拟代理 虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求委托给对象。 本地客户 Client 发出请求 -&gt; 本地的虚拟代理 proxy 处理请求 -&gt; 如果 RealSubject（开销大的对象）已经创建，proxy 就把请求委托给 RealSubject；否则 proxy 创建该 RealSubject。","link":"/2018/04/06/zh/programing/book_read/java/head_first_design_pattern/10_proxy/"},{"title":"《Head First 设计模式》笔记1","text":"前言对白很有趣，业务情景营造地很有氛围，如果还不会设计模式的话是值得一读的。 本笔记当然不会有那些有趣的图片和氛围，内容也会尽量浓缩。 策略模式（Strategy）定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 栗子某公司做了一款鸭子游戏，游戏中的鸭子可以游泳，可以呱呱叫。系统设计了一个鸭子抽象类，让各种鸭子都继承它： 1234567891011abstract class Duck { void quack() { System.out.println(&quot;呱呱叫&quot;); } void swim() { System.out.println(&quot;游泳&quot;); } abstract void display();} 其中一些鸭子： 12345678910111213class MallardDuck extends Duck { @Override void display() { System.out.println(&quot;绿头鸭子&quot;); }}class RedheadDuck extends Duck { @Override void display() { System.out.println(&quot;红头鸭子&quot;); }} 提需求现在公司要游戏中的鸭子能飞。 最简单的方案：给鸭子抽象类加上 fly 方法，这样鸭子们都能飞了。 123void fly() { System.out.println(&quot;飞&quot;);} 对于真鸭子来说，没多大问题。但对于假鸭子来说，就不对了，比如橡皮鸭，根本就不能飞，而且另一个 quack 方法也不适用于橡皮鸭，因为它是吱吱叫的。 当然，对于橡皮鸭，你可以覆盖 quack 方法和 fly 方法： 12345678910111213141516class RubberDuck extends Duck { @Override void quack() { System.out.println(&quot;吱吱叫&quot;); } @Override void display() { System.out.println(&quot;橡皮鸭&quot;); } @Override void fly() { // 什么都不做 }} 但如果现在又新添加了一只诱饵鸭呢？它是木头假鸭，既不会飞又不会叫，如果还是使用上面的方法的话就是： 12345678910111213141516class DecoyDuck extends Duck { @Override void quack() { // 什么都不做 } @Override void display() { System.out.println(&quot;诱饵鸭&quot;); } @Override void fly() { // 什么都不做 }} 给程序员很明显的感觉就是，并不需要这些什么都不做的行为，但不覆盖又不行，不然这些鸭子的行为就不对了。所以利用继承来提供鸭子的行为有以下缺点： 代码在多个子类中重复。 运行时的行为不容易改变。 很难知道所有鸭子的全部行为。 改变会牵一发动全身，造成其他鸭子不想要的改变。 满足需求 设计原则一：找出应用中可能需要变化的地方，把它们独立出来，不要和那些不需要变化的代码混在一起。 既然鸭子的行为是变化的，那么根据原则一，我们要做的就是把鸭子的行为从鸭子抽象类 Duck 中抽出来，那抽出来后怎么定义具体鸭子的行为呢？那当然是定义具体鸭子的同时，定义其行为。 设计原则二：针对接口编程，而不是针对实现编程。设计原则三：多用组合，少用继承。 根据原则二，写出对应的飞和叫这两种行为的接口： 飞的行为： 123interface FlayBehavior { void fly();} 具体飞的动作的两个实现： 12345678910111213class FlyWithWings implements FlayBehavior { @Override public void fly() { System.out.println(&quot;飞&quot;); }}class FlyNoWay implements FlayBehavior { @Override public void fly() { // 不会飞，什么都不做 }} 叫的行为： 123interface QuackBehavior { void quack();} 具体叫的动作的三个实现： 1234567891011121314151617181920class Quack implements QuackBehavior { @Override public void quack() { System.out.println(&quot;呱呱叫&quot;); }}class Squeak implements QuackBehavior { @Override public void quack() { System.out.println(&quot;橡皮鸭吱吱叫&quot;); }}class MuteQuack implements QuackBehavior { @Override public void quack() { // 不会叫，什么都不做 }} 给鸭子抽象类添加这些行为，并且加入 setter，让这些行为可以动态设置： 123456789101112131415161718192021222324252627abstract class Duck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; // 如果想要改变鸭子的飞行 void setFlyBehavior(FlyBehavior behavior) { this.flyBehavior = behavior; } void setQuackBehavior(QuackBehavior behavior) { this.quackBehavior = behavior; } void quack() { quackBehavior.quack(); } void fly() { flyBehavior.fly(); } void swim() { System.out.println(&quot;游泳&quot;); } abstract void display();} 然后就可以在构造器里实现具体行为了： 1234567891011121314151617181920212223class MallardDuck extends Duck { public MallardDuck() { quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); } @Override void display() { System.out.println(&quot;绿头鸭子&quot;); }}class RubberDuck extends Duck { public RubberDuck() { quackBehavior = new Squeak(); flyBehavior = new FlyNoWay(); } @Override void display() { System.out.println(&quot;橡皮鸭子&quot;); }} 测试1234567891011121314151617public class Main { public static void main(String[] args) throws IOException { RubberDuck rubberDuck = new RubberDuck(); rubberDuck.display(); rubberDuck.fly(); rubberDuck.quack(); // 橡皮鸭也变成呱呱叫 QuackBehavior quack = new Quack(); rubberDuck.setQuackBehavior(quack); rubberDuck.quack(); System.out.println(&quot;--------&quot;); MallardDuck mallardDuck = new MallardDuck(); mallardDuck.display(); mallardDuck.fly(); mallardDuck.quack(); }} 输出： 橡皮鸭子 橡皮鸭吱吱叫 呱呱叫 ——– 绿头鸭子 飞 呱呱叫","link":"/2018/03/28/zh/programing/book_read/java/head_first_design_pattern/1_strategy/"},{"title":"《Head First 设计模式》笔记2","text":"观察者模式（Observer）定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 初识我们先来了解一下报纸和杂志的订阅是怎么回事： 报社的业务就是出版报纸、杂志等各种出版物。 如果我想看报社的 A 报纸和 B 杂志，那么就向报社订阅 A 报纸和 B 杂志。 当他们有新的 A 报纸或 B 杂志出版时，就会向你派送，只要你是他们的订户，你就会一直收到新报纸，新杂志。 如果你不想看 B 杂志了，取消订阅，他们就不会再送新的 B 杂志给你了。但不会影响你订阅的 A 报纸。 只要报社还在运营，就会一直有人向他们订阅或取消报纸等出版物。 在观察者模式中，出版者报社 = 主题（subject），而我们订阅者 = 观察者（observer）。 栗子现在有一个系统，包括三部分： 气象站：获取实际气象数据的物理装置。 WeatherData 类：追踪来自气象站的数据，并更新布告板（具体怎么追踪的不用管）。 布告板：显示目前的天气状况。 现在的项目是，利用 WeatherData 类取得气象数据，更新三个布告板：目前状况、气象统计和天气预报。 WeatherData 类： 123456789101112131415161718192021222324class WeatherData { private float temperature; // 温度 private float humidity; // 湿度 private float pressure; // 气压 public float getTemperature() { return this.temperature; } public float getHumidity() { return this.humidity; } public float getPressure() { return this.pressure; } /** * 一旦气象数据更新，就会被调用 */ public void measurementsChanged() { // 你的代码 }} 而我们的工作就是实现 measurementsChanged，让它来更新我们的三个布告板（不用知道该方法是如何被调用的，我们只用知道该方法被调用时，我们的布告板也被更新了）。 布告板肯定还会添加或者删除的，所以项目一定要支持扩展。 错误示范12345678910public void measurementsChanged() { // 获得最近的天气数据 float temp = getTemperature(); float humidity = getHumidity(); float pressure = getPressure(); // 更新三个布告板 currentConditionsDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); forecastDisplay.update(temp, humidity, pressure);} 有什么问题呢？ 如果有添加和删除布告板的需求，那么就必须改动这些代码，不利于项目的扩展。（想一想每次都要修改、编译、打包就觉得累） 这些布告板都有一个 update 方法，所以这些布告板应该用带有 update 方法的接口或抽象类替代而不是具体实现。 满足需求一个 WeatherData 类和多个布告板有联系，并且布告板需要 WeatherData 类来通知数据，所以这里应该使用观察者模式。 定义主题接口： 12345678interface Subject { // 观察者注册 void registerObserver(Observer o); // 删除观察者 void removeObserver(Observer o); // 通知所有观察者 void notifyObservers();} 观察者接口： 123interface Observer { void update(float temperature, float humidity, float pressure);} 布告板显示功能： 123interface DisplayElement { void display();} 然后就是把 WeatherData 类改造成 Subject： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class WeatherData implements Subject { private float temperature; // 温度 private float humidity; // 湿度 private float pressure; // 气压 private List&lt;Observer&gt; observers; // 观察者们 public WeatherData() { observers = new ArrayList&lt;&gt;(); } @Override public void registerObserver(Observer o) { observers.add(o); } @Override public void removeObserver(Observer o) { observers.remove(o); } @Override public void notifyObservers() { // 通知每一个观察者更新数据 for (Observer observer : observers) { observer.update(temperature, humidity, pressure); } } public void measurementsChanged() { notifyObservers(); } public float getTemperature() { return this.temperature; } public float getHumidity() { return this.humidity; } public float getPressure() { return this.pressure; } // 模拟数据，方便测试 public void mock(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); }} 把布告板变成观察者： 12345678910111213141516171819202122class CurrentConditionsDisplay implements Observer, DisplayElement { private Subject weatherData; // 保存主题，方便之后取消观察 private float temperature; private float humidity; public CurrentConditionsDisplay(WeatherData weatherData) { this.weatherData = weatherData; this.weatherData.registerObserver(this); } @Override public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; display(); } @Override public void display() { System.out.println(&quot;目前状况：&quot; + temperature + &quot; 摄氏度，&quot; + humidity + &quot;% 湿度&quot;); }} 测试123456789101112public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay display1 = new CurrentConditionsDisplay(weatherData); System.out.println(&quot;通知前&quot;); display1.display(); System.out.println(&quot;第一次通知后&quot;); weatherData.mock(25, 60, 30.4f); System.out.println(&quot;第二次通知后&quot;); weatherData.mock(20, 72, 41.7f); }} 输出： 通知前 目前状况：0.0 摄氏度，0.0% 湿度 第一次通知后 目前状况：25.0 摄氏度，60.0% 湿度 第二次通知后 目前状况：20.0 摄氏度，72.0% 湿度 使用 Java 内置的观察者模式Java 内置的 Observer 接口和 Observable 类和我们实现的 Subject 接口与 Observer 接口很相似。 这里就将使用这两个内置的接口和类重写上面的天气软件。 WeatherData 类继承 Observable 类： 1234567891011121314151617181920212223242526272829303132333435import java.util.Observable;class WeatherData extends Observable { private float temperature; // 温度 private float humidity; // 湿度 private float pressure; // 气压 public void measurementsChanged() { // 指示状态已经改变；如果不指示的话，notifyObservers 无法发出通知 // 详细看源码实现 setChanged(); notifyObservers(); } // 观察者会利用这些 getter 方法取得 WeatherData 对象的状态 public float getTemperature() { return this.temperature; } public float getHumidity() { return this.humidity; } public float getPressure() { return this.pressure; } // 模拟数据，方便测试 public void mock(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); }} 布告板实现 Observer 接口： 12345678910111213141516171819202122232425262728import java.util.Observer;class CurrentConditionsDisplay implements Observer, DisplayElement { private Observable observable; private float temperature; private float humidity; public CurrentConditionsDisplay(Observable observable) { this.observable = observable; this.observable.addObserver(this); } @Override public void update(Observable observable, Object arg) { // 先确定接收的是来自 WeatherData 的，而不是来自其他可观察对象的 if (observable instanceof WeatherData) { WeatherData weatherData = (WeatherData) observable; this.temperature = weatherData.getTemperature(); this.humidity = weatherData.getHumidity(); display(); } } @Override public void display() { System.out.println(&quot;目前状况：&quot; + temperature + &quot; 摄氏度，&quot; + humidity + &quot;% 湿度&quot;); }} 测试123456789101112public class Main { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay display1 = new CurrentConditionsDisplay(weatherData); System.out.println(&quot;通知前&quot;); display1.display(); System.out.println(&quot;第一次通知后&quot;); weatherData.mock(25, 60, 30.4f); System.out.println(&quot;第二次通知后&quot;); weatherData.mock(20, 72, 41.7f); }} 输出结果和上面一致： 通知前 目前状况：0.0 摄氏度，0.0% 湿度 第一次通知后 目前状况：25.0 摄氏度，60.0% 湿度 第二次通知后 目前状况：20.0 摄氏度，72.0% 湿度 如果有多个不同的公告板，上面输出的结果顺序可能会不同，因为 Observable 类通知的先后顺序不依赖于注册的先后。比如 A、B 都订了同一份报纸，并且 A 比 B 先订阅，但派送新报纸时，可能 A 先收到，可能 B 先收到，与注册先后无关，这是松耦合的体现。 注意：WeatherData 类是通过继承 Observable 类来获得可被观察的行为的，这违背了设计原则的“多用组合，少用继承”。","link":"/2018/03/29/zh/programing/book_read/java/head_first_design_pattern/2_observer/"},{"title":"《Head First 设计模式》笔记3","text":"装饰者模式（Decorate）动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 设计原则四：类应该对扩展开放，对修改关闭。 如果使用过 Python，应该听过装饰器，虽然概念有点不同，但都是通过动态添加的方式给对象扩展功能。 栗子星巴克的订单系统系统中有个饮料抽象类 Beverage，店内的饮料都必须继承该类： 1234567891011abstract class Beverage { // 饮料描述，比如咖啡、牛奶 protected String description; public String getDescription() { return this.description; } // 饮料价钱 public abstract float cost();} 其中一些饮料： 1234567891011121314151617181920212223class Coffee extends Beverage { public Coffee() { description = &quot;Coffee&quot;; } @Override public float cost() { return 3.2f; }}class Milk extends Beverage { public Milk() { description = &quot;Milk&quot;; } @Override public float cost() { return 4.6f; }}// ... 提需求现在，客户想要在买的饮料里加点调味料，比如买了杯咖啡，要加点牛奶、豆浆、巧克力等。这就需要订单系统在统计饮料价格时加上调味料的价格。 错误示范1每种可能的调味料的饮料都新建一个类： 123456789101112131415class CoffeeWithMilk extends Beverage { @Override public float cost() { return 7.9f; }}class MilkWithCoffee extends Beverage { @Override public float cost() { return 8.2f; }}// .... 很明显，调味料有很多，饮料也有很多，如果只加一种调味料，那搭配起来也有非常多的可能，如果都新建一个类，那么就会造成“类爆炸”。而且这些调味料的价格如果发生变化，就要将涉及的饮料都修改一遍，严重违反了设计原则中的“将变化与不变化的代码分开”。 错误示范2既然违反了变化的原则，那么尝试把这些变化的调味料都放在饮料抽象类 Beverage 中？ 1234567891011121314151617181920212223242526272829303132333435363738abstract class Beverage { protected String description; // 是否添加了某些调味料 protected boolean milk; protected boolean coffee; public String getDescription() { return this.description; } // 计算好添加的调味料价格，让子类直接调用 public float cost() { float sum = 0; if (hasCoffee()) { sum += 3.2f; } if (hasMilk()) { sum += 4.6f; } return sum; } protected boolean hasCoffee() { return this.coffee; } protected void setCoffee(boolean coffee) { this.coffee = coffee; } protected boolean hasMilk() { return this.milk; } protected void setMilk(boolean milk) { this.milk = milk; }} 饮料只要设置好添加的调味料，最后计算下自身花费就好了： 12345678910111213class Coffee extends Beverage { @Override public float cost() { return super.cost() + 3.2f; }}class Milk extends Beverage { @Override public float cost() { return super.cost() + 4.6f; }} 调用： 12345678public class Main { public static void main(String[] args) { Coffee coffee = new Coffee(); // 加点牛奶 coffee.setMilk(true); System.out.println(coffee.cost()); }} 现在没有了“类爆炸”，就算调料价格发生变化，只要修改下抽象类就好了，但是真的没问题了吗？ 有问题，而且挺多的： 如果出现新的调味料，就需要在抽象类添加新的布尔值成员，cost 方法也需要添加新的判断，还要分别新增一个 setter 和一个 getter，如果是删除一个调味料呢？ 对于有些饮料来说，某些调味料并不能加（会拉肚子的！），比如冰红茶 + 牛奶？ 如果客户要一杯咖啡，加两份牛奶呢？ 满足需求不改变原有的饮料抽象和具体的饮料： 123456789abstract class Beverage { protected String description; public String getDescription() { return this.description; } public abstract float cost();} 12345678910class Coffee extends Beverage { public Coffee() { description = &quot;Coffee&quot;; } @Override public float cost() { return 3.2f; }} 添加调味料（condiment）装饰者： 1234abstract class CondimentDecorator extends Beverage { @Override public abstract String getDescription();} 调味料继承调味料装饰者： 1234567891011121314151617181920212223242526272829303132333435class Milk extends CondimentDecorator { Beverage beverage; public Milk(Beverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + &quot; + milk&quot;; } @Override public float cost() { return .50f + beverage.cost(); }}class Mocha extends CondimentDecorator { Beverage beverage; public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public String getDescription() { return beverage.getDescription() + &quot; + mocha&quot;; } @Override public float cost() { return .20f + beverage.cost(); }} 测试12345678910111213141516171819202122public class Main { public static void main(String[] args) { Beverage coffee1 = new Coffee(); // 不需要调味料 System.out.println(coffee1.getDescription() + &quot; $&quot; + coffee1.cost()); Beverage coffee2 = new Coffee(); // 加牛奶和摩卡 coffee2 = new Milk(coffee2); coffee2 = new Mocha(coffee2); System.out.println(coffee2.getDescription() + &quot; $&quot; + coffee2.cost()); Beverage coffee3 = new Coffee(); // 加3份牛奶和2份摩卡 coffee3 = new Milk(coffee3); coffee3 = new Milk(coffee3); coffee3 = new Milk(coffee3); coffee3 = new Mocha(coffee3); coffee3 = new Mocha(coffee3); System.out.println(coffee3.getDescription() + &quot; $&quot; + coffee3.cost()); }} 输出： Coffee $3.2 Coffee + milk + mocha $3.9 Coffee + milk + milk + milk + mocha + mocha $5.0999994","link":"/2018/03/30/zh/programing/book_read/java/head_first_design_pattern/3_decorate/"},{"title":"《Head First 设计模式》笔记4","text":"工厂模式（Factory）定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 new按照之前的原则，使用接口，并 new 一个具体实现： 1Duck duck = new MallardDuck(); 但如果出现一堆相关的具体类时，可能会写出这样的代码： 123456789Duck duck;if (picnic) { // 在野外，是绿头鸭 duck = new MallardDuck();} else if (hunting) { // 在打猎，是诱导鸭 duck = new DecoyDuck();} else if (inBathTub) { // 在浴缸，是橡皮鸭 duck = new RubberDuck();} 一旦有变化或扩展，就要重新打开这段代码进行检查和修改。通常这样修改过的代码将造成部分系统更难维护和更新，而且也更容易犯错。 栗子假设有一家比萨店，店里的披萨是这样的： 12345678910111213141516171819abstract class Pizza { protected String name; // 具体的披萨名 public void prepare() { System.out.println(&quot;擀揉面皮，加佐料...&quot;); } public void bake() { System.out.println(&quot;烘烤一段时间...&quot;); } public void cut() { System.out.println(&quot;切几刀...&quot;); } public void box() { System.out.println(&quot;装上盒子...&quot;); }} 菜单上有不同的披萨口味： 1234567891011121314151617class CheesePizza extends Pizza { public CheesePizza() { this.name = &quot;cheese&quot;; }}class GreekPizza extends Pizza { public GreekPizza() { this.name = &quot;greek&quot;; }}class PepperoniPizza extends Pizza { public PepperoniPizza() { this.name = &quot;pepperoni&quot;; }} 订单系统的代码是这样的： 1234567891011121314151617181920class PizzaStore { public Pizza orderPizza(String type) { Pizza pizza; if (type.equals(&quot;cheese&quot;)) { pizza = new CheesePizza(); } else if (type.equals(&quot;greek&quot;)) { pizza = new GreekPizza(); } else if (type.equals(&quot;pepperoni&quot;)) { pizza = new PepperoniPizza(); } pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; }} 出现的正是上面提到的问题，既然这部分容易变化，那么可以把这段 new 的代码抽出来。 简单工厂把不同口味的披萨放到披萨工厂里，由工厂根据客户的需求生产： 123456789101112131415class SimplePizzaFactory { public Pizza createPizza(String type) { Pizza pizza; if (type.equals(&quot;cheese&quot;)) { pizza = new CheesePizza(); } else if (type.equals(&quot;greek&quot;)) { pizza = new GreekPizza(); } else if (type.equals(&quot;pepperoni&quot;)) { pizza = new PepperoniPizza(); } return pizza; }} 乍一看，只是将代码转到另一个地方了，其实不然，对于披萨工厂来说，它可以面向其他的客户，比如其他小吃店，而不是限制在这间披萨店。 重写比萨店的订单代码： 123456789101112131415161718class PizzaStore { SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) { this.factory = factory; } public Pizza orderPizza(String type) { Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; }} 拓展比萨市场现在比萨店要开分店了，比如在纽约，芝加哥等地方，而不同地方的比萨口味会有点不同，比如纽约的披萨皮薄，少芝士，而芝加哥的皮厚，多芝士。 12345678910// 继承自简单工厂的纽约披萨工厂NYPizzaFactory nyFactory = new NYPizzaFactory();// 纽约披萨分店PizzaStore nyStore = new PizzaStore(nyFactory);// 纽约风味的芝士披萨nyStore.orderPizza(&quot;cheese&quot;);ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();PizzaStore chicagoStore = new PizzaStore(chicagoFactory);chicagoStore.orderPizza(&quot;cheese&quot;); 未完待续……","link":"/2018/04/01/zh/programing/book_read/java/head_first_design_pattern/4_factory/"},{"title":"《Head First 设计模式》笔记5","text":"单例模式（Singleton）确保一个类只有一个实例，并提供一个全局访问点。 应用场景：线程池、注册表、任务管理器、日志对象、充当打印机、显卡等设备的驱动程序等的对象。 经典的单例模式1234567891011121314class Singleton { private static Singleton instance; // 私有的构造器，外部无法 new Singleton() private Singleton() { } public static Singleton getInstance() { // 没有实例才 new if (instance == null) { instance = new Singleton(); } return instance; }} 缺点：多线程下有可能 new 出多个不同的实例。 为什么？ 假设有两个线程 A 和 B 都调用了方法 getInstance()： A 判断完 instance 为空，准备 new；此时 B 也对 instance 进行判断，因为 A 还没 new，所以 B 判断也是空，也准备 new。 A new 完了，B 接着又 new 一个，结果就出现了两个不同的实例。 加上同步锁1234567891011121314class Singleton { private static Singleton instance; private Singleton() { } // 加上 synchronized 同步 // 保证同一时间不会有别的线程进入该方法 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 缺点：确实解决了多线程的问题，但是也造成了性能浪费。因为只有第一次 new 时才需要同步，之后每次还进行同步就显得累赘了。 加载时就创建实例12345678910class Singleton { // JVM 加载该类时就会 new 该实例 private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; }} 缺点：如果不是经常使用到的实例，也是会造成性能浪费。 双重检查加锁123456789101112131415161718192021class Singleton { // 加上 volatile 关键字 private volatile static Singleton instance; private Singleton() { } public static Singleton getInstance() { // 双重检查 if (instance == null) { // 进入第一层判断后进行同步 // 保证不存在其他线程 synchronized (Singleton.class) { // 到其他线程时可能已经有了实例 if (instance == null) { instance = new Singleton(); } } } return instance; }}","link":"/2018/04/02/zh/programing/book_read/java/head_first_design_pattern/5_singleton/"},{"title":"《Head First 设计模式》笔记6","text":"命令模式（Command）将“请求”封装成对象，以便使用不同的请求，队列或日志来参数化其他对象。命令模式也支持可撤销的操作。 栗子现在有个万能遥控器，它有五个插槽和五对开关按钮。每个插槽可以插一张存储卡，存储卡里面存的是可以控制的某个电器代码，对应的开关按钮可以控制某个电器开关。（听起来这个遥控器有点奇怪是不是？你把它想像成小霸王游戏机就可以了） 你的任务就是给遥控器上的这些开关按钮编程，让它们可以使用存储卡存的电器命令进而控制电器。 下面是其中一些存储卡的代码： 123456789101112131415161718192021222324252627282930// 灯class Light { public void on() { } public void off() { }}// 电视class TV { public void on() { } public void off() { } // 设置频道 public void setInputChannel() { } // 设置音量 public void setVolume() { }}// 安全控制系统class SecurityControl { // 警报 public void arm() { } // 解除警报 public void disarm() { }}// ... 当然现在的遥控器雏形还比较简单，只能用到开关命令，但是以后还会升级、增加更多按钮让它可以把那些控制命令都用上，需要控制的电器也会越来越多。 如何满足需求在这里，遥控器是“动作的请求者”，而那些“动作的执行者”就是存储卡上的电器对象。遥控器不需要知道这些电器对象是怎么执行的开关操作，只需要执行调用它们的命令就行了。 上面这句话有点绕口，用宏命令来解释就是：虽然上面的存储卡代码很简单，开关只有一个 on 和 off 方法，但不是所有电器都封装的这么完美。有些电器的开关操作可能很复杂（厂家没封装好，或者为了更开放），比如先打开风扇电源，再打开主机电源，可能需要一系列操作才能“开启”，而命令模式可以把这些都封装在“开启”这个执行方法中，我们只要点击这个开启，就会完成这一系列已经设置好的操作。 命令接口 123interface Command { void execute();} 一个打开灯的命令 123456789101112class LightOnCommand implements Command { Light light; public LightOnCommand(Light light) { this.light = light; } @Override public void execute() { light.on(); }} 可以控制电器的简单遥控器 这里为了方便说明，先把五个插槽简略成了一个，按钮的按下动作也被简略成了开关按钮中的一个。（完全版本就是把 Command slot 改成 Command[] slot 数组形式，这里就不实现了） 1234567891011class SimpleRemoteControl { private Command slot; public void setCommand(Command command) { this.slot = command; } public void buttonWasPressed() { this.slot.execute(); }} 模拟遥控器按下按钮 123456789101112public static void main(String[] args) { SimpleRemoteControl control = new SimpleRemoteControl(); Light light = new Light(); // 开灯命令的接收者被设置为某一个灯 LightOnCommand lightOn = new LightOnCommand(light); // 设置插槽的命令为开灯 control.setCommand(lightOn); // 按下开的按钮 control.buttonWasPressed();} 队列请求假设有一个工作队列：你控制一端，线程控制另一端。你控制的一端可以添加命令，线程控制的一端则进行这样的动作：从队列取出一个命令，调用它的 execute 方法，等待这个调用完成，然后将该命令丢弃，再取出下一个命令…… 工作队列类和进行计算的对象之间是完全解耦的，此刻线程可能在进行财务计算，下一刻可能就在读取网络数据。工作队列不在乎到底做什么，怎么做，它们只知道取出命令对象，然后调用它的 execute 方法。 日志请求类似宏命令，每次执行某一个命令后，下一步就是 store 保存这些命令操作日志，也就是操作点，这样可以在系统出问题时，方便我们查找操作点。","link":"/2018/04/02/zh/programing/book_read/java/head_first_design_pattern/6_command/"},{"title":"《Head First 设计模式》笔记7","text":"适配器模式（Adapter）将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 栗子欧洲的插座大多是三脚的，而美国的插头大多是两脚的，那么如何让两脚插头插进三脚插座里呢？这就需要一个转换头，作为一个中介，二脚插头先插入转换头，然后转换头再插入三脚插座。 还记得笔记1里的鸭子吧？ 12345interface Duck { void quack(); void fly();} 绿头鸭： 1234567891011class MallardDuck implements Duck { @Override public void quack() { System.out.println(&quot;呱呱叫&quot;); } @Override public void fly() { System.out.println(&quot;飞&quot;); }} 现在有一个火鸡的接口： 12345interface Turkey { void gobble(); // 火鸡是咯咯叫 void fly(); // 会飞，但是飞不远} 野生火鸡： 1234567891011class WildTurkey implements Turkey { @Override public void gobble() { System.out.println(&quot;咯咯叫&quot;); } @Override public void fly() { System.out.println(&quot;飞很短的距离&quot;); }} 需求来了：你的鸭子不够卖了，想拿火鸡来冒充鸭子。 需求分析 很明显，火鸡和鸭子的叫声接口不同，而且又不能长途飞，客人肯定会发现的，怎么骗过他们呢？那就需要使用到适配器，让火鸡“变成”鸭子了。（只是形式上的调用欺骗） 满足需求把火鸡变成鸭子的适配器： 123456789101112131415161718192021class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } // 原来的咯咯叫变成了呱呱叫 @Override public void quack() { turkey.gobble(); } // 火鸡飞的太短，要多飞几次才像鸭子 @Override public void fly() { for (int i = 0; i &lt; 5; i++) { turkey.fly(); } }} 测试1234567891011121314151617181920public static void main(String[] args) { MallardDuck duck = new MallardDuck(); WildTurkey turkey = new WildTurkey(); Duck turkeyAdapter = new TurkeyAdapter(turkey); System.out.print(&quot;火鸡：&quot;); turkey.gobble(); turkey.fly(); System.out.print(&quot;鸭子：&quot;); testDuck(duck); System.out.print(&quot;冒充鸭子的火鸡：&quot;); testDuck(turkeyAdapter);}public void testDuck(Duck duck) { duck.quack(); duck.fly();} 真实世界的适配器是不是感觉上面的鸭子栗子有点莫名其妙？那就看下真实世界的一个简单的适配器吧。 旧世界的枚举器 早期的集合（collection）类型（比如 Vector、Stack、Hashtable）都实现了一个名为 elements 的方法，它会返回一个 Enumeration（举）。这个接口可以遍历集合中的每个元素，而无需知道它们在集合内是如何被管理的。 1234567interface Enumeration { // 是否还有元素 boolean hasMoreElements(); // 下一个元素 Object nextElement();} 新世界的迭代器 新的集合类，使用了迭代器（Iterator），和上面的枚举接口很像，但多了删除元素的功能。 12345678910interface Iterator { // 是否还有元素 boolean hasNext(); // 下一个元素 Object next(); // 删除元素 void remove();} 遗留代码 以前的代码大多都使用了枚举器，而现在系统的 Java 版本升级了，新的代码都使用了迭代器，如何兼顾新旧代码呢？这就需要我们构造一个适配器，让旧的枚举器适配到新的迭代器。 改造前 枚举里面没有 remove 方法，怎么办？我们可以直接抛出不支持该方法的异常（UnsupportedOperationException）。而其他两个方法两者都差不多，很容易适配。 改造后 12345678910111213141516171819class EnumerationIterator implements Iterator { Enumeration enum; public EnumerationIterator (Enumeration enum) { this.enum = enum; } public boolean hasNext() { return enum.hasMoreElements(); } public boolean next() { return enum.nextElement(); } public void remove() { throw new UnsupportedOperationException(); }} 外观模式（Facade）提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 设计原则：“最少知识”，只和你的密友谈话。 上面的原则是什么意思呢？ =&gt; 不要让太多类耦合在一起，免得修改系统中的一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，而且太复杂也不容易被其他人理解。 像下面这样的代码就有点耦合了： 123public float getTemp() { return station.getThermometer().getTemperature();}","link":"/2018/04/03/zh/programing/book_read/java/head_first_design_pattern/7_adapter/"},{"title":"《Head First 设计模式》笔记8","text":"模版方法模式（Template）在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。（由高层组件决定低层组件的行为，而不是反过来） 栗子现在你有两种冲泡饮料，分别是咖啡和茶。 咖啡的冲泡过程： 把水煮沸 用沸水冲泡咖啡 把咖啡倒进杯子 加糖和牛奶 茶的冲泡过程： 把水煮沸 用沸水浸泡茶叶 把茶倒进杯子 加柠檬 然后是实现它们的过程： 冲咖啡： 123456789101112131415161718192021222324class Coffee { public void prepareRecipe() { boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } public void boilWater() { System.out.println(&quot;煮沸水&quot;); } public void brewCoffeeGrinds() { System.out.println(&quot;用咖啡壶泡咖啡&quot;); } public void pourInCup() { System.out.println(&quot;把咖啡倒进杯子&quot;); } public void addSugarAndMilk() { System.out.println(&quot;加糖和牛奶&quot;); }} 冲茶： 123456789101112131415161718192021222324class Tea { public void prepareRecipe() { boilWater(); steepTeaBag(); pourInCup(); addLemon(); } public void boilWater() { System.out.println(&quot;煮沸水&quot;); } public void steepTeaBag() { System.out.println(&quot;用茶壶泡茶&quot;); } public void pourInCup() { System.out.println(&quot;把茶倒进杯子&quot;); } public void addLemon() { System.out.println(&quot;加柠檬&quot;); }} 很明显，这四步基本差不多。整理后的算法： 把水煮沸 用沸水浸泡 xx 把饮料倒进杯子 给 xx 加适当的调味料 饮料抽象类，其中 1、3 两步都是子类共有的： 1234567891011121314151617181920abstract class Beverage { public void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } public void boilWater() { System.out.println(&quot;煮沸水&quot;); } public abstract void brew(); public void pourInCup() { System.out.println(&quot;把饮料倒进杯子&quot;); } public abstract void addCondiments();} 然后是继承饮料的咖啡： 123456789class Coffee extends Beverage { public void brew() { System.out.println(&quot;用咖啡壶泡咖啡&quot;); } public void addCondiments() { System.out.println(&quot;加糖和牛奶&quot;); }} 茶： 123456789class Tea extends Beverage { public void brew() { System.out.println(&quot;用茶壶泡茶&quot;); } public void addCondiments() { System.out.println(&quot;加柠檬&quot;); }} 测试 1234567public static void main(String[] args) { Tea tea = new Tea(); tea.prepareRecipe(); Coffee coffee = new Coffee(); coffee.prepareRecipe();} 在模版方法中使用钩子在上面的栗子中，饮料被强制加入了调味料，但是有时我们就想喝纯咖啡或者纯茶，怎么办呢？ =&gt; 可以使用钩子让用户决定是否加调味料。 12345678910111213141516171819202122232425262728abstract class Beverage { public void prepareRecipe() { boilWater(); brew(); pourInCup(); if (customerWantsCondiments()) { addCondiments(); } } public void boilWater() { System.out.println(&quot;煮沸水&quot;); } public abstract void brew(); public void pourInCup() { System.out.println(&quot;把饮料倒进杯子&quot;); } public abstract void addCondiments(); // 该函数就相当于一个钩子 // 子类可以覆盖该方法从而决定用户是否加调味料 public boolean customerWantsCondiments() { return true; }}","link":"/2018/04/03/zh/programing/book_read/java/head_first_design_pattern/8_template/"},{"title":"《Head First 设计模式》笔记9","text":"状态模式（State）允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 栗子现在有一台糖果机，它的状态（挺复杂的）： 没有 25 分钱 -&gt; 投入 25 分钱 -&gt; 有 25 分钱 有 25 分钱 -&gt; 转动曲柄 -&gt; 售出糖果（数量不为0） | 糖果售罄（数量为0） 有 25 分钱 -&gt; 退钱按钮 -&gt; 退出 25 分钱 售出糖果 -&gt; 没有 25 分钱 从上面的状态实现代码的步骤： 找出所有状态 -&gt; 共四种：没有 25 分钱、有 25 分钱、售出糖果、糖果售罄。 创建一个持有当前状态的实例变量 state。 写出所有可能发生的动作判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class GumballMachine { private final static int SOLD_OUT = 0; private final static int NO_QUARTER = 1; private final static int HAS_QUARTER = 2; private final static int SOLD = 3; private int state = SOLD_OUT; // 当前状态 private int count = 0; // 糖果数目 public GumballMachine(int count) { this.count = count; // 初始糖果机的糖果数 if (count &gt; 0) { // 大于0表示等待别人投币 state = NO_QUARTER; } } // 投进25分钱 public void insertQuarter() { if (state == HAS_QUARTER) { System.out.println(&quot;你已经投过25分钱了，请不要重复投币&quot;); } else if (state == NO_QUARTER) { System.out.println(&quot;投进25分钱&quot;); state = HAS_QUARTER; } else if (state == SOLD_OUT) { System.out.println(&quot;没有糖果了，不要投币&quot;); } else if (state == SOLD) { System.out.println(&quot;请稍等，正在出糖果&quot;); } } // 客户尝试退钱 public void ejectQuarter() { if (state == HAS_QUARTER) { System.out.println(&quot;已退还25分钱&quot;); state = NO_QUARTER; } else if (state == NO_QUARTER) { System.out.println(&quot;你还没投币呢&quot;); } else if (state == SOLD_OUT) { System.out.println(&quot;没有糖果时无法投币，不要骗钱&quot;); } else if (state == SOLD) { System.out.println(&quot;你已经转动曲柄了，无法退钱&quot;); } } // 客户转动曲柄 public void turnCrank() { if (state == HAS_QUARTER) { System.out.println(&quot;你转动了曲柄&quot;); state = SOLD; dispense(); } else if (state == NO_QUARTER) { System.out.println(&quot;你还没投币呢&quot;); } else if (state == SOLD_OUT) { System.out.println(&quot;已经没有糖果了&quot;); } else if (state == SOLD) { System.out.println(&quot;转几次都只能拿一次&quot;); } } // 糖果机发糖果 public void dispense() { if (state == SOLD) { System.out.println(&quot;糖果已发出&quot;); count--; if (count == 0) { System.out.println(&quot;已经没有糖果喽&quot;); state = SOLD_OUT; } else { state = NO_QUARTER; } } else if (state == NO_QUARTER) { System.out.println(&quot;你还没投币呢&quot;); } else if (state == SOLD_OUT) { System.out.println(&quot;没有糖果发&quot;); } else if (state == SOLD) { System.out.println(&quot;没有糖果发&quot;); } }} 多么缜密的判断，基本上没什么漏洞了。 新需求现在产品经理提需求来了：当曲柄被转动时，有 10% 的几率掉出两个糖果。 看回上面缜密的代码，是不是有点无从入手？这个需求真是要了命了……如果需求再有变更，上面的代码基本上就得推倒重来了，因为代码逻辑判断太复杂。 满足需求我们可以把这四个状态当作一个实体，比如糖果机当前处在没投币的状态，那么在该状态下，可以通过投币动作使糖果机转移到投了币状态，其他状态也是这样，基本上可以把 if else 这些判断语句分离出来。 定义状态接口： 123456789interface State { void insertQuarter(); void ejectQuarter(); void turnCrank(); void dispense();} 然后每种状态都实现该接口（先看总体）： 12345678910class SoldState implements Stateclass SoldOutState implements Stateclass NoQuarterState implements Stateclass HasQuarterState implements State// 新需求中的“中奖状态”class WinnerState implements State 还有新的糖果机（还没添加中奖状态）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class GumballMachine { private State soldState; private State soldOutState; private State noQuarterState; private State hasQuarterState; private State state = soldState; private int count = 0; public GumballMachine(int count) { soldState = new SoldState(this); soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); this.count = count; if (count &gt; 0) { state = noQuarterState; } } public void insertQuarter() { state.insertQuarter(); } public void ejectQuarter() { state.ejectQuarter(); } // 转动曲柄后 // 具体是否能发出糖果就需要当前状态是 hasQuarterState public void turnCrank() { state.turnCrank(); state.dispense(); } public void setState(State state) { this.state = state; } // 不再通过 dispense 发放糖果 public void releaseBall() { System.out.println(&quot;糖果已发出&quot;); if (count != 0) { count--; } } // getter public State getState() { return state; } public int getCount() { return count; } public State getSoldState() { return soldState; } public State getSoldOutState() { return soldOutState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; }} 分别实现的状态类 没投币的状态： 12345678910111213141516171819202122232425262728class NoQuarterState implements State { private GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(&quot;投进25分钱&quot;); gumballMachine.setState(gumballMachine.getHasQuarterState()); } @Override public void ejectQuarter() { System.out.println(&quot;你还没投币呢，怎么退钱&quot;); } @Override public void turnCrank() { System.out.println(&quot;你转动了曲柄，但你还没投币呢&quot;); } @Override public void dispense() { System.out.println(&quot;你要先投币&quot;); }} 投了币的状态： 1234567891011121314151617181920212223242526272829class HasQuarterState implements State { private GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(&quot;你已经投过25分钱了，请不要重复投币&quot;); } @Override public void ejectQuarter() { System.out.println(&quot;已退还25分钱&quot;); gumballMachine.setState(gumballMachine.getNoQuarterState()); } @Override public void turnCrank() { System.out.println(&quot;你转动了曲柄&quot;); gumballMachine.setState(gumballMachine.getSoldState()); } @Override public void dispense() { System.out.println(&quot;没有糖果发&quot;); }} 售出糖果的状态： 123456789101112131415161718192021222324252627282930313233class SoldState implements State { private GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(&quot;请稍等，正在出糖果&quot;); } @Override public void ejectQuarter() { System.out.println(&quot;你已经转动曲柄了，无法退钱&quot;); } @Override public void turnCrank() { System.out.println(&quot;转几次都只能拿一次&quot;); } @Override public void dispense() { gumballMachine.releaseBall(); if (gumballMachine.getCount() &gt; 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { System.out.println(&quot;已经没有糖果喽&quot;); gumballMachine.setState(gumballMachine.getSoldOutState()); } }} 糖果售罄的状态： 123456789101112131415161718192021222324252627class SoldOutState implements State { private GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(&quot;没有糖果了，不要投币&quot;); } @Override public void ejectQuarter() { System.out.println(&quot;没有糖果时无法投币，不要骗钱&quot;); } @Override public void turnCrank() { System.out.println(&quot;你转动了曲柄，但是已经没有糖果了&quot;); } @Override public void dispense() { System.out.println(&quot;没有糖果发&quot;); }} 新需求中的中奖状态： 123456789101112131415161718192021222324252627282930313233343536373839404142class WinnerState implements State { private GumballMachine gumballMachine; public WinnerState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(&quot;请稍等，正在出糖果&quot;); } @Override public void ejectQuarter() { System.out.println(&quot;你已经转动曲柄了，无法退钱&quot;); } @Override public void turnCrank() { System.out.println(&quot;转几次都只能拿一次&quot;); } // 除了发糖外，其他信息和售出糖果的状态一样 @Override public void dispense() { System.out.println(&quot;恭喜！你拿到了两颗糖&quot;); // 第一颗糖 gumballMachine.releaseBall(); if (gumballMachine.getCount() == 0) { gumballMachine.setState(gumballMachine.getSoldOutState()); } else { // 第二颗糖 gumballMachine.releaseBall(); if (gumballMachine.getCount() &gt; 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { System.out.println(&quot;已经没有糖果喽&quot;); gumballMachine.setState(gumballMachine.getSoldOutState()); } } }} 需求还没解决完上面的代码只是解决了状态的问题，但还没有完全满足需求，10% 的随机中奖还没写。（其实也没什么难度了） 给糖果机加上中奖状态： 123456789101112131415class GumballMachine { // ... private State winnerState; public GumballMachine(String location, int count) { winnerState = new WinnerState(this); // ... } public State getWinnerState() { return winnerState; } // ...} 因为只有在投了币的情况下才能转动曲柄 -&gt; 发糖 | 中奖，所以要在投了币的状态加入这 10% 随机： 123456789101112131415161718class HasQuarterState implements State { // ... @Override public void turnCrank() { System.out.println(&quot;你转动了曲柄&quot;); Random randomWinner = new Random(System.currentTimeMillis()); // 中奖 // 10次里面有一次是0，即 1/10 int winner = randomWinner.nextInt(10); if (winner == 0 &amp;&amp; gumballMachine.getCount() &gt; 1) { gumballMachine.setState(gumballMachine.getWinnerState()); } else { gumballMachine.setState(gumballMachine.getSoldState()); } } // ...","link":"/2018/04/05/zh/programing/book_read/java/head_first_design_pattern/9_state/"},{"title":"《Java 8 函数式编程》笔记1","text":"前记在图书馆找有关 Java 的书时发现了这本动物出版社的书，大一时就听过 lambda，匿名函数之类的了（虽然两者不同），一直没机会接触前者，鉴于前段时间写的程序有好多匿名函数，很是冗余，本着好奇以及打算重构的心，就借来这本书打算学习一遍 lambda。本笔记按照章节顺序从第 2 章开始。 纸质书读起来很有滋味，建议买来或借来品味一番。 随书的资料在作者的 github 中可以下载到。 本笔记代码也全部放在 github 中，建议搭配代码食用~ 设置断言Idea 和 Eclipse 都是默认不开启断言的，请先设置好。 lambda 表达式第一行 lambda使用匿名类将按钮和点击行为关联起来： 123456button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent event) { System.out.println(&quot;clicked&quot;); }}); 使用 lambda 表达式： 1button.addActionListener(event -&gt; System.out.println(&quot;clicked&quot;)); 匿名类： 方法参数类型需要显式声明：ActionEvent event lambda： 无需指定类型，javac 根据上下文推断出 event 的类型（addActionListener 方法的签名） 注： lambda 声明参数时也可以包括参数类型（比如：(int x, int y) -&gt; x + y）； 有时编译器不一定能根据上下文推断出参数类型，这时要显示声明。 lambda 表达式的不同形式： 12345678910111213141516171819202122// 该 Runnable 接口只有 1 个 void run() 方法// 使用空括号 () 表示没有参数Runnable noArguments = () -&gt; System.out.println(&quot;Hello&quot;);// 只有 1 个参数，可省略括号ActionListener oneArgument = event -&gt; System.out.println(&quot;clicked&quot;);// lambda 主体不仅可以是表达式，也可以是一段代码块// 用大括号 {} 括起来的代码块// 遵循的规则和普通方法一样Runnable multiStatement = () -&gt; { System.out.println(&quot;Hello 1&quot;); System.out.println(&quot;Hello 2&quot;);};// 显式声明参数类型BinaryOperator&lt;Integer&gt; addExplicitType = (Integer x, Integer y) -&gt; x + y;// 这段代码是创建一个函数，用来计算出两个数字相加的结果// add 不是两个数字的和，而是将两个数字相加的那行代码BinaryOperator&lt;Integer&gt; add = (x, y) -&gt; x + y;System.out.println(add.apply(1, 2)); 引用值，而不是变量匿名类中使用所在方法的变量时需要 final 修饰： 12345678final String username = getUsername();button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent event) { System.out.println(username + &quot; clicked&quot;); }}); lambda 表达式中使用时虽然可以没有 final 修饰符，但实际上仍是 final 变量： 123String username = getUsername();button.addActionListener(event -&gt; System.out.println(username + &quot; clicked&quot;)); 使用 final 变量，实际上就是使用赋给该变量的一个特定值。 函数接口函数接口：只有 1 个抽象方法的接口，用作 lambda 表达式的类型。 比如 ActionListener 接口： 123public abstract ActionListener extends EventListener { public abstract void actionPerformed(ActionEvent event);} 该单一抽象方法的命名并不重要，只要方法签名和 lambda 表达式的类型匹配即可。 一些最重要的函数接口： 接口 参数 返回类型 示例 Predicate T boolean 这张唱片发行了吗 Consumer T void 输出一个值 Function&lt;T, R&gt; T R 获得 A 对象的名字 Supplier None T 工厂方法 UnaryOperator T T 逻辑非(!) BinaryOperator (T,T) T 求两个数的和(+)","link":"/2018/03/05/zh/programing/book_read/java/java8_lambdas/1_lambda/"},{"title":"《Java 8 函数式编程》笔记2","text":"流从外部迭代到内部迭代使用 for 循环统计来自美国的艺术家： 1234567int count = 0;for(Artist artist: allArtists) { if(artist.isFrom(&quot;US&quot;)) { count++; }} for 循环本质是封装了迭代的语法糖，外部迭代： 123456789int count = 0;Iterator&lt;Artist&gt; iterator = allArtists.iterator();while(iterator.hasNext()) { Artist artist = (Artist) iterator.next(); if(artist.isFrom(&quot;US&quot;)) { count++; }} 外部迭代本质上是一种串行化操作。 使用内部迭代改写： 12345// stream() 方法和上面的 iterator() 作用一样// 但该方法返回的是内部迭代中的相应接口：Streamint count = allArtists.stream() .filter(artist -&gt; artist.isFrom(&quot;US&quot;)) .count(); 注：Stream 是用函数式编程方式在集合类上进行复杂操作的工具 内部迭代的实现机制只过滤，不计数： 12allArtists.stream() .filter(artist -&gt; artist.isFrom(&quot;London&quot;)); filter 只是刻画出了 Stream，并没有产生新的集合。 这些不产生新集合方法叫：惰性求值方法； 像 count 这样最终会从 Stream 产生值的方法叫：及早求值方法。 即使在 filter 过滤器中加上 println，也不会输出任何信息： 12345allArtists.stream() .filter(artist -&gt; { System.out.println(artist.getName); return artist.isFrom(&quot;London&quot;); }); 但只要加入一个拥有终止操作的流，艺术家的名字就会被输出： 123456allArtists.stream() .filter(artist -&gt; { System.out.print(artist.getName); return artist.isFrom(&quot;London&quot;); }) .count(); 如何判断一个操作是惰性求值还是及早求值？ 看它的返回值： 返回值是 Stream：惰性求值； 返回值是另一个值或 null：及早求值。 常用的流操作collect()由 Stream 里的值生成一个 List、Set、Map 或其他。 比如，生成 List： 123456// 使用 Stream 的 of 方法：// 由一组初始值生成新的 StreamList&lt;String&gt; collected = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) .collect(Collectors.toList());assert Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).equals(collected); map将一个流中的值转换为一个新的流。 该 lambda 表达式的函数接口是 Function。 比如，将一组字符串都转为大小形式： 12345List&lt;String&gt; collected = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;abc&quot;) .map(string -&gt; string.toUpperCase()) .collect(Collectors.toList());assert Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;ABC&quot;).equals(collected); filter保留 Stream 中符合条件的元素，而过滤掉其他的。 该 lambda 表达式的函数接口是 Predicate。 比如，找出一组字符串中以数字开头的字符串： 12345List&lt;String&gt; startWithDigits = Stream.of(&quot;1a&quot;, &quot;b&quot;, &quot;abc&quot;) .filter(string -&gt; isDigit(string.charAt(0))) .collect(Collectors.toList());assert Arrays.asList(&quot;1a&quot;).equals(startWithDigits); flatMap将多个 Stream 连接成一个 Stream。 该 lambda 表达式的函数接口是 Function，返回值是 Stream。 比如，一个包含多个列表的 Stream 连接成只有一个列表的 Stream： 12345List&lt;Integer&gt; together = Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4)) .flatMap(numbers -&gt; numbers.stream()) .collect(Collectors.toList());assert Arrays.asList(1, 2, 3, 4).equals(together); max 和 min找出 Stream 中的最大最小值。 比如，找出播放长度最短的曲目： 12345678910List&lt;Track&gt; tracks = Arrays.asList( new Track(&quot;BaKai&quot;, 524), new Track(&quot;Violets&quot;, 378), new Track(&quot;Time Was&quot;, 451)); Track shortestTrack = tracks.stream() .min(Comparator.comparing(track -&gt; track.getLength())) .get();assert tracks.get(1).equals(shortestTrack); reduce从一组值中生成一个值，上面用到的 count、min 和 max 方法都属于 reduce 操作。因为常用而被纳入标准库。 比如，求和： 12345// 0 是初始值，acc 是累加器int count = Stream.of(1, 2, 3) .reduce(0, (acc, element) -&gt; acc + element);assert 6 == count; 阶乘： 123BigInteger k = Stream.iterate(BigInteger.ONE, x -&gt; x.add(BigInteger.ONE)) .limit(n) .reduce(BigInteger.ONE, (m, current) -&gt; m.multiply(current)); 整合操作举例说明如何把问题分解成简单的 Stream 操作： 如何找出某张专辑上乐队所有成员的国籍？ 将问题分解： 找出专辑上的所有表演者 分辨出哪些表演者是乐队 找出乐队每个中每个成员的国籍 将找出的国籍放在一个集合里 找出对应的 Stream API： 专辑 Album 类有 getMusicians 方法，该方法返回一个 Stream 对象，包含整张专辑中所有的表演者 使用 filter 方法对表演者进行过滤，只保留乐队 使用 flatMap 方法将乐队成员加入流中 使用 map 方法将成员映射为其所属国家 使用 collect 方法将找出的国籍放到集合里 12345Set&lt;String&gt; origins = album.getMusicians() .filter(artist -&gt; artist.getName().startsWith(&quot;The&quot;)) .flatMap(artist -&gt; artist.getMembers()) .map(member -&gt; member.getNationality()) .collect(Collectors.toSet());","link":"/2018/03/05/zh/programing/book_read/java/java8_lambdas/2_stream/"},{"title":"《Java 8 函数式编程》笔记3","text":"类库默认方法Collection 接口中新增了 stream 方法，如果继承它的子类没有实现 stream 方法，就使用它的 stream 方法，这样的方法叫默认方法。 Iterable 接口中也新增了一个默认方法：forEach，允许用户使用 lambda 表达式作为循环体。 JDK 中 forEach 的实现方法： 12345default void forEach(Consumer&lt;? super T&gt; action) { for (T t : this) { action.accept(t); }} 默认方法和子类 Parent 接口定义了默认方法 welcome，而 ParentImpl 类没有实现 welcome 方法，因此它自然继承了默认方法。 123456789101112131415161718192021222324252627282930313233public class Main { public static void main(String[] args) { Parent parent = new ParentImpl(); parent.welcome(); assert &quot;Parent: Hi!&quot;.equals(parent.getLastMessage()); }}// 实现接口时没有实现 welcomeclass ParentImpl implements Parent { String body; @Override public void message(String body) { this.body = body; } @Override public String getLastMessage() { return this.body; }}interface Parent { void message(String body); // 默认方法 default void welcome() { message(&quot;Parent: Hi!&quot;); } String getLastMessage();} 新增一个 Child 接口，该类继承 Parent 接口，并且重写 Parent 的默认方法： 1234567891011121314151617181920212223242526272829303132333435363738public class Main { public static void main(String[] args) { Child child = new ChildImpl(); child.welcome(); assert &quot;Child: Hi!&quot;.equals(child.getLastMessage()); }}class ChildImpl implements Child { String body; @Override public void message(String body) { this.body = body; } @Override public String getLastMessage() { return this.body; }}interface Child extends Parent { @Override default void welcome() { message(&quot;Child: Hi!&quot;); }}interface Parent { void message(String body); default void welcome() { message(&quot;Parent: Hi!&quot;); } String getLastMessage();} 现在，默认方法成了虚方法。任何时候，一旦子类定义的方法和父类的产生冲突，都会优先选择子类定义的方法： 12345678910111213141516171819202122232425262728293031323334353637383940public class Main { public static void main(String[] args) { Parent parent = new OverridingParent(); // 调用的是类的具体方法，而不是默认方法 parent.welcome(); assert &quot;Override Parent&quot;.equals(parent.getLastMessage()); }}class OverridingParent extends ParentImpl { // 重写 welcome 默认实现的父类 @Override public void welcome() { message(&quot;Override Parent&quot;); }}class ParentImpl implements Parent { String body; @Override public void message(String body) { this.body = body; } @Override public String getLastMessage() { return this.body; }}interface Parent { void message(String body); default void welcome() { message(&quot;Parent: Hi!&quot;); } String getLastMessage();} 新增 OverridingChild 类，该类本身并没有任何操作，只是继承 Child 接口和 OverridingParent 类。但调用的 welcome 方法来自 OverridingParent 类。 原因：与 Child 接口定义的默认方法相比，OverridingParent 类中重写后的 welcome 方法更具体。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Main { public static void main(String[] args) { Child child = new OverridingChild(); child.welcome(); assert &quot;Override Parent&quot;.equals(child.getLastMessage()); }}class OverridingChild extends OverridingParent implements Child {}class OverridingParent extends ParentImpl { @Override public void welcome() { message(&quot;Override Parent&quot;); }}interface Child extends Parent { @Override default void welcome() { message(&quot;Child: Hi!&quot;); }}class ParentImpl implements Parent { String body; @Override public void message(String body) { this.body = body; } @Override public String getLastMessage() { return this.body; }}interface Parent { void message(String body); default void welcome() { message(&quot;Parent: Hi!&quot;); } String getLastMessage();} 多重继承接口允许多重继承，因此有可能遇到 2 个接口包含签名相同的默认方法的情况： 1234567891011121314151617// 编译器会报错// 因为 javac 不明确继承了哪个接口的 rock 方法class MusicalCarriage implements Carriage, Jukebox {}interface Jukebox { default String rock() { return &quot;...all over the world&quot;; }}interface Carriage { default String rock() { return &quot;...from side to side&quot;; }} 解决：可以使用增强的 super 语法，指定使用某个接口的默认方法。 123456class MusicalCarriage implements Carriage, Jukebox { @Override public String rock() { return Carriage.super.rock(); }} 三定律 如果对多重继承下的默认方法工作原理没有把握，可以参考以下3条： 类 &gt; 接口。如果继承链中有方法体或抽象的方法声明，那就可以忽略接口中定义的方法。 子类 &gt; 父类。如果一个接口继承了另一个接口，且两个接口都定义了一个默认方法，则子类优先。 没有3。如果以上2条不适用，子类要么实现该方法，要么将该方法声明为抽象方法。 OptionalOptional 是核心类库新设计的数据类型，用来替换 null 值。 Optional 对象相当于值的容器，可以使用 get() 获得该值。 创建某个值的 Optional 对象： 12Optional&lt;String&gt; a = Optional.of(&quot;a&quot;);assert &quot;a&quot;.equals(a.get()); Optional 对象可以为空： 12345678910// 创建空 Optional 对象Optional&lt;String&gt; emptyOptional = Optional.empty();// 将空值转换为空 Optional 对象Optional&lt;String&gt; alsoEmpty = Optional.ofNullable(null);// isPresent() 检查 Optional 对象是否有值assert emptyOptional.isPresent() == false;assert alsoEmpty.isPresent() == false; 但对象为空时，如果希望使用备选值，可以使用 orElse。如果备选值计算太繁琐，可以使用 orElseGet，该方法接受 Supplier 对象。 1234567Optional&lt;String&gt; emptyOptional = Optional.empty();Optional&lt;Integer&gt; alsoEmpty = Optional.ofNullable(null);assert &quot;b&quot;.equals(emptyOptional.orElse(&quot;b&quot;));assert 3 == alsoEmpty.orElseGet(() -&gt; 1 + 2);","link":"/2018/03/05/zh/programing/book_read/java/java8_lambdas/3_class/"},{"title":"《Java 8 函数式编程》笔记4","text":"高级集合类和收集器方法引用标准语法：Classname::methodName 比如想得到艺术家的名字： 12345lambda：artist -&gt; artist.getName()方法引用：Artist::getNameArrays.stream(artist).map(Artist::getName).forEach(System.out::println) 构造方法同样可以缩写： 123lambda：(name, nationality) -&gt; new Artist(name, nationality)方法引用：Artist::new 元素顺序本身是有序集合，比如 List，创建流时，流中的元素就有顺序： 123456List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; sameOrder = numbers.stream() .collect(Collectors.toList());assert sameOrder.equals(numbers); 本身是无序集合，比如 HashSet，由此生成的流也是无序的： 123456Set&lt;Integer&gt; numbers = new HashSet&lt;&gt;(Arrays.asList(4, 3, 2, 1));List&lt;Integer&gt; sameOrder = numbers.stream() .collect(Collectors.toList());// 断言有时会失败assert Arrays.asList(4, 3, 2, 1).equals(sameOrder); 可以使用 sorted()，让流里的元素有序： 1234567Set&lt;Integer&gt; numbers = new HashSet&lt;&gt;(Arrays.asList(4, 3, 2, 1));List&lt;Integer&gt; sameOrder = numbers.stream() .sorted() .collect(Collectors.toList());assert Arrays.asList(1, 2, 3, 4).equals(sameOrder); 或者使用 unordered()，变无序： 1234567Set&lt;Integer&gt; numbers = new HashSet&lt;&gt;(Arrays.asList(4, 3, 2, 1));List&lt;Integer&gt; sameOrder = numbers.stream() .unordered() .collect(Collectors.toList());assert Arrays.asList(4, 3, 2, 1).equals(sameOrder); 使用收集器collect(Collectors.toList())，在流中生成列表。类似的还有 Map、Set 等。 转换为其他集合比如转换为 TreeSet，而不是框架背后为你指定的一种类型的 Set： 123List&lt;Integer&gt; numbers = Arrays.asList(4, 3, 2, 1);Set&lt;Integer&gt; treeSet = numbers.stream() .collect(Collectors.toCollection(TreeSet::new)); 转换为值maxBy 和 minBy 找出成员最多的乐队： 1234public Optional&lt;Artist&gt; biggestGroup(Stream&lt;Artist&gt; artists) { Function&lt;Artist, Long&gt; getCount = artist -&gt; artist.getMembers().count(); return artists.collect(maxBy(comparing(getCount)));} 找出一组专辑上单曲的平均数： 123public double averageNumberOfTracks(List&lt;Album&gt; albums) { return albums.stream().collect(averagingInt(album -&gt; album.getTrackList().size()));} 数据分块假设有一个艺术家组成的流，一部分是独唱歌手，另一部分是乐队。如果你希望将其分成两部分，可以使用收集器 partitioningBy，它接受一个流， 并将其分成两部分： 123public Map&lt;Boolean, List&lt;Artist&gt;&gt; soloAndBands(Stream&lt;Artist&gt; artists) { return artists.collect(partitioningBy(Artist::isSolo));} 数据分组与将数据分成 true 和 false 两块不同，数据分组是一种更自然的分割数据操作，可以使用任意值对数据分组。 比如，现在有一个专辑组成的流，可以按专辑当中的乐队主唱对专辑分组： 123public Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist(Stream&lt;Album&gt; albums) { return albums.collect(groupingBy(Album::getMainMusician));} 字符串比如要得到 “[{A, B, C}]” 这样的字符串： 12345public String getString() { List&lt;String&gt; strings = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;); return strings.stream() .collect(Collectors.joining(&quot;, &quot;, &quot;[{&quot;, &quot;}]&quot;));} Collectors.joining(分隔符, 前缀, 后缀) 组合收集器如何计算一个艺术家的发行的专辑数量？ 最简单的就是使用前面的方法：对专辑先按艺术家分组，然后计数： 123456Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist = albums.collect(groupingBy(Album::getMainMusician));Map&lt;Artist, Integer&gt; numberOfAlbums = new HashMap&lt;&gt;();for (Entry&lt;Artist, List&lt;Album&gt;&gt; entry : albumsByArtist.entrySet()) { numberOfAlbums.put(entry.getKey(), entry.getValue().size());} 这段代码固然简单，但有点杂乱，命令式的代码，也无法自动适应并行化的操作。 使用 counting 重写： 1234Map&lt;Artist, Long&gt; numberOfAlbums = albums.collect( groupingBy(Album::getMainMusician, counting())); groupingBy 先将元素分块，每块都与 getMainMusician 提供的键相关联，然后使用下游的另一个收集器收集每块中的元素，最后将结果映射为 Map。 另一个例子：如何获得每个艺术家的每张专辑名，而不是每张专辑？ 123456789Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist = albums.collect(groupingBy(Album::getMainMusician));Map&lt;Artist, List&lt;String&gt;&gt; nameOfAlbums = new HashMap&lt;&gt;();for (Entry&lt;Artist, List&lt;Album&gt;&gt; entry : albumsByArtist.entrySet()) { nameOfAlbums.put(entry.getKey(), entry.getValue() .stream() .map(Album::getName) .collect(toList()));} groupingBy 将专辑按主唱分组，输出了 Map&lt;Artist, List&lt;Album&gt;&gt;，它将每个艺术家和他的专辑列表关联起来。 但我们需要的是 Map&lt;Artist, List&lt;String&gt;&gt;，将每个艺术家和他的专辑名列表关联起来。 mapping 可以像 map 一样将 groupingBy 的值做映射，生成我们想要的结果： 12345albums.collect( groupingBy(Album::getMainMusician, mapping(Album::getName, toList()))); Map 类的变化用 Map 实现缓存，传统方法：先试着取值，如果值为空，创建一个新值并返回。 12345678public Artist getArtist(String name) { Artist artist = artistCache.get(name); if (artist == null) { artist = readArtistFromDB(name); artistCache.put(name, artist); } return artist;} computeIfAbsent 方法会在值不存在时，使用 lambda 表达式计算新值： 123public Artist getArtistUsingComputeIfAbsent(String name) { return artistCache.computeIfAbsent(name, this::readArtistFromDB);} 你可能试过在 Map 上迭代，比如： 123456789Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist = albums.collect(groupingBy(Album::getMainMusician));Map&lt;Artist, Integer&gt; numberOfAlbums = new HashMap&lt;&gt;();for (Entry&lt;Artist, List&lt;Album&gt;&gt; entry : albumsByArtist.entrySet()) { Artist artist = entry.getKey(); List&lt;Album&gt; albums = entry.getValue(); numberOfAlbums.put(artist, albums.size());} 虽然工作正常，但是看起来挺丑的。 使用 forEach 内部迭代 Map 里的值： 1234567Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist = albums.collect(groupingBy(Album::getMainMusician));Map&lt;Artist, Integer&gt; numberOfAlbums = new HashMap&lt;&gt;();albumsByArtist.forEach( (artist, albumList) -&gt; numberOfAlbums.put(artist, albumList.size()));","link":"/2018/03/05/zh/programing/book_read/java/java8_lambdas/4_collect/"},{"title":"《Java 8 函数式编程》笔记5","text":"数据并行化并行和并发并行：两个任务在同一时间发生，比如在多核 CPU 上，A 任务在三核，B 任务在四核。并发：两个任务共享时间段，比如在 1s 内 A 任务和 B 任务交替运行 0.5s。 并行化流操作在一个 Stream 对象上调用 parallel 方法即可拥有并行操作的能力。如果想从一个集合类创建一个流，调用 parallelStream 即可获得拥有并行能力的流。 串行化计算所有专辑曲目长度： 123456public int serialArraySum(List&lt;Album&gt; albums) { return albums.stream() .flatMap(Album::getTracks) .mapToInt(Track::getLength) .sum();} 改成调用 parallelStream 方法并行处理： 123456public int parallelArraySum(List&lt;Album&gt; albums) { return albums.parallelStream() .flatMap(Album::getTracks) .mapToInt(Track::getLength) .sum();} 并行并不一定比串行快，要视情况选用，后面的性能小节会详细说明。 模拟系统暂略 限制虽然只需一点改动就能让已有代码使用并行流工作，但前提是代码写得符合约定，所以写代码是必须遵守一些规则和限制。 比如，reduce 方法的初始值可以是任意值。但为了让其在并行化时能工作正常，初值必须为组合函数的恒等值。举个栗子：使用 reduce 操作求和时，组合函数为 (acc, element) -&gt; acc + element，则其初值必须为 0。因为任何数字加 0，值不变。 reduce 操作的另一个限制是组合操作必须符合结合律。（只要序列值不变，组合操作的顺序就不重要）举个栗子： (4 + 2) + 1 = 4 + (2 + 1) = 7、(4 x 2) x 1 = 4 x (2 x 1) = 8。 避免持有锁。流框架会在需要时自己处理同步操作。 parallel 并行和 sequential 串行不能同时使用在流上，要么并行，要么串行。如果同时使用，只有最后调用的那个方法生效。 性能影响并行流性能的主要 5 个因素： 数据大小将问题分解之后并行化处理，再将结果合并会带来额外的开销。因此只有在数据足够大时，每个数据处理管道花费的时间足够多时，并行化处理才有意义。 源数据结构每个管道的操作都基于一些初始数据源，通常是集合。将不同的数据源分割相对容易，这里的开销影响了在管道中并行处理数据是到底能带来多少性能上的提升。 装箱处理基本类型比处理装箱类型要快。 核的数量极端情况下，只有一个核，因此完全没必要并行化。核的数量不单指你的机器上有多少核，更是指运行时你的机器能使用多少核。这也就是说同时运行的其他进程，或者线程关联性（强制线程在某些核或 CPU 上运行）会影响性能。 单元处理开销比如数据大小，这是一场并行执行花费时间和分解合并操作开销之间的战争。花在流中每个元素身上的时间越长，并行操作带来的性能提升越明显。 根据性能的好坏，将核心类库提供的通用数据结构分成以下 3 组： 性能好ArrayList、数组或 IntStream.range，这些数据结构支持随机读取，也就是它们能轻而易举地被任意分解。 性能一般HashSet、TreeSet，这些数据结构不易公平地被分解，但是大多数时候分解是可能的。 性能差有些数据结构难于分解，比如，可能要花 O(N) 的时间复杂度来分解问题。其中包括 LinkedList，对半分解太难了。还有 Streams.iterate 和 BufferedReader.lines，它们长度未知，因此很难预测该在哪里分解。 选用无状态操作，而不是有状态，就能获得更好的并行性能。无状态操作： map、filter、flatMap。有状态操作：sorted、distinct、limit。 并行化数组操作数组上的并行化操作： 方法名 操作 parallelPrefix 任意给定一个函数，计算数组的和 parallelSetAll 使用 lambda 表达式更新数组元素 parallelSort 并行化对数组元素排序 for 循环初始化数组： 1234567public double[] imperativeInitialize(int size) { double[] values = new double[size]; for (int i = 0; i &lt; values.length; i++) { values[i] = i; } return values;} 使用 parallelSetAll 并行化以上过程： 12345public double[] imperativeInitializeParallelSetAll(int size) { double[] values = new double[size]; Arrays.parallelSetAll(values, i -&gt; i); return values;}","link":"/2018/03/05/zh/programing/book_read/java/java8_lambdas/5_parallel/"},{"title":"《Java 8 函数式编程》笔记6","text":"测试、调试和重构孤独的覆盖ThreadLocal 能创建一个工厂，为每个线程最多只产生一个值。这是确保非线程安全的类在并发环境下安全使用的一种简单方式。 假设要在数据库查询一个艺术家，但希望每个线程值做一次这种查询： 123456ThreadLocal&lt;Album&gt; thisAlbum = new ThreadLocal&lt;Album&gt;() { @Override protected Album initialValue() { return database.findCurrentAlbum(); }}; 为工厂方法 withInitial 传入一个 Supplier 对象实例来创建对象： 123ThreadLocal&lt;Album&gt; thisAlbum = ThreadLocal.withInitial( () -&gt; database.findCurrentAlbum()); 同样的东西写两遍DRY：Don’t Repeat YourselfWET：Write Everything Twice 不是所有的 WET 都适合 lambdas 化。有时重复是唯一可以避免系统过紧耦合的方式。 什么时候该将 WET 的代码 lambda 化？如果有一个整体上大概相似的模式，只是行为上有所不同，就可以试着加入一个 lambda 表达式。 举个栗子： 用户想要了解购买的专辑的一些信息，比如音乐家的人数、曲目和专辑时长等。 使用命令式 Java 编写的 Order 类： 12345678910111213141516171819202122232425public long countMusicians() { long count = 0; for (Album album : albums) { count += album.getMusicianList().size(); } return count;}public long countTracks() { long count = 0; for (Album album : albums) { count += album.getTrackList().size(); } return count;}public long countRunningTime() { long count = 0; for (Album album : albums) { for (Track track : album.getTrackList()) { count += track.getLength(); } } return count;} 每个方法里，都有样板代码将将每个专辑里的属性和总数相加。没有重用共有的概念，写出了更多需要测试和维护的代码。 新增 OrderStream 类，使用 Stream 来抽象 Order 类： 12345678910111213141516171819public long countMusicians() { return albums.stream() .mapToLong(album -&gt; album.getMusicians().count()) .sum();}public long countTracks() { return albums.stream() .mapToLong(album -&gt; album.getTracks().count()) .sum();}public long countRunningTime() { return albums.stream() .mapToLong(album -&gt; album.getTracks() .mapToLong(Track::getLength) .sum()) .sum();} 然而这段代码仍然有重用可读性的问题，因为有一些抽象和共性只能使用领域内的知识来表达。流不会提供一个方法统计每张专辑上的信息——这是程序猿自己要编写的领域知识。 新增 OrderStreamDSL 类，用领域方法重构 OrderStream 类： 12345678910111213141516171819private long countFeature(ToLongFunction&lt;Album&gt; function) { return albums.stream() .mapToLong(function) .sum();}public long countMusicians() { return countFeature(album -&gt; album.getMusicians().count());}public long countTracks() { return countFeature(album -&gt; album.getTracks().count());}public long countRunningTime() { return countFeature(album -&gt; album.getTracks() .mapToLong(Track::getLength) .sum());}","link":"/2018/03/05/zh/programing/book_read/java/java8_lambdas/6_test/"},{"title":"《Java 8 函数式编程》笔记7","text":"设计和架构的原则命令者模式命令者是一个对象，它封装了调用另一个方法的所有细节，命令者模式使用该对象，可以编写出根据运行期条件，顺序调用方法的一般化代码。 命令者模式中有四个类参与其中： 命令接收者执行实际任务 命令者封装了所有调用命令执行者的信息 发起者控制一个或多个命令的顺序和执行 客户端创建具体的命令者实例 1234567891011[发起者] -&gt; [命令者] ↑ ↑ |创建 |实现[客户端] -&gt; [具体命令者] 调用| ↓ [命令接收者] 举个栗子：假设有个 GUI Editor 组件，可以执行 open、save 等一系列操作。现在我们像实现宏功能——就是把一系列操作录下来，日后作为一个操作执行，这就是命令的接受者。 文本编辑器可能有的一般功能： 1234567public interface Editor { void save(); void open(); void close();} 像 open、save 这样的操作称为命令，我们需要一个统一的接口来概括这些不同的操作。 通过 Action 接口，所有操作均可实现： 123public interface Action { void perform();} 现在让每个操作都实现该接口： 123456789101112public class Save implements Action { private final Editor editor; Save(Editor editor) { this.editor = editor; } @Override public void perform() { editor.save(); }} 123456789101112public class Open implements Action { private final Editor editor; Open(Editor editor) { this.editor = editor; } @Override public void perform() { editor.open(); }} 123456789101112public class Close implements Action { private final Editor editor; Close(Editor editor) { this.editor = editor; } @Override public void perform() { editor.close(); }} 实现一个宏： 123456789101112131415161718public class Macro { // 一系列操作 private final List&lt;Action&gt; actions; Macro() { actions = new ArrayList&lt;&gt;(); } // 记录操作 void record(Action action) { actions.add(action); } // 运行一系列动作 void run() { actions.forEach(Action::perform); }} 别忘了实现一个具体的文本编辑器 EditorImpl： 12345678910111213141516public class EditorImpl implements Editor { @Override public void save() { System.out.println(&quot;success save&quot;); } @Override public void open() { System.out.println(&quot;success open&quot;); } @Override public void close() { System.out.println(&quot;success close&quot;); }} 现在就可以通过录制这些操作做一个宏，来方便自己的工作了： 命令者模式构建宏： 12345Macro macro = new Macro();macro.record(new Open(editor));macro.record(new Save(editor));macro.record(new Close(editor));macro.run(); lambda 表达式构建宏： 12345Macro macro = new Macro();macro.record(() -&gt; editor.open());macro.record(() -&gt; editor.save());macro.record(() -&gt; editor.close());macro.run(); 方法引用构建宏： 12345Macro macro = new Macro();macro.record(editor::open);macro.record(editor::save);macro.record(editor::close);macro.run(); 宏只是使用使用命令者模式中的一个例子，它被大量用在实现组件化的图形界面系统、撤销功能、线程池、事务和向导中。 策略模式策略模式能在运行时改变软件的算法模式。其主要思想是定义一个通用的问题。使用不同的算法来实现，然后将这些算法都封装在统一接口的背后。 以文件压缩为例，我们为用户提供压缩各种文件的方式，可以使用 zip 算法，也可以使用 gzip 算法，我们实现一个通用的 Compressor 类，能用任何算法压缩文件。 首先，为策略定义 API CompressionStrategy，每种文件压缩算法都要实现该接口。该接口有一个 compress 方法，接受并返回一个压缩后 OutputStream 对象。 12345压缩器 -调用-&gt; 压缩策略 ↗ ↖ 实现/ \\实现 / \\ zip压缩 gzip压缩 定义压缩数据的策略接口： 1234public interface CompressionStrategy { OutputStream compress(OutputStream data) throws IOException;} 使用 gzip 算法压缩数据： 123456public class GzipCompressionStrategy implements CompressionStrategy { @Override public OutputStream compress(OutputStream data) throws IOException { return new GZIPOutputStream(data); }} 使用 zip 算法压缩数据： 123456public class ZipCompressionStrategy implements CompressionStrategy { @Override public OutputStream compress(OutputStream data) throws IOException { return new ZipOutputStream(data); }} 压缩器 Compressor： 123456789101112131415public class Compressor { private final CompressionStrategy strategy; // 构造时使用用户提供的压缩策略 public Compressor(CompressionStrategy strategy) { this.strategy = strategy; } // 读入文件，根据策略压缩文件 public void compress(Path inFile, File outFile) throws IOException { try (OutputStream outputStream = new FileOutputStream(outFile)) { Files.copy(inFile, strategy.compress(outputStream)); } }} 到此就可以开始使用我们的压缩器来压缩文件了： 使用具体策略类初始化 Compressor： 12345Compressor gzipCompressor = new Compressor(new GzipCompressionStrategy());gzipCompressor.compress(inFile, outFile);Compressor zipCompressor = new Compressor(new ZipCompressionStrategy());zipCompressor.compress(inFile, outFile); 使用方法引用初始化 Compressor： 12345Compressor gzipCompressor = new Compressor(GZIPOutputStream::new);gzipCompressor.compress(inFile, outFile);Compressor zipCompressor = new Compressor(ZipOutputStream::new);zipCompressor.compress(inFile, outFile); 观察者模式观察者模式是另一种可被 lambda 表达式简化和改进的行为模式。在观察者模式中，被观察者持有一个观察者列表。当被观察者的状态发生改变，会通知观察者。 观察者模式被大量应用于基于 MVC 的 GUI 工具中，以此让模型状态发生变化时，自动刷新视图模块，达到二者之间的解耦。 举个栗子： NASA 和外星人都对登陆到月球上的东西感兴趣，都希望可以记录这些信息。NASA 希望确保阿波罗号上的航天员成功登月；外星人则希望在 NASA 注意力分散时进攻地球。 这里他们的观察对象就是登陆到月球的东西。 首先，定义观察者的 API LandingObserver，它只有 observeLanding 方法，当有东西登陆到月球上时会调用该方法： 123public interface LandingObserver { void observerLanding(String name);} 被观察者就是月球 Moon，它持有一组 LandingObserver 实例，有东西着陆时会通知这些观察者，还可以增加新的 LandingObserver 实例观测 Moon 对象： 1234567891011public class Moon { private final List&lt;LandingObserver&gt; observers = new ArrayList&lt;&gt;(); public void land(String name) { observers.forEach(observer -&gt; observer.observerLanding(name)); } public void startSpying(LandingObserver observer) { observers.add(observer); }} 外星人观察到阿波罗号登陆月球，就开始发出进攻地球的信号： 12345678public class Aliens implements LandingObserver { @Override public void observerLanding(String name) { if (name.contains(&quot;Apollo&quot;)) { System.out.println(&quot;They're distracted, lets invade earth!&quot;); } }} NASA 观察到阿波罗号登陆到月球，会很兴奋： 12345678public class Nasa implements LandingObserver { @Override public void observerLanding(String name) { if (name.contains(&quot;Apollo&quot;)) { System.out.println(&quot;We made it!&quot;); } }} 传统方式，就是使用以上写好的模版类 Aliens 和 Nasa 来调用： 123456Moon moon = new Moon();moon.startSpying(new Nasa());moon.startSpying(new Aliens());moon.land(&quot;An asteroid&quot;);moon.land(&quot;Apollo 11&quot;); 但使用 lambda 表达式的话，就不用写以上的模版类了： 1234567891011121314Moon moon = new Moon();moon.startSpying(name -&gt; { if (name.contains(&quot;Apollo&quot;)) { System.out.println(&quot;We made it!&quot;); }});moon.startSpying(name -&gt; { if (name.contains(&quot;Apollo&quot;)) { System.out.println(&quot;They're distracted, lets invade earth!&quot;); }});moon.land(&quot;An asteroid&quot;);moon.land(&quot;Apollo 11&quot;); 注意：无论是使用观察者还是策略模式，实现时采用 lambda 表达式，还是传统的类，取决于观察者和策略代码的复杂度。这里举的例子很简单，所以更能展示新的语言特性。 使用 lambda 表达式的 SOLID 原则SOLID 原则是涉及面向对象程序是的一些基本原则，分别是： Single responsibility Open/closed Liskov substitution Interface segregation Dependency inversion 这里主要关注如何 lambda 表达式的环境下应用其中的三条原则。 单一功能原则程序中的类或方法只能有一个改变的理由。 当软件的需求发生变化，实现这些功能的类和方法也需要变化。如果你的类有多个功能，一个功能引起的代码变化会影响该类其他功能。这可能会引入缺陷，还会影响代码演进的能力。 举个栗子：有一个程序，可以由资产列表生成 BalanceSheet 表格，然后输出一份 PDF 格式的报告。如果实现时将制表和输出功能都放进同一个类，那么该类就有两个变化的理由。你可能想改变输出功能，输出不同的格式，比如 HTML，可能还想改变 BalanceSheet 的细节。这将问题分解成两个类提供了很好的理由：一个负责将 BalanceSheet 生成表格，一个负责输出。 单一功能原则不止于此：一个类不仅要功能单一，而且还需要将功能封装好。以上面的例子就是：如果我想改变输出格式，那么只需要改变负责输出的类，而不必关心负责制表的类。 这是强内聚性设计的一部分。说一个类是内聚的，是指它的方法和属性需要统一对待，因为它们紧密相关。如果你试着将一个内聚的类拆分，可能会得到刚才创建的那两个类。 那么问题来了，这和 lambda 表达式有什么关系？ lambda 表达式在方法级别能更容易实现单一功能原则。 举个栗子： 计算质数个数： 123456789101112131415public long countPrimes(int upTo) { long total = 0; for (int i = 1; i &lt; upTo; i++) { boolean isPrime = true; for (int j = 2; j &lt; i; j++) { if (i % j == 0) { isPrime = false; } } if (isPrime) { total++; } } return total;} 显然，上面的方法塞了两个职责：判断一个数是否是质数、计数。 拆分这两个功能： 123456789101112131415161718public long countPrimes(int upTo) { long total = 0; for (int i = 1; i &lt; upTo; i++) { if (isPrime(i)) { total++; } } return total;}public boolean isPrime(int num) { for (int i = 2; i &lt; num; i++) { if (num % i == 0) { return false; } } return true;} 既然遵守单一功能原则，那么我们可以对迭代过程封装： 12345678910public long countPrimes(int upTo) { return IntStream.range(1, upTo) .filter(this::isPrime) .count();}public boolean isPrime(int num) { return IntStream.range(2, num) .allMatch(x -&gt; (num % x) != 0);} 如果我们想利用多核加速计数，可以使用 parallel 方法，而不用修改任何其他代码： 123456public long countPrimes(int upTo) { return IntStream.range(1, upTo) .parallel() .filter(this::isPrime) .count();} 开闭原则软件应该对扩展开放，对修改闭合。 开闭原则的首要目标和单一功能原则类似：让软件易于修改。 一个新增功能或一处改动，会影响整个代码，容易引入新的缺陷。 开闭原则保证已有的类在不修改内部实现的基础上可扩展，这样就努力避免了上述问题。 举个栗子： 现在我们有个描述计算机花在用户空间、内核空间和输入输出上的时间散点图 MetricDataGraph 接口： 1234567public interface MetricDataGraph { void updateUserTime(int value); void updateSystemTime(int value); void updateIOTime(int value);} 但这个接口有点问题：对扩展不友好。因为要想添加新的时间点，比如 XXTime，就要修改这个接口，添加对应的 updateXXTime 方法。 如何解决扩展问题呢？一般是通过引入抽象解决。 使用新的类 TimeSeries 来表示各种时间点，这样 MetricDataGraph 接口也得以简化，不必依赖某项具体指标。 123public interface MetricDataGraph { void updateTimeSeries(TimeSeries time);} 123public interface TimeSeries { int getValue();} 每项具体指标都实现 TimeSeries 接口，在需要时能直接插入： 12345678public class UserTime implements TimeSeries { private int value; @Override public int getValue() { return this.value; }} 现在，要添加新的时间点，比如，“被浪费的CPU时间”： 12345678public class WasteTime implements TimeSeries { private int value; @Override public int getValue() { return this.value; }} 高阶函数也展示了同样的特性：对扩展开放，对修改闭合。 ThreadLocal 类有一个特殊变量，每个线程都有一个该变量的副本与之交互。该类的静态方法 withInitial 是一个高阶函数，传入一个负责生成初始值的 lambda 表达式。即不用修改 ThreadLocal 类就能获得新的行为，所以符合开闭原则。 给 withInitial 方法传入不同的工厂方法，就能得到有着不同行为的 ThreadLocal 实例。 比如，使用 ThreadLocal 生成一个 DateFormatter 实例，该实例是线程安全的： 123456// 实现ThreadLocal&lt;DateFormat&gt; localFormatter = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat());// 使用DateFormat formatter = localFormatter.get(); 或者为每个 Java 线程创建唯一，有序的标识符： 123456AtomicInteger threadId = new AtomicInteger();ThreadLocal&lt;Integer&gt; localId = ThreadLocal.withInitial(() -&gt; threadId.getAndIncrement());int idForeThisThread = localId.get(); 依赖反转原则抽象不应依赖细节，细节应该依赖抽象。 该原则的目的：让程序猿脱离底层粘合代码，编写上层业务逻辑代码。这就让上层代码依赖于底层细节的抽象，从而可以重用上层代码。这种模块化和重用方式是双向的：既可以替换不同的细节重用上层代码，也可以替换不同的业务逻辑重用细节的实现。 以下代码是从一种标记语言中提取标题，其中标题以冒号（：）结尾。 1234567891011121314public List&lt;String&gt; findHeadings(Reader input) { // 读取文件 try (BufferedReader reader = new BufferedReader(input)) { // 逐行检查 return reader.lines() // 滤出标题 .filter(line -&gt; line.endsWith(&quot;:&quot;)) .map(line -&gt; line.substring(0, line.length() - 1)) .collect(toList()); } catch (IOException e) { // 将和读写文件有关的异常封装成待解决的异常 throw new HeadingLookupException(e); }} 这段代码，将提取标题，资源管理，文件处理都混在了一起。我们真正想要的是编写提取标题的代码，而将操作文件相关细节交给另一个方法。 剥离文件处理功能后的业务逻辑： 12345678910111213141516171819public List&lt;String&gt; findHeadings2(Reader input) { return withLinesOf(input, lines -&gt; lines.filter(line -&gt; line.endsWith(&quot;:&quot;)) .map(line -&gt; line.substring(0, line.length() - 1)) .collect(toList()), HeadingLookupException::new);}// Stream 对象更安全，而且不容易被滥用// 使用 Stream&lt;String&gt; 做抽象，让代码依赖它，而不是文件private &lt;T&gt; T withLinesOf(Reader input, Function&lt;Stream&lt;String&gt;, T&gt; handler, Function&lt;IOException, RuntimeException&gt; error) { try (BufferedReader reader = new BufferedReader(input)) { return handler.apply(reader.lines()); } catch (IOException e) { throw error.apply(e); }}","link":"/2018/03/05/zh/programing/book_read/java/java8_lambdas/7_design/"},{"title":"1.Netty and Java NIO APIs","text":"本章内容主要介绍： Netty 架构 我们为什么需要非阻塞IO 阻塞IO vs 非阻塞IO 了解 JDK 的 NIO实现的问题和 Netty 的解决方法 前面关于 Netty 架构的省略。 异步的设计整个 Netty 的 API 都是异步的。异步处理并不新鲜，已经出现有一段时间了。在这些年里，IO 经常出现瓶颈，所以异步处理变得越来越重要。 在使用资源时调用异步处理可以变得更有效率，因为当任务进行时，我们可以去干其他事，直到我们收到任务完成的信息。 Callbacks回调经常在异步处理中使用，回调被传入到方法中直到方法完成才执行。我们可以经常在 JavaScript 中看到异步回调，因为它是 JS 语言的核心。 以下代码展示了当获取到数据后使用的回调： 123456789101112131415161718192021222324252627282930interface FetchCallback { void onData(Data data); void onError(Throwable cause);}interface Fetcher { // 该 FetchCallback 类型参数有两个回调方法： // onData ：接收到数据后的操作 // onError：出错后的操作 void fetchData(FetchCallback callback);}class Worker { public void doWork() { Fetcher fetcher = ... fetcher.fetchData(new FetchCallback() { @Override public void onData(Data data) { // 接收到数据 } @Override public void onError(Throwable cause) { // 出现错误 } }); ... }} 如果写过 Android，应该对以上代码很熟悉。 有个问题就是，当你使用一大堆异步方法并回调时，就会出现很多意大利面式的冗余代码。一些人会认为这会导致代码的难读，但我认为这更多的是影响代码的风格。比如 Node.js，它基于 JavaScript，变得越来越流行。它就使用了大量的回调，但依然有很多人觉得很好读很好写。 Futures第二种就是使用 Futures。Future 是抽象，是对将要变得可用的值的呈现。 Future 接口在 java.util.concurrent 包中，通过为异步处理服务的 Executor 进行使用。 以下例子中，我们传入了 Runnable 对象给 ExecutorService.submit() 方法，方法会返回 Future 对象给我们，利用它我们可以检查到方法是否执行完成。 123456789101112ExecutorService executor = Executors.newCachedThreadPool();// 无返回值Runnable task1 = () -&gt; doSomeHeavyWork();// 带返回值Callable&lt;Integer&gt; task2 = () -&gt; doSomeHeavyWorkWithResult();// 提交执行Future&lt;?&gt; future1 = executor.submit(task1);Future&lt;Integer&gt; future2 = executor.submit(task2);// 循环查看是否完成while (!future1.isDone() || !future2.isDone()) { // 完成之后做些什么} 现在让我们尝试将回调例子改造一下： 12345678910111213141516171819interface Fetcher { Future&lt;Data&gt; fetchData();}class Worker { public void doWork() { Fetcher fetcher = ... Future&lt;Data&gt; future = fetcher.fetchData(); try { while (!future.isDone()){ // 完成之后做些什么 } // 接收到数据 System.out.println(&quot;Data received: &quot;+ future.get()); }catch (Throwable cause){ // 出现错误 } }} 有时候用 Futures 会感到很恶心，因为你需要每隔一段时间检查一下是否完成，而通过回调你可以第一时间收到完成消息。 通过以上两个关于异步执行的例子，你也许会想哪一种会比较好。这里没有明确的答案。如果使用 Netty，它将为你提供最好的操作。 JVM 中 阻塞IO vs 非阻塞IO早期的 Java 1.4 就有了 NIO 的 API，而 Java7 则提供了新的 NIO.2 API，其包含更多高层次的 API。 如果要用 Java 写和网络相关的程序，有两种方法： 使用 IO，也叫 阻塞 IO 使用 NIO，也叫 新/非阻塞 IO New 还是 Non-Blocking？NIO 的 N 很明显应该是 Non-Blocking。因为 NIO 出现很久了，没人会说它是 New 的了。 一个线程处理一个连接，它们是 1:1 的关系，因此在 JVM 中会限制你可以创建的线程数。 非阻塞 IO 则可以让你使用一个 selector 处理多个连接，它们是 1:n 的关系。 请记住上面的关系图，让我们更深入阻塞和非阻塞。 接下来我们将写一个简单的 echo 服务端去描述这两种 IO 的不同。 基于阻塞 IO 的 echo 服务端123456789101112131415161718192021222324252627282930313233public class PlainEchoServer { public void serve(int port) throws IOException { ServerSocket socket = new ServerSocket(port); try { while (true) { final Socket clientSocket = socket.accept(); System.out.println(&quot;Accepted connection from&quot; + clientSocket); // 每个新连接都要开启一个线程 // 和使用线程池的本质是一样的 // 一旦需要处理成千上万的并发连接，就会出现灾难 new Thread(() -&gt; { try { BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); // 将读到的数据写回去 PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true); while (true) { writer.println(reader.readLine()); writer.flush(); } } catch (IOException e) { e.printStackTrace(); try { clientSocket.close(); } catch (IOException ignored) { } } }).start(); } } catch (IOException e) { e.printStackTrace(); } }} 非阻塞 IO 基础Java7 提供的新 NIO API 被称为 NIO.2，当然你也可以用 NIO。 尽管新的 API 也是异步的，但在实现和对外接口上并不完全相同，但都有相同的特性。比如，两者的实现都使用了名为 ByteBuffer 的抽象作为数据容器。 ByteBuffer ByteBuffer 是新旧 NIO API 的基础，对于 Netty 来说也是。ByteBuffer 内存可以被分配在堆上，或在直接内存上，这意味着它可以被存储在堆空间以外。通常，当将它传到 channel 上时，在直接内存上的访问会更快，但分配和回收的花费会更高。 ByteBuffer 允许相同数据在 ByteBuffer 实例间分享，而不用去做内存拷贝。它还支持切片和其他操作去限制数据的可见性。 ByteBuffer 的典型使用场景： 向 ByteBuffer 写数据 调用 ByteBuffer.flip() 切换读写模式 从 ByteBuffer 读数据 调用 ByteBuffer.clear() 清除整个 ByteBuffer 调用 ByteBuffer.compact() 清除已从内存拷贝中读取的数据 当你向 ByteBuffer 写入数据时，它会去更新缓存已写的下标位置（即每写1个数据，position+1）；当然你也可以手动完成。 当你准备好读取数据时，可以调用 ByteBuffer.flip() 把写模式切换到读模式。调用 ByteBuffer.flip() 会将 ByteBuffer 的 limit 设置为当前 position，并更新 position = 0。这样你就可以读取 ByteBuffer 的所有数据了。 ByteBuffer.compact() 将所有未读取的数据移动到 ByteBuffer 开头，然后调整 position。 下面是使用的场景例子： 1234567891011121314151617181920Channel inChannel = ...ByteBuffer buf = ByteBuffer.allocate(48);int byteRead = -1;do { // 从 Channel 中读取数据到 ByteBuffer byteRead = inChannel.read(buf); if (byteRead != -1) { // 切换到读模式 buf.flip(); while (buf.hasRemaining()) { // 读取 ByteBuffer 的字节 // 每次 get() 会更新 position+1 System.out.print((char) buf.get()); } // 使 ByteBuffer 准备下一次写 buf.clear(); }} while (byteRead != -1);inChannel.close(); 现在基本了解了 ByteBuffer，下一步让我们认识 selectors。 NIO Selector selector 是决定一个或多个 channels 是否准备好 读或写的 NIO 组件。单个 selector 可以被用于处理多个连接，可以缓和阻塞IO下1个线程处理1个连接的模型需求。 要使用 selector，你需要完成以下步骤： 创建一个或多个 selectors 去给已开启的 channels（sockets）进行注册。 当一个 channel 被注册了，要去指定需要监听的事件。以下是可以监听的四种事件（或操作）： OP_ACCEPT：连接 accept OP_CONNECT：连接 connect OP_READ：读 OP_WRITE：写 当多个 channels 被注册了，可以调用 Selector.select() 方法去阻塞，直到这些事件中的一个发生。 当方法不阻塞了，你就可以获得所有的 SelectionKey 实例（它们有注册 channel 的引用和选定的监听事件）。一个 SelectedKey 可以包含多个事件。 为了看它是怎么工作的，让我们实现一个非阻塞版本的 echo 服务端。 基于 NIO 的 echo 的服务端该版本的服务端使用异步 NIO API，可以让一个线程处理上千个并发客户端。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class PlainNioEchoServer { public void serve(int port) throws IOException { System.out.println(&quot;Listening for connections on port: &quot; + port); ServerSocketChannel serverChannel = ServerSocketChannel.open(); ServerSocket ss = serverChannel.socket(); InetSocketAddress address = new InetSocketAddress(port); // 绑定端口地址 ss.bind(address); serverChannel.configureBlocking(false); Selector selector = Selector.open(); // 把 channel 注册到 selector，并关注连接的 accept 事件 serverChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) { try { // 阻塞直到被选中 selector.select(); } catch (IOException e) { e.printStackTrace(); break; } // 获得所有 SelectedKey 的实例 Set readyKeys = selector.selectedKeys(); Iterator iterator = readyKeys.iterator(); while (iterator.hasNext()) { SelectionKey key = (SelectionKey) iterator.next(); // 将 SelectedKey 移出迭代器 iterator.remove(); try { if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); // 接受客户端的连接 SocketChannel client = server.accept(); System.out.println(&quot;Accepted connection from &quot; + client); client.configureBlocking(false); // 把连接注册到 selector 并设置 ByteBuffer client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100)); } // 检查 SelectedKey 是否可读 if (key.isReadable()) { SocketChannel client = (SocketChannel) key.channel(); ByteBuffer output = (ByteBuffer) key.attachment(); // 将数据读到 ByteBuffer client.read(output); } // 检查 SelectedKey 是否可写 if (key.isWritable()) { SocketChannel client = (SocketChannel) key.channel(); ByteBuffer output = (ByteBuffer) key.attachment(); output.flip(); // 将 ByteBuffer 里的数据写到 channel client.write(output); output.compact(); } } catch (IOException e) { key.channel(); try { key.channel().close(); } catch (IOException ignored) { } } } } }} 该例子比之前的 echo 服务端版本都要复杂。但这种复杂是一种权衡。异步代码明显要比同步部分复杂。 下面我们要实现 NIO.2 版本的 echo 服务端。 基于 NIO.2 的 echo 服务端不像原生 NIO 的实现，NIO.2 允许你发出 IO 操作和提供一个完成时的处理器（CompletionHandler 类）。这个完成时处理器会在 IO 操作完成后执行，完成时处理器的执行是由底层系统驱动的，开发者不用关心它的实现。而且支持在同一时间只执行一个在 channel 中的 CompletionHandler。这可以帮助简化代码，因为它除去了多线程执行带来的复杂度。 原生 NIO 和 NIO.2 的最主要不同点：你不必去检查一个在 channel 中的事件是否发生了，然后再去触发一些动作。 在 NIO.2 中，你只需要触发 IO 操作，和注册一个完成时处理器给它，这个处理器会在操作完成的第一时间得到通知。这可以移除你在自己程序里写逻辑去检查操作完成的必要。 现在让我们看下同样是异步 echo 服务端，用 NIO.2 实现是怎样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class PlainNio2EchoServer { public void serve(int port) throws IOException { System.out.println(&quot;Listening for connections on port &quot; + port); final AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open(); InetSocketAddress address = new InetSocketAddress(port); // 绑定端口地址 serverChannel.bind(address); final CountDownLatch latch = new CountDownLatch(1); // 开始接受新的客户端连接 // 一旦有一个客户端被 accepted，CompletionHandler 就会被调用 serverChannel.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() { @Override public void completed(AsynchronousSocketChannel channel, Object attachment) { // 再一次接受新的客户端连接 serverChannel.accept(null, this); ByteBuffer buffer = ByteBuffer.allocate(100); // 在 channel 中触发读操作 // 一旦读到什么 CompletionHandler 就会第一时间被通知 channel.read(buffer, buffer, new EchoCompletionHandler(channel)); } @Override public void failed(Throwable throwable, Object attachment) { try { // 有错误就关闭套接字 serverChannel.close(); } catch (IOException ignored) { } finally { latch.countDown(); } } }); try { latch.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } private final class EchoCompletionHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; { private final AsynchronousSocketChannel channel; EchoCompletionHandler(AsynchronousSocketChannel channel) { this.channel = channel; } @Override public void completed(Integer result, ByteBuffer buffer) { buffer.flip(); // 在 channel 中触发写操作 // 一旦写了什么 CompletionHandler 就会第一时间被通知 channel.write(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() { @Override public void completed(Integer result, ByteBuffer buffer) { if (buffer.hasRemaining()) { // 如果还有东西在 ByteBuffer 中 // 就再次触发写操作 channel.write(buffer, buffer, this); } else { buffer.compact(); channel.read(buffer, buffer, EchoCompletionHandler.this); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (IOException ignored) { } } }); } @Override public void failed(Throwable exc, ByteBuffer attachment) { try { channel.close(); } catch (IOException ignored) { } } }} 第一眼看上去，比之前使用 NIO 的代码更多了。但要注意到 NIO.2 为你处理好了线程和事件循环的创建。这会简化在创建多线程 NIO 程序时的代码，尽管在这个例子中不太明显。随着程序变得越来越复杂，你产出的代码将会更简洁，简化效果会变得越来越明显。 下一步我们看看 JDK 的 NIO 存在的一些问题。 NIO 问题以及 Netty 是如何解决的跨平台和兼容性问题NIO 比较底层，取决于操作系统是如何处理 IO 的。Java 有统一的 API，这让它可以在所有操作系统上都能工作。 当你使用 NIO 时，你可能会发现在 Linux 下的代码工作正常，但在 Windows 下却有问题。我的建议就是，即使你不使用 NIO，你要想支持所有操作系统，你都要进行测试。所以就算所有的测试在你的 Linux 下都通过了，也要在其他操作系统上进行验证。如果你不打算这样，那就有得你爽喽。 NIO.2 只支持 Java7 以上，如果你在 Java6 以下，那就用不了了。而且，在写这篇文章时，NIO.2 还没有支持 datagram channels（针对 UDP 协议），所以只能限制使用 TCP 协议。 Netty 解决了这个问题，可以运行在 Java6 和 7 上。不用再担心向下兼容，而且还能享受到简单统一的 API。 ByteBuffer 可扩展性如你所见，ByteBuffer 是数据的容器。不幸的是，JDK 没有包含 ByteBuffer 的实现，所以不支持对 ByteBuffer 实例的封装。如果你想压缩内存拷贝，这会很有用。如果你还是想“我自己实现它“。不用浪费你的时间，ByteBuffer 的构造器是私有的，所以不太可能进行扩展。 Netty 提供了自己的 ByteBuffer 实现，打破了上面的限制，而且通过提供一些构造方法，使用，和生成方法 API。 分散和聚集可能内存泄漏许多 channel 的实现支持分散和聚集。这个特性可以让多个 ByteBuffer 实例在同一时间写入或读出，从而提高性能。这是内核/OS进行的读/写处理，因为更接近底层，所以可以更高效。 在你想切割不同 ByteBuffer 实例去分别处理缓存时，通常就要使用分散/聚集。比如你想在一个 ByteBuffer 中放入 header，而把 body 放到其他 ByteBuffer。 下图就展示了分散读是怎样的： 传入一组 ByteBuffer 实例到 ScatteringByteChannel，然后数据就会从 channel 分散读到 buffer。 写也差不多，只是数据是从 buffer 写到 channel： 传入一组 ByteBuffer 实例到 GatheringByteChannel.write() 方法，然后数据就会从 buffer 写到 channel。 不幸的是，这特性可能会导致内存泄露，从而引发 OutOfMemoryError，所以你要谨慎使用分散/聚集。 著名的 epoll bug在类 Linux 操作系统中，selector 使用 epoll - IO 事件发现。这是一种可以让操作系统在网络栈中异步工作的高性能技术。但直到今天，epoll 仍然有一个可以让 selector 变为 invalid 状态的 bug，会导致 CPU 占用达到100%。唯一的解决办法就是回收旧的 selector，把之前注册的 channel 实例都注册到新的 selector 上。 这里主要是由于 Selector.select() 方法停止阻塞，然后立即返回了，即使没有 SelectionKeys 被选中。这和它的本质是有冲突的，因为当它的事件没有被选中时是不能变为非阻塞的。 解决 epoll 的方法被限制了，但 Netty 尝试自动检测和预防这种情况。 下面是会出现 epoll bug 的代码： 123456789101112131415...while (true) { // 立即返回 // 并且当没有事件被选中时返回的是0 int selected = selector.select(); Set&lt;SelectedKeys&gt; readyKeys = selector.selectedKeys(); // 获得所有 SelectedKeys // 没东西被选中时，迭代器会是空 Iterator iterator = readyKeys.iterator(); // 空迭代器，则无法进入 while (iterator.hasNext()){ ... }}... 最主要的影响是那段 while 循环会吃 CPU： 12345...while (true) { }...","link":"/2018/10/18/zh/programing/book_read/java/netty_in_action/1_netty_and_java_nio_apis/"},{"title":"3.Netty from the ground up","text":"Netty 组件： Bootstrap / ServerBootstrap EventLoop EventLoopGroup ChannelPipeline Channel Future / ChannelFuture ChannelInitializer ChannelHandler 接下来将会在本章对上面组件进行介绍，为了避免分散地介绍它们，我们将详细说明它们是如何在一起工作的。 快速了解 Netty一个 Netty 程序开始于一个 Bootstrap 类，Bootstrap 是由 Netty 提供的可以让我们方便配置 Netty 的构造类。 为了允许多种协议和各种处理数据的方式，Netty 提供了 handlers 处理类。如它们名字那样，是用于处理指定”事件“或事件集合。 一种常见的类型就是 ChannelInboundHandler。你可以决定如何处理 ChannelInboundHandler 接收到的信息。当你的程序需要提供响应时，你也许要把 ChannelInboundHandler 内部的数据 写/冲洗 到外面。换句话说，你的程序的业务逻辑一般就写在 ChannelInboundHandler。 当 Netty 连接客户端或绑定服务端时，它需要知道如何去处理发送或接收到的数据。这是通过各种类型的处理器完成的，Netty 提供了名为 ChannelInitializer 去配置这些处理器。ChannelInitializer 的职责就是为 ChannelPipeline 添加 ChannelHandler 的实现。当你发送和接收消息时，这些处理器会决定如何对待这些消息。一个 ChannelInitializer 本身也是一个 ChannelHandler，当向 ChannelPipeline 添加完其他处理器后，就会自动将自己移除。 所有的 Netty 程序都是基于 ChannelPipeline，ChannelPipeline 和 EventLoop 以及 EventLoopGroup 的关系很接近，因为它们三个都是和事件和事件处理有关。 EventLoops 是为 Channel 处理 IO 操作。单个 EventLoop 通常会为多个 Channels 处理事件。EventLoopGroup 本身会包含多于一个的 EventLoop，可以被用于获取一个 EventLoop。 Channel 是一个 socket 连接或一些用于 IO 操作的组件的表现形式，因此这也是为什么会由 EventLoop 所管理。 所有在 Netty 的 IO 操作都是异步的。所以当我们连接一台主机的时候，也是默认异步的，包括写/发送消息。这意味着操作不会被立即执行，而是过后执行。因为你不可能在它返回后就知道一个操作是成功还是失败，但又需要过后检查成功与否，所以就要去注册监听器。为了改正这点，Netty 使用了 Futures 和 ChannelFutures。这个 future 会被用于注册一个监听器，在一个操作出错或成功完成时就会收到提示。 Channels、Events 和 IO下图展示了 Netty 有 EventLoopGroups，这些组有一个或多个 EventLoop。可以把 EventLoops 当成为 channel 执行真实工作的线程。 EventLoop 和 线程 的关系在 EventLoop 的生命周期里，它总是一个单独的线程。 当一个 channel 被注册了，Netty 会将 channel 的整个生命周期都绑定到单个 EventLoop（相当于单个线程）。这就是为什么你的程序不用同步 Netty IO 操作，因为所有给到 channel 的 IO 都会被同一个线程执行。 EventLoop 和 EventLoopGroup 的关系第一感觉很奇怪是吧？因为我们说过 EventLoopGroup 包含一个或多个 EventLoop，但从图来看，EventLoop 实际上是 EventLoopGroup 的子接口，所以也可以说 EventLoop 是一个 EventLoopGroup。 BootStrapping：什么/为什么Netty 的 BootStrapping 是对你的 Netty 应用进行配置的过程。当你需要通过主机号和端口连接到客户端，或连接到给定端口的服务端时，用 Bootstrap。像之前说过的一样，Bootstraps 有两种类型，一种用于客户端（也可以用于 DatagramChannel）（简略称为 Bootstrap）；另一种用于服务端（称为 ServerBootstrap）。无论你的应用用的是什么协议，唯一决定你用哪个 Bootstrap 的是你要创建的是客户端还是服务端。 这两种 Bootstraps 有很多类似的地方，实际上，相似的比不同的地方要多。下表展示了一些关键的相似点和不同点： 相似点 Bootstrap ServerBootstrap 职责 连接到远程主机和端口 绑定本地端口 EventLoopGroups 数量 1 2 使用 Bootstrap，你显然要调用 connect() 连接；但你也可以调用 bind()，之后再使用 Channel 进行连接，bind() 返回的是 ChannelFuture。 客户端 Bootstraps/applications 使用1个 EventLoopGroup，而 ServerBootstrap 使用2个（实际上可以使用同一个 EventLoopGroup 实例）。 1个 ServerBootstrap 可以想成有2套 channels，第一套包含一个代表服务端本身 socket 的 ServerChannel，其已经绑定本地端口；第二套包含所有代表连接的 Channel，其连接已被 accepted。 上图中，EventLoopGroup A 的唯一目的就是接受连接，然后把它们传到 EventLoopGroup B 中。Netty 可以用不同的两个组，是因为当应用在接受大量连接时，单个 EventLoopGroup 会因为忙于处理已接受的连接而不能在合理时间内去接受新连接，使其成为瓶颈。最终的结果就是一些连接出现 timeout。而通过两个 EventGroup，所有的都可以被 accepted，甚至在极端高负荷下，因为 EventLoops 正在接受的连接不会和已经接受的连接一样被共享。 EventLoopGroup 和 EventLoopEventLoopGroup 可能包含多个 EventLoop。每个 Channel 一旦被创建，就会有一个 EventLoop 去绑定它。一个 EventLoopGroup 如果包含的 EventLoops 比 Channels 更少，那么一些 Channel 就会共享同一个 EventLoop。这意味着让 EventLoop 在一个 Channel 上保持忙碌，就会影响到其他绑定到这个 EventLoop 的 Channel 处理。这也是为什么你 不能 阻塞 EventLoop。 下图展示了如果你打算使用同一个 EventLoopGroup 实例两次去配置 Netty 服务端所带来的不同： Netty 允许使用同一个 EventLoopGroup 去处理 IO 和接受连接。这在大多数情况下可以正常工作。 Channel 处理器和数据流我们需要看看数据在发送和接受时都发生了什么。为了理解这个过程，就需要先理解处理器是什么。处理器是依靠前面所说的 ChannelPipeline 去指定它们的执行顺序的。而不定义好 ChannelPipeline 就无法明确处理器，不定义好 ChannelHandlers 就无法明确 ChannelPipeline。无需多说，就是我们要处理好它们每一个的定义。 把它们合到一起：ChannelPipeline 和 处理器很多情况下，Netty 的 ChannelHandler 是我们处理最多的，虽然你没有意识到。如果你正在使用 Netty，那至少里面会有一个 ChannelHandler。换句话说，它们是很多东西的关键。所以它们到底是什么？很难去定义 ChannelHandler，因为它们太普通了，可以把它们想象成处理到来数据和通过 ChannelPipeline 的一些代码。 数据流在 Netty 中有两个方向，如接口定义的两个：“入”（ChannelInboundHandler）和“出”（ChannelOutboundHandler）处理器。数据从用户应用到远程节点就被认为是“出”。相反的，从远程节点到用户应用就是“入”。 为了使得数据从一个终点到另一个终点，一个或多个 ChannelHandler 就要在多个地方操控数据。这些 ChannelHandlers 要被添加到应用中的 Bootstrap 部分，它们被添加的顺序就决定了它们操控数据的顺序。 指定顺序的 ChannelHandler 排列可以看成是 ChannelPipeline。换句话说，ChannelPipeline 就是一系列的 ChannelHandler 排列。每一个 ChannelHandler 在数据上执行它们的动作（如果它能处理，比如入的数据只能被 ChannelInboundHandler 处理），然后再将改变过的数据传递到在 ChannelPipeline 中的下一个 ChannelHandler，直到没有剩余的 ChannelHandler。 下图展示了 ChannelPipeline 的排序： 正如图中展示，ChannelInboundHandler 和 ChannelOutboundHandler 可以在 ChannelPipeline 中混合使用。 在该 ChannelPipeline 中，如果消息或任何其他”入“事件被读取，就要从 ChannelPipeline 的 head 开始，然后被传进第一个 ChannelInboundHandler 中。这个 ChannelInboundHandler 会处理这个事件 或 将它传到下一个 ChannelInboundHandler。一旦 ChannelPipeline 中没有 ChannelInboundHandler，就到达了 ChannelPipeline 的 tail 尾部，也就意味着之后不用再进行处理了。 反过来也是一样的，任何”出“事件都会从 ChannelPipeline 的 tail 开始，然后被传到”最后“一个 ChannelOutboundHandler，之后和 ChannelInboundHandler 是一样的。一旦没有更多的 ChannelOutboundHandler 可以被用于传递事件，也就到了正式的传输（也许是网络 socket）。 你可能会想，如果 outbound 和 inbound 的操作是不同的，它们是怎么在同一个 ChannelPipeline 工作的？请记住 outbound 和 inbound 处理器是继承自 ChannelHandler 的不同接口。这意味着 Netty 可以忽略任何不是特定类型的处理器，因此不是特定的就不能处理给定的操作。所以在 outbound 事件中，ChannelInboundHandler 就会被忽略，因为 Netty 知道每个处理器，是来自 ChannelInboundHandler 还是 ChannelOutboundHandler。 一旦 ChannelHandler 被添加进 ChannelPipeline，就会得到 ChannelHandlerContext。通常获得该对象的引用并使用是安全的，但在 datagram 数据包协议（UDP）中使用就不对了。这个对象可以被用于获得底层的 channel，所以你可以用 ChannelHandlerContext 来写/发消息。这意味着在 Netty 中有两种发送消息的方法。你可以直接向 channel 写消息或者向 ChannelHandlerContext 对象写消息。它们的不同处就是：向 channel 直接写是从 ChannelPipeline 的 tail 开始的，而向 context 对象写是从 ChannelPipeline 的下一个 Handler 开始的。 加解码密和业务逻辑：进一步了解处理器如前面说的，有很多不同类型的处理器。具体到每一个就依赖于它们所继承的基类。在 Pipeline 中，每个处理器都有义务去把 Netty 事件传递到下一个处理器中，而 Netty 提供了一系列的 ”Adapter“ 类，可以使得事情变得简单些。使用 *Adapter 类（或它的子类）就可以自动完成，你要做的只是去重写你关心的方法。除了 *Adapter 类之外，还有其他继承和提供额外功能可以去帮助加解码消息的实现。 Adapter 类很少有允许你用简单的方法向 ChannelHandlers 写消息的 adapter 类。如果你想实现自己的 ChannelHandler，我建议你继承已有的一个 adapter 类或 encoder/decoder 类。Netty 有以下这些 adapters： ChannelHandlerAdapter ChannelInboundHandlerAdapter ChannelOutboundHandlerAdapter ChannelDuplexHandlerAdapter Encoder/Decoder当你用 Netty 发送或接收消息，都是要转换操作的。如果消息被接收，就要把它从字节转换成 Java 的对象（由某些 decoder 进行 decode）。如果消息被发送，就要把它从 Java 对象转换成字节（由某些 encoder 进行 encode）。转换经常在通过网路发送消息时发生，比如把字节转成消息或消息转成字节，因为网路只能用字节传输。 Netty 有各种各样的 encoder 和 decoder 基类，取决于你要用哪个。比如，你的应用可能不需要将消息立刻转换为字节，而是转成另一种类型的消息。仍然需要用 encoder，但是基类已经不同了。为了知道哪种基类适合，我们通过基类名字就能方便分辨，常见的基类都会有个差不多的名字：”ByteToMessageDecoder“ 或者 ”MessageToByteEncoder“。或在一些特定类型下，你可以找到 ”ProtobufEncoder“ 和 ”ProtobufDecoder“（用于支持 Google 的协议缓冲区的）。 严格来说，处理器可以做到 encoders 和 decoders 能做的。但回想一下，我们说过的有不同的 adapter 类可供使用，在 decoders 中，有 ChannelInboundHandlerAdapter 或 ChannelInboundHandler，它们是所有 decoders 继承或实现的。”channelRead“ 方法被重写了，这个方法在每一次读取从 inbound channel 来的消息都会被调用。这个被重写的 channelRead 方法调用每个 decoder 的 decode 方法，然后通过调用 ChannelHandlerContext.fireChannelRead(decodedMessage) 方法将被 decoded 的消息传递给下一个 ChannelInboundHandler。 业务逻辑可能你的应用中使用的最常见的处理器就是去接收解码消息，然后在消息上添加业务逻辑。为了创建这样的处理器，你唯一要做的就是继承 SimpleChannelInboundHandler 基类，T 就是你需要处理的消息类型。在该处理器中，你的应用可以通过重写基类的任何一个方法来获得 ChannelHandlerContext，它们都是可以接受 ChannelHandlerContext 作为参数的，你可以把它作为成员参数存储。 这个处理器的主方法是 channelRead0(ChannelHandlerContext, T)。Netty 调用这个方法，T 就是消息，你的应用可以对它进行处理，怎样处理就看你的需要了。需要注意，处理消息时，虽然是多线程处理 IO，但你不能去阻塞 IO 线程，因为这会在高负荷下出现问题。","link":"/2018/10/19/zh/programing/book_read/java/netty_in_action/3_netty_from_the_ground_up/"},{"title":"Netty&#39;s Hello World","text":"Netty 官网 可以到官网下载，也可以直接使用 maven 依赖： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.30.Final&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; DISCARD 协议官网的入门示例使用的协议是：DISCARD，最简单的协议，因为它只接收数据（然后扔掉……）而不作响应，类似 Linux 下的无底洞 /dev/null。 因为使用的是 DISCARD 协议，所以唯一要做的就是无视所有接收到的数据： 12345678910111213141516171819202122232425262728293031323334353637383940import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;import io.netty.util.ReferenceCountUtil;/** * 服务端处理通道 */// ChannelInboundHandlerAdapter 是 ChannelInboundHandler 接口的实现，ChannelInboundHandler 提供了各种事件处理的方法供你重写使用// 当然现在直接继承 ChannelInboundHandlerAdapter 比让你去实现一个接口来得快public class DiscardServerHandler extends ChannelInboundHandlerAdapter { // 无论何时从客户端接收到数据，该方法都会被调用 // 在这里接收到的数据是 ByteBuf 类型 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { // 默默地扔掉接收到的数据 // ByteBuf 是一个引用计数对象，在释放时需要明确调用 release 方法 // 要记住：处理器方法要释放所有传递给它的引用计数对象，比如这里的 ByteBuf ((ByteBuf) msg).release(); // 通常该 channelRead 方法是这样的实现形式： /* try { // Do something with msg } finally { ReferenceCountUtil.release(msg); } */ } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { // 出现异常时关闭连接 // 当然你也可以在关闭连接前发送带有错误码的响应 cause.printStackTrace(); ctx.close(); }} 到目前为止一切正常，我们已经实现了一半的 DISCARD 协议服务端。剩下的工作就是写 main 方法，去启动带有 DiscardServerHandler 处理器的服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;/** * 丢弃所有接收的数据 */public class DiscardServer { private int port; public DiscardServer(int port) { this.port = port; } public void run() throws Exception { // NioEventLoopGroup 是一个处理I/O操作的多线程事件轮询 // Netty 为各种传输需求提供了各种 EventLoopGroup 实现 // 我们在该例中实现了服务端应用，因此需要用到两个 NioEventLoopGroup // 第一个通常叫 boss，接受到来的连接 // 第二个通常叫 worker，一旦 boss 接受连接并且向 worker 注册该连接，worker 就可以处理已接受的连接通信 // 有多少线程会被使用和它们会被怎样映射到被创建的 Channels，取决于 EventLoopGroup 的实现和构造器的配置 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workGroup = new NioEventLoopGroup(); try { // ServerBootstrap 是一个建立服务端的帮助类 // 当然你可以直接使用 Channel 来建立服务端，但请注意这是一个繁琐的过程，大多时候你不需要这么做 ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workGroup) // 指定使用 NioServerSocketChannel 类，它被用于实例化一个新的通道去接受到来的连接 .channel(NioServerSocketChannel.class) // 这里的处理器会被新接受的通道所评估 // ChannelInitializer 是一个特别的处理器，用于帮助用户配置新通道 // 可能当你想为新的通道配置 ChannelPipeline，通过添加一些处理器比如上面的 DiscardServerHandler 去实现你的网络应用 // 当应用变得复杂起来，你可能要为 pipeline 去添加更多的处理器，最终就是要将这个匿名类提取到顶层类中了 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel socketChannel) { socketChannel.pipeline().addLast(new DiscardServerHandler()); } }) // 你也可以为通道设置参数 // 我们正在写的是 TCP/IP 服务端，所以我们可以设置一些比如 tcpNoDelay 和 keepAlive 的套接字选项 // 请参考 api 文档中的 ChannelOption 和 ChannelConfig 实现，里面有关于支持 ChannelOptions 的说明 .option(ChannelOption.SO_BACKLOG, 128) // 上面的 option 方法是为 NioServerSocketChannel 所接受的连接服务 // 而下面的 childOption 是为 ServerChannel 所接受的 Channels 服务，在这里就是 NioServerSocketChannel .childOption(ChannelOption.SO_KEEPALIVE, true); // 绑定端口并开始接受到来的连接 ChannelFuture channelFuture = serverBootstrap.bind(port).sync(); // 等待直到服务器套接字关闭 // 在该例中，这不会发生，但你可以优雅的关闭你的服务器 channelFuture.channel().closeFuture().sync(); } finally { workGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { int port; if (args.length &gt; 0) { port = Integer.parseInt(args[0]); } else { port = 9000; } new DiscardServer(port).run(); }} 为了能看到效果，改造一下 channelRead 方法，让服务端在接收到消息时能显示出来： 123456789101112131415161718192021@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { //((ByteBuf) msg).release(); ByteBuf buf = (ByteBuf) msg; try { // 可以直接读 System.out.print(buf.toString(CharsetUtil.US_ASCII)); // 也可以循环读 /* while (buf.isReadable()) { System.out.print((char) buf.readByte()); System.out.flush(); } */ } finally { buf.release(); // 工具类释放也可以 //ReferenceCountUtil.release(msg); }} 为了方便，客户端直接用 telnet 进行测试： ECHO 协议到目前为止，服务端还没有发回过响应（因为是 DISCARD 协议）。 让我们实现 ECHO 协议，写一个可以“回音”的服务端。 只要改造一下 channelRead 方法就好了： 12345@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ctx.write(msg); ctx.flush();} ChannelHandlerContext 的对象提供了各种操作可以让你触发各种 I/O 事件和操作。这里我们调用了 write 方法将收到的消息逐字写回。 注意，这里我们并没有像 DISCARD 例子那样释放收到的消息，因为 Netty 已经在你写回消息时为你自动释放了（和流的概念差不多）。 调用 write 并没有立刻将消息写回，而是在内部缓存起来了，还需要调用 flush 才能写回。你也可以使用更简洁的 writeAndFlush(msg) 方法。","link":"/2018/10/11/zh/programing/book_read/java/netty_in_action/netty/"},{"title":"Spring IOC 源码分析","text":"引言新建一个 maven 工程，添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 定义一个接口： 123public interface MessageService { String getMessage();} 实现该接口： 123456public class MessageServiceImpl implements MessageService { public String getMessage() { return &quot;Hello&quot;; }} 在 resources 目录新建一个配置文件 application.xml： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;messageService&quot; class=&quot;com.zoc.ioc.MessageServiceImpl&quot;/&gt;&lt;/beans&gt; 主程序： 1234567891011121314public class App { public static void main(String[] args) { // 用配置文件启动 ApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;); System.out.println(&quot;context 启动成功&quot;); // 从 context 中取出 Bean，而不是用 new MessageServiceImpl() 这种方式 MessageService messageService = context.getBean(MessageService.class); // Hello System.out.println(messageService.getMessage()); }} ApplicationContext context = new ClassPathXmlApplicationContext(...) 就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext，我们还可以选择其他方法构建 ApplicationContext。 大体的继承结构： 我们可以使用绿色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类代替 ClassPathXmlApplicationContext： FileSystemXmlApplicationContext 基本上和 ClassPathXmlApplicationContext 一样，不同点可以看这篇文章。 AnnotationConfigApplicationContext 是基于注解使用的。 BeanFactory 简介BeanFactory：生产 Bean 的工厂，负责生产和管理各个 Bean 实例。 前面的 ApplicationContext 就是一个 BeanFactory。 和 BeanFactory 接口相关的继承结构： ApplicationContext 继承了 ListableBeanFactory，Listable 表示可以获取多个 Bean。看源码可以发现，最顶层 BeanFactory 接口的方法都只能获取单个 Bean。 ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 表示可以启动多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。 AutowireCapableBeanFactory，Autowire 表示可以用来自动装配 Bean。仔细看上图可以发现 ApplicationContext 并没有继承它，不过不继承，不代表不使用，ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就表示了可以获得该 BeanFactory。 ConfigurableListableBeanFactory 是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。 启动过程分析ClassPathXmlApplicationContext 构造方法： 123456789101112131415161718192021public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext { private Resource[] configResources; // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法 public ClassPathXmlApplicationContext(ApplicationContext parent) { super(parent); } ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { super(parent); // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割) setConfigLocations(configLocations); if (refresh) { refresh(); // 核心方法 } } ...} 重点说 refresh()。 在 ApplicationContext 已经建立起来后，我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Overridepublic void refresh() throws BeansException, IllegalStateException { // 先锁上，不然 refresh() 还没结束，又来个启动或销毁容器的线程，就乱了 synchronized (this.startupShutdownMonitor) { // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会被解析成一个个 Bean 定义，注册到 BeanFactory // 注意，这里说的 Bean 还没有初始化，只是配置信息被提取出来了 // 注册也只是将这些信息都保存到注册中心 // 说到底核心是一个 beanName -&gt; beanDefinition 的 map ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean prepareBeanFactory(beanFactory); try { // BeanFactoryPostProcessor：如果 Bean 实现了此接口 // 那么在容器初始化后，Spring 会负责调用里面的 postProcessBeanFactory 方法 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行 // 注意，到这里 Bean 还没初始化 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法) // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成 finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 异常外抛 throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 创建 Bean 容器前的准备工作refresh() 方法中的第一行 prepareRefresh()： 1234567891011121314151617181920212223242526protected void prepareRefresh() { // 记录启动时间， // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isDebugEnabled()) { if (logger.isTraceEnabled()) { logger.trace(&quot;Refreshing &quot; + this); } else { logger.debug(&quot;Refreshing &quot; + getDisplayName()); } } // 初始化在 context 环境中的占位符属性源 initPropertySources(); // 验证按需要标记的所有属性是否可解析 // see ConfigurablePropertyResolver#setRequiredProperties getEnvironment().validateRequiredProperties(); // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();} 创建 Bean 容器，加载并注册 Beanrefresh() 方法中的下一行 obtainFreshBeanFactory()。 注意，这个方法是全文最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。 这步结束后，Bean 实例还没生成。 123456protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等 refreshBeanFactory(); // 返回刚刚创建的 BeanFactory return getBeanFactory();} 12345678910111213141516171819202122232425262728293031// AbstractRefreshableApplicationContext.java@Overrideprotected final void refreshBeanFactory() throws BeansException { // 如果 ApplicationContext 中已经加载过 BeanFactory，销毁所有 Bean，关闭 BeanFactory // 注意，应用中 BeanFactory 本来就是可以多个的 // 这里可不是说应用全局是否有 BeanFactory，而是当前 ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) { destroyBeans(); closeBeanFactory(); } try { // 初始化一个 DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = createBeanFactory(); // 用于 BeanFactory 的序列化，我想不部分人应该都用不到 beanFactory.setSerializationId(getId()); // 下面这两个方法很重要，别跟丢了，具体细节之后说 // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用 customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) { this.beanFactory = beanFactory; } } catch (IOException ex) { throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); }} 为什么实例化 DefaultListableBeanFactory？ 前面我们说了有个很特殊的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口： ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，这个实现类还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路继承。 所以最底下这个 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这里会使用这个类来实例化的原因。 如果想在程序运行的时候动态往 IOC 容器中注册新的 Bean，就要使用到这个类。那我们怎么在运行时获得这个实例呢？之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，把它向下转型就能得到 DefaultListableBeanFactory 了。 BeanDefinition 接口定义这里的 BeanDefinition 就是 Spring 的 Bean。我们定义的各个 Bean 会转换成一个个 BeanDefinition 存在于 BeanFactory 中。 所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以认为是 BeanDefinition 的实例。 BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement { // 默认只提供 sington 和 prototype 两种 // 很多读者可能知道还有 request、session、globalSession、application、websocket 这几种 // 但它们属于基于 web 的扩展 String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; // 不重要，直接跳过 int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; // 设置父 Bean，这里涉及到 Bean 继承，不是 Java 继承。请参见附录的详细介绍 // 一句话就是：继承父 Bean 的配置信息 void setParentName(String parentName); String getParentName(); // 设置 Bean 的类名称，将来是要通过反射来生成实例的 void setBeanClassName(String beanClassName); String getBeanClassName(); // 设置 Bean 的 Scope void setScope(String scope); String getScope(); // 设置是否懒加载 void setLazyInit(boolean lazyInit); boolean isLazyInit(); // 设置该 Bean 依赖的所有的 Bean // 注意，这里的依赖不是指属性依赖(如 @Autowire 标记的) // 而是 depends-on=&quot;&quot; 属性设置的值 void setDependsOn(String... dependsOn); String[] getDependsOn(); // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效 // 如果根据名称注入，即使这边设置了 false，也是可以的 void setAutowireCandidate(boolean autowireCandidate); boolean isAutowireCandidate(); // 同一接口的多个实现 // 如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean void setPrimary(boolean primary); boolean isPrimary(); // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录 // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的 void setFactoryBeanName(String factoryBeanName); String getFactoryBeanName(); // 指定工厂类中的方法名称 void setFactoryMethodName(String factoryMethodName); String getFactoryMethodName(); // 构造器参数 ConstructorArgumentValues getConstructorArgumentValues(); // Bean 中的属性值，后面给 bean 注入属性值的时候会说到 MutablePropertyValues getPropertyValues(); // 是否 singleton boolean isSingleton(); // 是否 prototype boolean isPrototype(); // 如果这个 Bean 是 abstract，那么不能实例化 // 常用于作为 父 Bean 用于继承，很少用 boolean isAbstract(); int getRole(); String getDescription(); String getResourceDescription(); BeanDefinition getOriginatingBeanDefinition();} 往下看 refreshBeanFactory() 方法中的剩余部分： 12customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory); customizeBeanFactorycustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) { if (this.allowBeanDefinitionOverriding != null) { // 是否允许 Bean 定义覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } if (this.allowCircularReferences != null) { // 是否允许 Bean 间的循环依赖 beanFactory.setAllowCircularReferences(this.allowCircularReferences); }} 默认情况下，allowBeanDefinitionOverriding 属性为 null，在配置文件中定义 Bean 时使用了相同的 id 或 name，如果在同一配置文件中重复，会抛错；而如果不是同一配置文件中，会发生覆盖。 循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。 默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。 loadBeanDefinitions接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。 1234567891011121314151617181920// AbstractXmlApplicationContext.java@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader // 读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的 // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧 initBeanDefinitionReader(beanDefinitionReader); // 重点来了，继续往下 loadBeanDefinitions(beanDefinitionReader);} 接下来用刚刚初始化的 Reader 开始来加载 xml 配置：（可以选择性跳过，不是很重要） 12345678910111213141516171819202122232425262728// AbstractXmlApplicationContext.javaprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException { Resource[] configResources = getConfigResources(); if (configResources != null) { // 往下看 reader.loadBeanDefinitions(configResources); } String[] configLocations = getConfigLocations(); if (configLocations != null) { // 2 reader.loadBeanDefinitions(configLocations); }}// 上面虽然有两个分支，不过第2个分支很快通过解析路径转换为 Resource 以后也会进到这里@Overridepublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException { Assert.notNull(resources, &quot;Resource array must not be null&quot;); int counter = 0; // 注意这里是个 for 循环，也就是每个文件是一个 resource for (Resource resource : resources) { // 继续往下看 counter += loadBeanDefinitions(resource); } // 最后返回 counter，表示总共加载了多少的 BeanDefinition return counter;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// XmlBeanDefinitionReader.java@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { return loadBeanDefinitions(new EncodedResource(resource));}public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException { Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) { logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); } // 用一个 ThreadLocal 来存放配置文件资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) { currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); } if (!currentResources.add(encodedResource)) { throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); } try { InputStream inputStream = encodedResource.getResource().getInputStream(); try { InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) { inputSource.setEncoding(encodedResource.getEncoding()); } // 核心部分是这里，往下面看 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); } finally { inputStream.close(); } } catch (IOException ex) { throw new BeanDefinitionStoreException( &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); } finally { currentResources.remove(encodedResource); if (currentResources.isEmpty()) { this.resourcesCurrentlyBeingLoaded.remove(); } }}protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException { try { // 这里就不看了，将 xml 文件转换为 Document 对象 Document doc = doLoadDocument(inputSource, resource); // 继续 return registerBeanDefinitions(doc, resource); } catch (...)}// 返回值：返回从当前配置文件加载了多少数量的 Beanpublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // 这里 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;} 12345678910// DefaultBeanDefinitionDocumentReader.java@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) { this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); Element root = doc.getDocumentElement(); // 从 xml 根节点开始解析文件 doRegisterBeanDefinitions(root);} 经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。 下面开始从根节点开始解析： doRegisterBeanDefinitions12345678910111213141516171819202122232425262728293031323334// DefaultBeanDefinitionDocumentReader.javaprotected void doRegisterBeanDefinitions(Element root) { // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义， // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题， // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { // 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的， // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析 // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (logger.isInfoEnabled()) { logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); } return; } } } preProcessXml(root); // 钩子 // 往下看 parseBeanDefinitions(root, this.delegate); postProcessXml(root); // 钩子 this.delegate = parent;} preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，直接跳过。 这里涉及到了 profile，不了解的可以在附录中参考一下。 接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate)： 1234567891011121314151617181920212223// default namespace 涉及到的四个标签// &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，// 其他的属于 customprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) { // 解析 default namespace 下面的几个元素 parseDefaultElement(ele, delegate); } else { // 解析其他 namespace 的元素 delegate.parseCustomElement(ele); } } } } else { delegate.parseCustomElement(root); }} 从上面的代码，可以看到，对于每个配置来说，分别进入：parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支。 parseDefaultElement(ele, delegate) 代表解析的节点是 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt; 这几个。 这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的：http://www.springframework.org/schema/beans 不熟悉 namespace 的请看下面贴出来的 xml： 123456&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns=&quot;http://www.springframework.org/schema/beans&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;default-autowire=&quot;byName&quot;&gt; 对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 、、、等。这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如： 123456789101112&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;default-autowire=&quot;byName&quot;&gt; 同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。假如读者想分析 &lt;context:property-placeholder location=”classpath:xx.properties” /&gt; 的实现原理，就应该到 ContextNamespaceHandler 中找答案。 回过神来，看看处理 default 标签的方法： 12345678910111213141516private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) { // 处理 &lt;import /&gt; 标签 importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) { // 处理 &lt;alias /&gt; 标签定义 // &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt; processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) { // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧 processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) { // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归 doRegisterBeanDefinitions(ele); }} 这里只挑重点 标签说。 processBeanDefinition下面是 processBeanDefinition 解析 &lt;bean /&gt; 标签： 1234567891011121314151617181920// DefaultBeanDefinitionDocumentReader.javaprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的 if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); }} 继续往下看怎么解析之前，我们先看下 &lt;bean /&gt; 标签中可以定义哪些属性： Property 说明 class 类的全限定名 name 可指定 id、name(用逗号、分号、空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autowiring mode no(默认值)、byName、byType、 constructor lazy-initialization mode 是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了) initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 在 xml 上就是： 1234567891011121314151617181920&lt;bean id=&quot;exampleBean&quot; name=&quot;name1, name2, name3&quot; class=&quot;com.javadoop.ExampleBean&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot; init-method=&quot;init&quot; destroy-method=&quot;cleanup&quot;&gt; &lt;!-- 可以用下面三种形式指定构造参数 --&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt; &lt;!-- property 的几种情况 --&gt; &lt;property name=&quot;beanOne&quot;&gt; &lt;ref bean=&quot;anotherExampleBean&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt; &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt; 当然，除了上面举例出来的这些，还有 factory-bean、factory-method、&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt; 这几个。 继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// BeanDefinitionParserDelegate.javapublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null);}public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) { String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组， // 当然，如果你不定义 name 属性的话，就是空的了 if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; // 如果没有指定id, 那么用别名列表的第一个名字作为 beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(&quot;No XML 'id' specified - using '&quot; + beanName + &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中, // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。 if (beanDefinition != null) { // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生 if (!StringUtils.hasText(beanName)) { try { // 按照我们的思路，这里 containingBean 是 null 的 if (containingBean != null) { beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { // 如果我们不定义 id 和 name，那么我们引言里的那个例子： // 1. beanName 为：com.javadoop.example.MessageServiceImpl#0 // 2. beanClassName 为：com.javadoop.example.MessageServiceImpl beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { // 把 beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(&quot;Neither XML 'id' nor 'name' specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null;} 再看看怎么根据配置创建 BeanDefinition 实例的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } try { String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } // 创建 BeanDefinition，然后设置类信息 AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素， // 解析出来以后的信息都放到 bd 的属性中 // 解析 &lt;meta /&gt; parseMetaElements(ele, bd); // 解析 &lt;lookup-method /&gt; parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;replaced-method /&gt; parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;constructor-arg /&gt; parseConstructorArgElements(ele, bd); // 解析 &lt;property /&gt; parsePropertyElements(ele, bd); // 解析 &lt;qualifier /&gt; parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex); } catch (NoClassDefFoundError err) { error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err); } catch (Throwable ex) { error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex); } finally { this.parseState.pop(); } return null;} 到这里，我们已经完成了根据 &lt;bean /&gt; 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。 回到解析 &lt;bean /&gt; 的入口方法: 1234567891011121314151617protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { // 如果有自定义属性的话，进行相应的解析，先忽略 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // 我们把这步叫做 注册Bean 吧 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&quot;Failed to register bean definition with name '&quot; + bdHolder.getBeanName() + &quot;'&quot;, ele, ex); } // 注册完成后，发送事件，本文不展开说这个 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); }} 这里已经根据一个 &lt;bean /&gt; 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息。 注意，我们的关注点始终在 BeanDefinition 上： 12345678public class BeanDefinitionHolder implements BeanMetadataElement { private final BeanDefinition beanDefinition; private final String beanName; private final String[] aliases; ... 然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。 注册 Bean123456789101112131415161718// BeanDefinitionReaderUtils.javapublic static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); // 注册这个 Bean registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了 String[] aliases = definitionHolder.getAliases(); if (aliases != null) { for (String alias : aliases) { // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了， // 获取的时候，会先将 alias 转换为 beanName，然后再查找 registry.registerAlias(beanName, alias); } }} 别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// DefaultListableBeanFactory.java@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException { Assert.hasText(beanName, &quot;Bean name must not be empty&quot;); Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;); if (beanDefinition instanceof AbstractBeanDefinition) { try { ((AbstractBeanDefinition) beanDefinition).validate(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(...); } } // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding BeanDefinition oldBeanDefinition; // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中 oldBeanDefinition = this.beanDefinitionMap.get(beanName); // 处理重复名称的 Bean 定义的情况 if (oldBeanDefinition != null) { if (!isAllowBeanDefinitionOverriding()) { // 如果不允许覆盖的话，抛异常 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()... } else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) { // log...用框架定义的 Bean 覆盖用户自定义的 Bean } else if (!beanDefinition.equals(oldBeanDefinition)) { // log...用新的 Bean 覆盖旧的 Bean } else { // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean } // 覆盖 this.beanDefinitionMap.put(beanName, beanDefinition); } else { // 判断是否已经有其他的 Bean 开始初始化了. // 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程， // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans if (hasBeanCreationStarted()) { // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) { this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) { Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; } } } else { // 最正常的应该是进到这个分支 // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition this.beanDefinitionMap.put(beanName, beanDefinition); // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字 this.beanDefinitionNames.add(beanName); // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean， // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的 // 手动：指的是通过调用以下方法注册的 Bean： // registerSingleton(String beanName, Object singletonObject) // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean， // 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的 this.manualSingletonNames.remove(beanName); } // 这个不重要，在预初始化的时候会用到，不必管它 this.frozenBeanDefinitionNames = null; } if (oldBeanDefinition != null || containsSingleton(beanName)) { resetBeanDefinition(beanName); }} 到这里已经初始化了 Bean 容器，&lt;bean /&gt; 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。 准备 Bean 容器：prepareBeanFactory说到这里，我们回到 refresh() 方法，上面才说完 obtainFreshBeanFactory() 方法。 Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。 这里简单介绍下 prepareBeanFactory(factory) 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * * @param beanFactory the BeanFactory to configure */protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器， // 这里设置为加载当前 ApplicationContext 类的类加载器 beanFactory.setBeanClassLoader(getClassLoader()); // 设置 BeanExpressionResolver beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 添加一个 BeanPostProcessor，这个 processor 比较简单： // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调， // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware // 注意：它不仅仅回调 ApplicationContextAware // 还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们， // Spring 会通过其他方式来处理这些依赖。 beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); /** * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值， * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行 * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean */ beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类， // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它 // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样， // 感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } /** * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean， * 我们也可以选择覆盖 */ // 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } // 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } // 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); }} 在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。 初始化所有的 singleton beans我们的重点是 finishBeanFactoryInitialization(beanFactory)，这里会负责初始化所有的 singleton beans。 注意，后面的描述中，我都会使用初始化或预初始化来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。 我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 “environment”、“systemProperties” 等。 剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。 12345678910111213141516171819202122232425262728293031323334353637383940414243// AbstractApplicationContext.java// 初始化剩余的 singleton beansprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) { // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了 // 什么，看代码这里没有初始化 Bean 啊！ // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) { beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); } // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) { beanFactory.addEmbeddedValueResolver(new StringValueResolver() { @Override public String resolveStringValue(String strVal) { return getEnvironment().resolvePlaceholders(strVal); } }); } // 先初始化 LoadTimeWeaverAware 类型的 Bean // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) { getBean(weaverAwareName); } // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了， // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。 beanFactory.freezeConfiguration(); // 开始初始化 beanFactory.preInstantiateSingletons();} 从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。 preInstantiateSingletons1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// DefaultListableBeanFactory.java@Overridepublic void preInstantiateSingletons() throws BeansException { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this); } // this.beanDefinitionNames 保存了所有的 beanNames List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // 触发所有的非懒加载的 singleton beans 的初始化操作 for (String beanName : beanNames) { // 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧， // 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非抽象、非懒加载的 singletons // 如果配置了 “abstract = true”，那是不需要初始化的 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解) if (isFactoryBean(beanName)) { // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) { isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() { @Override public Boolean run() { return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); } }, getAccessControlContext()); } else { isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); } if (isEagerInit) { getBean(beanName); } } else { // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了 getBean(beanName); } } } // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化 // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略 for (String beanName : beanNames) { Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) { final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { smartSingleton.afterSingletonsInstantiated(); return null; } }, getAccessControlContext()); } else { smartSingleton.afterSingletonsInstantiated(); } } }} 接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。 getBean在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178// AbstractBeanFactory.java@Overridepublic Object getBean(String name) throws BeansException { return doGetBean(name, null, null, false);}// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，// 已经初始化过了就从容器中直接返回，否则就先初始化再返回@SuppressWarnings(&quot;unchecked&quot;)protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException { // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)， // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的 final String beanName = transformedBeanName(name); // 注意跟着这个，这个是返回值 Object bean; // 检查下是不是已经创建过了 Object sharedInstance = getSingleton(beanName); // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)， // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean if (sharedInstance != null &amp;&amp; args == null) { if (logger.isDebugEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.debug(&quot;...&quot;); } else { logger.debug(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;); } } // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance， // 如果是 FactoryBean 的话，返回它创建的那个实例对象 // (FactoryBean 知识，读者若不清楚请移步附录) bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } else { if (isPrototypeCurrentlyInCreation(beanName)) { // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常， // 往往是因为陷入了循环引用 throw new BeanCurrentlyInCreationException(beanName); } // 检查一下这个 BeanDefinition 在容器中是否存在 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) { // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有 String nameToLookup = originalBeanName(name); if (args != null) { // 返回父容器的查询结果 return (T) parentBeanFactory.getBean(nameToLookup, args); } else { // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); } } if (!typeCheckOnly) { // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。 markBeanAsCreated(beanName); } /* * 稍稍总结一下： * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean； * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。 */ try { final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 先初始化依赖的所有 Bean，这个很好理解。 // 注意，这里的依赖指的是 depends-on 中定义的依赖 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) { for (String dep : dependsOn) { // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了 if (isDependent(beanName, dep)) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;); } // 注册一下依赖关系 registerDependentBean(dep, beanName); // 先初始化被依赖项 getBean(dep); } } // 如果是 singleton scope 的，创建 singleton 的实例 if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { try { // 执行创建 Bean，详情后面再说 return createBean(beanName, mbd, args); } catch (BeansException ex) { destroySingleton(beanName); throw ex; } } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } // 如果是 prototype scope 的，创建 prototype 的实例 else if (mbd.isPrototype()) { // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); // 执行创建 Bean prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理 else { String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) { throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;); } try { Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { beforePrototypeCreation(beanName); try { // 执行创建 Bean return createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } } }); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); } catch (IllegalStateException ex) { throw new BeanCreationException(beanName, &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; + &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); } } } catch (BeansException ex) { cleanupAfterBeanCreationFailure(beanName); throw ex; } } // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) { try { return getTypeConverter().convertIfNecessary(bean, requiredType); } catch (TypeMismatchException ex) { if (logger.isDebugEnabled()) { logger.debug(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex); } throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); } } return (T) bean;} 大家应该也猜到了，接下来当然是分析 createBean 方法： 1protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException; 第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。 这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。 主要是为了以下场景，采用 @Autowired 注解注入属性值： 12345678public class MessageServiceImpl implements MessageService { @Autowired private UserService userService; public String getMessage() { return userService.getMessage(); }} 1&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt; 以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。 好了，读者要知道这么回事就可以了，继续向前。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// AbstractAutowireCapableBeanFactory.java/** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException { if (logger.isDebugEnabled()) { logger.debug(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;); } RootBeanDefinition mbdToUse = mbd; // 确保 BeanDefinition 中的 Class 被加载 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) { mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); } // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。 // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看 try { mbdToUse.prepareMethodOverrides(); } catch (BeanDefinitionValidationException ex) { throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex); } try { // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理， // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) { return bean; } } catch (Throwable ex) { throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex); } // 重头戏，创建 bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) { logger.debug(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;); } return beanInstance;} 创建 Bean我们继续往里看 doCreateBean 这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks. * &lt;p&gt;Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException { // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说 instanceWrapper = createBeanInstance(beanName, mbd, args); } // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); // 类型 Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor synchronized (mbd.postProcessingLock) { if (!mbd.postProcessed) { try { // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); } catch (Throwable ex) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, ex); } mbd.postProcessed = true; } } // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) { if (logger.isDebugEnabled()) { logger.debug(&quot;Eagerly caching bean '&quot; + beanName + &quot;' to allow for resolving potential circular references&quot;); } addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() { @Override public Object getObject() throws BeansException { return getEarlyBeanReference(beanName, mbd, bean); } }); } // Initialize the bean instance. Object exposedObject = bean; try { // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) { // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？ // 这里就是处理 bean 初始化完成后的各种回调 exposedObject = initializeBean(beanName, exposedObject, mbd); } } catch (Throwable ex) { if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) { throw (BeanCreationException) ex; } else { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex); } } if (earlySingletonExposure) { // Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) { if (exposedObject == bean) { exposedObject = earlySingletonReference; } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) { String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) { if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) { actualDependentBeans.add(dependentBean); } } if (!actualDependentBeans.isEmpty()) { throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been &quot; + &quot;wrapped. This means that said other beans do not use the final version of the &quot; + &quot;bean. This is often the result of over-eager type matching - consider using &quot; + &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;); } } } } // Register bean as disposable. try { registerDisposableBeanIfNecessary(beanName, bean, mbd); } catch (BeanDefinitionValidationException ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex); } return exposedObject;} 到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。 接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。 创建 Bean 实例我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) { // 确保已经加载了此 class Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); // 校验一下这个类的访问权限 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) { throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName()); } if (mbd.getFactoryMethodName() != null) { // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean return instantiateUsingFactoryMethod(beanName, mbd, args); } // 如果不是第一次创建，比如第二次创建 prototype bean。 // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) { synchronized (mbd.constructorArgumentLock) { if (mbd.resolvedConstructorOrFactoryMethod != null) { resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; } } } if (resolved) { if (autowireNecessary) { // 构造函数依赖注入 return autowireConstructor(beanName, mbd, null, null); } else { // 无参构造函数 return instantiateBean(beanName, mbd); } } // 判断是否采用有参构造函数 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) { // 构造函数依赖注入 return autowireConstructor(beanName, mbd, ctors, args); } // 调用无参构造函数 return instantiateBean(beanName, mbd);} 挑个简单的无参构造函数构造实例来看看： 123456789101112131415161718192021222324252627protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) { try { Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) { beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { return getInstantiationStrategy().instantiate(mbd, beanName, parent); } }, getAccessControlContext()); } else { // 实例化 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); } // 包装一下，返回 BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; } catch (Throwable ex) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex); }} 我们可以看到，关键的地方在于： 1beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); 这里会进行实际的实例化过程，我们进去看看: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// SimpleInstantiationStrategy.java@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) { // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB, // 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍 if (bd.getMethodOverrides().isEmpty()) { Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) { constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) { final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) { throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;); } try { if (System.getSecurityManager() != null) { constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() { @Override public Constructor&lt;?&gt; run() throws Exception { return clazz.getDeclaredConstructor((Class[]) null); } }); } else { constructorToUse = clazz.getDeclaredConstructor((Class[]) null); } bd.resolvedConstructorOrFactoryMethod = constructorToUse; } catch (Throwable ex) { throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex); } } } // 利用构造方法进行实例化 return BeanUtils.instantiateClass(constructorToUse); } else { // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。 // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持 return instantiateWithMethodInjection(bd, beanName, owner); }} 到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。 bean 属性注入看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// AbstractAutowireCapableBeanFactory.javaprotected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) { // bean 实例的所有属性都在这里了 PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) { if (!pvs.isEmpty()) { throw new BeanCreationException( mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); } else { // Skip property population phase for null instance. return; } } // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值， // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改， // 我也没找到有实际的使用，所以我们暂且忽略这块吧 boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) { continueWithPropertyPopulation = false; break; } } } } if (!continueWithPropertyPopulation) { return; } if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) { autowireByName(beanName, mbd, bw, newPvs); } // 通过类型装配。复杂一些 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) { autowireByType(beanName, mbd, bw, newPvs); } pvs = newPvs; } boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) { PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) { return; } } } } if (needsDepCheck) { checkDependencies(beanName, mbd, filteredPds, pvs); } } // 设置 bean 实例的属性值 applyPropertyValues(beanName, mbd, bw, pvs);} initializeBean属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。 1234567891011121314151617181920212223242526272829303132333435363738protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { invokeAwareMethods(beanName, bean); return null; } }, getAccessControlContext()); } else { // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调 invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor 的 postProcessBeforeInitialization 回调 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { // 处理 bean 中定义的 init-method， // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法 invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); } if (mbd == null || !mbd.isSynthetic()) { // BeanPostProcessor 的 postProcessAfterInitialization 回调 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;} 大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？ 附录id 和 name每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。 我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。 1beanFactory.getBean(&quot;beanName or alias&quot;); 在配置 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。 1&lt;bean id=&quot;messageService&quot; name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt; 以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。 1&lt;bean name=&quot;m1, m2, m3&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot; /&gt; 以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。 1&lt;bean class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt; 1&lt;bean class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt; beanName 为：com.javadoop.example.MessageServiceImpl#0，别名 1 个，为： com.javadoop.example.MessageServiceImpl 1&lt;bean id=&quot;messageService&quot; class=&quot;com.javadoop.example.MessageServiceImpl&quot;&gt; 以上配置的结果就是：beanName 为 messageService，没有别名。 配置是否允许 Bean 覆盖、是否允许循环依赖我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。 循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。 它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。 添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。 123456789public class NoBeanOverridingContextLoader extends ContextLoader { @Override protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) { super.customizeContext(servletContext, applicationContext); AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext; arac.setAllowBeanDefinitionOverriding(false); }} 1234567public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener { @Override protected ContextLoader createContextLoader() { return new NoBeanOverridingContextLoader(); }} 123&lt;listener&gt; &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 如果以上方式不能满足你的需求，请参考这个链接：解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题 profile我们可以把不同环境的配置分别配置到单独的文件中，举个例子： 1234567891011&lt;beans profile=&quot;development&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xsi:schemaLocation=&quot;...&quot;&gt; &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt; &lt;/jdbc:embedded-database&gt;&lt;/beans&gt; 12345678&lt;beans profile=&quot;production&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xsi:schemaLocation=&quot;...&quot;&gt; &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;&lt;/beans&gt; 应该不必做过多解释了吧，看每个文件第一行的 profile=””。 当然，我们也可以在一个配置文件中使用： 1234567891011121314151617&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xsi:schemaLocation=&quot;...&quot;&gt; &lt;beans profile=&quot;development&quot;&gt; &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt; &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=&quot;production&quot;&gt; &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt; &lt;/beans&gt;&lt;/beans&gt; 理解起来也很简单吧。 接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？ Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。 最简单的方式莫过于在程序启动的时候指定： 1-Dspring.profiles.active=&quot;profile1,profile2&quot; profile 可以激活多个 当然，我们也可以通过代码的形式从 Environment 中设置 profile： 1234AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);ctx.refresh(); // 重启 如果是 SpringBoot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件。 其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile： 1java -Dspring.profiles.active=prod -jar JavaDoop.jar 如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。 工厂模式生成 Bean请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean。 设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。 静态工厂： 1&lt;bean id=&quot;clientService&quot; class=&quot;examples.ClientService&quot; factory-method=&quot;createInstance&quot;/&gt; 1234567public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} // 静态方法 public static ClientService createInstance() { return clientService; }} 实例工厂： 1234567891011&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createClientServiceInstance&quot;/&gt;&lt;bean id=&quot;accountService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createAccountServiceInstance&quot;/&gt; 12345678910public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; }} FactoryBeanFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。 12345public interface FactoryBean&lt;T&gt; { T getObject() throws Exception; Class&lt;T&gt; getObjectType(); boolean isSingleton();} 12345public class Person { private Car car; private void setCar(Car car) { this.car = car; } } 我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来： 1234567891011121314151617181920212223242526272829public class MyCarFactoryBean implements FactoryBean&lt;Car&gt; { private String make; private int year; public void setMake(String m) { this.make = m; } public void setYear(int y) { this.year = y; } public Car getObject() { // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种 CarBuilder cb = CarBuilder.car(); if (year != 0) cb.setYear(this.year); if (StringUtils.hasText(this.make)) cb.setMake(this.make); return cb.factory(); } public Class&lt;Car&gt; getObjectType() { return Car.class; } public boolean isSingleton() { return false; }} 我们看看装配的时候是怎么配置的： 1234567&lt;bean class = &quot;com.javadoop.MyCarFactoryBean&quot; id = &quot;car&quot;&gt; &lt;property name = &quot;make&quot; value =&quot;Honda&quot;/&gt; &lt;property name = &quot;year&quot; value =&quot;1984&quot;/&gt;&lt;/bean&gt;&lt;bean class = &quot;com.javadoop.Person&quot; id = &quot;josh&quot;&gt; &lt;property name = &quot;car&quot; ref = &quot;car&quot;/&gt;&lt;/bean&gt; 看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。 说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java config 的方式来配置，这里有什么不一样呢？ 12345678910111213141516171819@Configurationpublic class CarConfiguration { @Bean public MyCarFactoryBean carFactoryBean() { MyCarFactoryBean cfb = new MyCarFactoryBean(); cfb.setMake(&quot;Honda&quot;); cfb.setYear(1984); return cfb; } @Bean public Person aPerson() { Person person = new Person(); // 注意这里的不同 person.setCar(carFactoryBean().getObject()); return person; }} 这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。 初始化 Bean 的回调有以下四种方案： 1&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt; 123456public class AnotherExampleBean implements InitializingBean { public void afterPropertiesSet() { // do some initialization work }} 1234@Bean(initMethod = &quot;init&quot;)public Foo foo() { return new Foo();} 1234@PostConstructpublic void init() {} 销毁 Bean 的回调1&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt; 123456public class AnotherExampleBean implements DisposableBean { public void destroy() { // do some destruction work (like releasing pooled connections) }} 1234@Bean(destroyMethod = &quot;cleanup&quot;)public Bar bar() { return new Bar();} 1234@PreDestroypublic void cleanup() {} ConversionService最有用的场景：用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定。 像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。 12345678&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。 下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。 来看一个很简单的例子，这样比什么都管用。 1234567891011public class StringToDateConverter implements Converter&lt;String, Date&gt; { @Override public Date convert(String source) { try { return DateUtils.parseDate(source, &quot;yyyy-MM-dd&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd HH:mm&quot;, &quot;HH:mm:ss&quot;, &quot;HH:mm&quot;); } catch (ParseException e) { return null; } }} 只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。 Bean 继承在初始化 Bean 的地方，我们说过了这个： 1RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); 这里涉及到的就是 &lt;bean parent=”” /&gt; 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。 首先，我们要明白，这里的继承和 Java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。 Spring 中提供了继承自 AbstractBeanDefinition 的 ChildBeanDefinition 来表示 child bean。 看如下一个例子: 1234567891011121314&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot; class=&quot;org.springframework.beans.TestBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;inheritsWithDifferentClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot; parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;&lt;/bean&gt; parent bean 设置了 abstract=”true” 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。 child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。 当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。 比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。 1234&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;&lt;/bean&gt; 方法注入一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。 但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。 一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。 另一种解决方案就是这里要介绍的通过使用 Lookup method。 lookup-method我们来看一下 Spring Reference 中提供的一个例子： 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager { public Object process(Object commandState) { // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); } // okay... but where is the implementation of this method? protected abstract Command createCommand();} xml 配置 &lt;lookup-method /&gt;： 123456789&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt; &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;&lt;/bean&gt; Spring 采用 CGLIB 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。 lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 了，其他不变： 1234567891011public abstract class CommandManager { public Object process(Object commandState) { MyCommand command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup(&quot;myCommand&quot;) protected abstract Command createCommand();} 注意，既然用了注解，要配置注解扫描：&lt;context:component-scan base-package=”com.javadoop” /&gt; 甚至，我们可以像下面这样： 1234567891011public abstract class CommandManager { public Object process(Object commandState) { MyCommand command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup protected abstract MyCommand createCommand();} 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。 replaced-method记住它的功能，就是替换掉 bean 中的一些方法。 12345678public class MyValueCalculator { public String computeValue(String input) { // some real code... } // some other methods...} 方法覆写，注意要实现 MethodReplacer 接口： 123456789public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer { public Object reimplement(Object o, Method m, Object[] args) throws Throwable { // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; }} 配置也很简单： 12345678&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt; &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt; &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt; arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。 BeanPostProcessor应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义： 123456public interface BeanPostProcessor { Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;} 看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。 首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。 我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。 那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。 最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？ 如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。 首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。","link":"/2018/04/11/zh/programing/java/spring/code_analysis/spring_ioc/"}],"tags":[{"name":"ai","slug":"ai","link":"/tags/ai/"},{"name":"spring","slug":"spring","link":"/tags/spring/"}],"categories":[{"name":"zh","slug":"zh","link":"/categories/zh/"},{"name":"others","slug":"zh/others","link":"/categories/zh/others/"},{"name":"english","slug":"zh/english","link":"/categories/zh/english/"},{"name":"work","slug":"zh/work","link":"/categories/zh/work/"},{"name":"hardware","slug":"zh/hardware","link":"/categories/zh/hardware/"},{"name":"programing","slug":"zh/programing","link":"/categories/zh/programing/"},{"name":"basis","slug":"zh/english/basis","link":"/categories/zh/english/basis/"},{"name":"ielts","slug":"zh/english/ielts","link":"/categories/zh/english/ielts/"},{"name":"java","slug":"zh/programing/java","link":"/categories/zh/programing/java/"},{"name":"ai","slug":"zh/programing/ai","link":"/categories/zh/programing/ai/"},{"name":"basis","slug":"zh/programing/basis","link":"/categories/zh/programing/basis/"},{"name":"design ideas","slug":"zh/programing/design-ideas","link":"/categories/zh/programing/design-ideas/"},{"name":"book read","slug":"zh/programing/book-read","link":"/categories/zh/programing/book-read/"},{"name":"docker","slug":"zh/programing/docker","link":"/categories/zh/programing/docker/"},{"name":"algorithm","slug":"zh/programing/basis/algorithm","link":"/categories/zh/programing/basis/algorithm/"},{"name":"data structure","slug":"zh/programing/basis/data-structure","link":"/categories/zh/programing/basis/data-structure/"},{"name":"database","slug":"zh/programing/basis/database","link":"/categories/zh/programing/basis/database/"},{"name":"algorithms","slug":"zh/programing/book-read/algorithms","link":"/categories/zh/programing/book-read/algorithms/"},{"name":"linux","slug":"zh/programing/book-read/linux","link":"/categories/zh/programing/book-read/linux/"},{"name":"java","slug":"zh/programing/book-read/java","link":"/categories/zh/programing/book-read/java/"}],"pages":[{"title":"About","text":"Education background 2015.9 - 2019.7 WUYI University Electronic Information Engineering-Information Security (Bachelor’s degree)Major courses: Computer Network, Introduction to Database System, Operating System Principle, Applied Cryptography, Information Security Fundamentals, Data Security and Disaster Recovery Management.GPA: 3.9/5.0 Rank: 1/168 Personal Strengths • Familiar with Java open source frameworks such as SpringBoot, MyBatis, SpringCloud;• Proficient in using MySQL/Oracle/Redis and other databases;• Familiar with Linux operating system, Shell, Python scripting;• Familiar with the configuration and deployment of application servers such as Tomcat/Nginx;• Familiar with commonly used algorithms, data structures and network protocols;• Proficient in JavaScript, jQuery, Bootstrap, Vue and other front-end technologies and applet development. work experience 2019.07 - 2022.12 Taishan Radio and Television Development/Operation EngineerWorked in the New Media Department, mainly responsible for the demand applet, website development, operation and maintenance for the department. Work project experience 2019.07 - 2019.10 Feedback applet full stack development• Responsible for the function development and page design of the Mini Program;• Responsible for the development/testing/launching of the backend management functions of the Mini Program;• Responsible for the development of server backend RESTful API;• Maintain data interaction programs for servers, socket hardware and cloud platforms. intern experience 2018.09 - 2019.03 Java Development Intern of AsiaInfo Technology (China) Guangzhou Branch / Unicom Business UnitWorked in the China Unicom business department, mainly responsible for the demand development tasks for the Unicom Wo music platform. There are many sub-platforms under the platform, including the deduction platform, the capability hub platform, the flow-free platform, and the capability conversion platform provided by various service providers. It is mainly based on MariaDB database cluster and Redis cluster for data storage, uses Kafka message middleware, and builds a high-availability system based on ZooKeeper cluster. Currently, the entire platform system is deployed on China Unicom’s servers in the form of Docker microservices. 2018.05 - 2018.07 Java Development Intern in Guangdong Dilang Technology Co., Ltd.Independently responsible for the development of the back-end API of the mobile terminal of the Jiangmen Human Resources and Social Security Bureau Examination System, and cooperated with the front-end to complete the corresponding functional tests, researched the implementation of OAuth2 authentication and resource invocation in the enterprise management system, improved the communication and coordination ability of his own team, and further became proficient in the software. Design, use of the SpringBoot framework and Oracle database. University project experience 2017.11 - 2018.05 Smart socket APP APP + back-end development• Responsible for the function development and page design of Android APP;• Responsible for the development of server backend RESTful API;• Maintain data interaction programs for servers, socket hardware and cloud platforms.Project: https://github.com/Zoctan/SmartHub 2017.08 - 2018.03 WYUOJ platform back-end development + crawler• Responsible for the development of the back-end RESTful API of the Online Judge platform on campus;• Responsible for the development of the main OJ evaluation functions of the platform;• Responsible for developing crawlers that crawl Leetcode topics, and parse the retrieved data into an agreed format for use by the OJ platform.Project: https://github.com/QinZhen001/CodeNut Awards and Honors 2021.12 Information Security Engineer Intermediate Certificate2021.05 Excellent employee of Taishan Radio and Television Station2018.08 Second Prize of National Competition of Computer Design Competition for Chinese College Students2018.05 “Discovery Cup” Internet Software Design Competition First Prize in South China Division and Third Prize in National Competition2018.04 “Blue Bridge Cup” Software and Information Technology Professionals Competition Guangdong Province Second Prize2018.03 Second Prize in the South China Division of the National University Internet of Things Application Innovation Competition2016-17 School “Dilang Cup” Software Design Competition Third Prize/Second Prize2016-19 “Three Good Students” for 4 consecutive years, first-class scholarship; National Scholarship, National Inspirational Scholarship Self-evaluation Familiar with PHP/Java/Python/JavaScript languages, understand basic data structures and algorithms; like to do small things, currently working hard on the road of full-stack development, and hope to make achievements in back-end architecture in the near future.","link":"/about/index-en.html"},{"title":"About","text":"教育背景 2015.9 - 2019.7 五邑大学 电子信息工程-信息安全（本科）主修课程：计算机网络、数据库系统概论、操作系统原理、应用密码学、信息安全基础、数据安全与灾备管理。GPA：3.9/5.0 排名：1/168 个人优势 • 熟悉 SpringBoot、MyBatis、SpringCloud 等 Java 开源框架；• 熟练使用 MySQL/Oracle/Redis 等数据库；• 熟悉 Linux 操作系统，Shell，Python 脚本；• 熟悉 Tomcat/Nginx 等应用服务器的配置和部署；• 熟悉常用的算法，数据结构和网络协议；• 熟练使用 JavaScript、jQuery、Bootstrap、Vue 等前端技术和小程序开发。 工作经历 2019.07 - 2022.12 台山市广播电视台 开发/运营工程师任职新媒体部部，主要负责为部门做需求小程序、网站开发、运营、维护工作。 工作项目经历 2019.07 - 2019.10 报料小程序 全栈开发• 负责小程序的功能开发及页面设计；• 负责小程序后台的管理功能开发/测试/上线；• 负责服务器后端 RESTfulAPI 的开发；• 维护服务端、插座硬件和云平台的数据交互程序。 实习经历 2018.09 - 2019.03 亚信科技(中国)广州分公司／联通事业部 Java 开发实习生任职联通事业部，主要负责为联通沃音乐平台做需求开发任务。该平台下属的子平台较多，包括扣费平台，能力枢纽平台，免流平台，以及各个服务商提供的能力转换平台。主要基于 MariaDB 数据库集群和 Redis 集群做数据存储，使用 Kafka 消息中间件，基于 ZooKeeper 集群搭建高可用系统，目前整套平台系统以 Docker 微服务方式部署在联通的服务器上。 2018.05 - 2018.07 广东迪浪科技股份有限公司 Java 开发实习生独立负责江门人社局考试系统移动端的后端 API 开发，配合前端完成相应的功能测试，研究 OAuth2 在企业管理系统的身份认证和资源调用实现，提高了自己的团队沟通协调能力，进一步熟练了软件设计、SpringBoot 框架和 Oracle 数据库的使用。 大学项目经历 2017.11 - 2018.05 智能插座 APP APP + 后端开发• 负责 Android APP 的功能开发及页面设计；• 负责服务器后端 RESTfulAPI 的开发；• 维护服务端、插座硬件和云平台的数据交互程序。项目: https://github.com/Zoctan/SmartHub 2017.08 - 2018.03 WYUOJ 平台 后端开发 + 爬虫• 负责校内 Online Judge 平台后端 RESTfulAPI 的开发；• 负责平台主要的 OJ 评测功能开发；• 负责开发抓取 Leetcode 题目的爬虫，将抓回的数据解析成约定的格式，供 OJ 平台使用。项目: https://github.com/QinZhen001/CodeNut 奖项荣誉 2021.12 信息安全工程师中级资格证2021.05 台山市广播电视台优秀员工2018.08 中国大学生计算机设计大赛国赛二等奖2018.05 “发现杯”互联网软件设计大赛华南赛区一等奖、国赛三等奖2018.04 “蓝桥杯”软件和信息技术专业人才大赛广东省二等奖2018.03 全国高校物联网应用创新大赛华南赛区二等奖2016-17 校“迪浪杯”软件设计大赛三等奖/二等奖2016-19 连续4年校“三好学生”，一等奖学金；国家奖学金，国家励志奖学金 自我评价 熟悉 PHP/Java/Python/JavaScript 语言，了解基本的数据结构和算法；喜欢做些小东西，目前正努力走在全栈开发的路上，希望能在不久的未来在后端架构有所成就。","link":"/about/index-zh.html"},{"title":"About","text":"自我评价 一个安静的全栈开发工程师。","link":"/about/index.html"},{"title":"","text":"(function () { var now = new Date() function createRuntime() { var siteStartDate = new Date(\"12/12/2017 12:00:00\") now.setTime(now.getTime() + 250) var days = Math.floor((now - siteStartDate) / 1000 / 60 / 60 / 24) var hours = Math.floor((now - siteStartDate) / 1000 / 60 / 60 - (24 * days)) var minutes = Math.floor((now - siteStartDate) / 1000 / 60 - (24 * 60 * days) - (60 * hours)) var seconds = Math.floor((now - siteStartDate) / 1000 - (24 * 60 * 60 * days) - (60 * 60 * hours) - (60 * minutes)) if (!document.getElementById(\"runtime\")) { document.getElementsByTagName('footer')[0] .getElementsByClassName('is-size-7')[0] .insertAdjacentHTML('beforeend', `Loading runtime...`) } else { var siteStartDateString = siteStartDate.toUTCString().split(' ').slice(0, 4).join(' ') document.getElementById(\"runtime\").innerHTML = `Started at ${siteStartDateString}. My site has been running for ${days} days ${hours} hours ${minutes} minutes ${seconds} seconds.` } } setInterval(() => createRuntime(), 250) })()","link":"/js/add_runtime.js"},{"title":"","text":"(function () { // 存在文章时间 var times = document.getElementsByTagName('time') if (times.length === 0) { return } // 存在文章内容 var posts = document.getElementsByClassName('card-content article') if (posts.length === 0) { return } // 发布时间 var postedTime = new Date(times[0].dateTime) // 更新时间 var updatedTime = new Date(times[1].dateTime) // 当前时间 var now = Date.now() var interval = parseInt(now - postedTime) var oneYearInMillisecond = 3600 * 24 * 30 * 12 * 1000 // 发布时间超过3年（毫秒） if (interval > oneYearInMillisecond * 3) { var years = parseInt(interval / oneYearInMillisecond) posts[0].insertAdjacentHTML('afterbegin', ` This article published ${years} years ago, some information may be out of date, please read carefully. `) } })()","link":"/js/post_date_tips.js"},{"title":"","text":"(function () { // 找到含有 Powered by 的元素 var copyright = document.evaluate(\"//p[contains(text(), 'Powered by')]\", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue // 找到要删除的这段内容，替换为空 var poweredBy = copyright.getInnerHTML().substring(copyright.getInnerHTML().indexOf('&nbsp;&nbsp;Powered by '), copyright.getInnerHTML().indexOf('","link":"/js/remove_powered_by.js"}]}